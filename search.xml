<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode题解-242-有效的字母异位词</title>
    <url>/2020/01/23/leetcode%E9%A2%98%E8%A7%A3-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="c实现">c++实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt; t.size())    swap(s, t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : s)</span><br><span class="line">        &#123;</span><br><span class="line">            --m[it];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it: t)</span><br><span class="line">        &#123;</span><br><span class="line">            ++m[it];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it: m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.second != <span class="number">0</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用哈希表构成一个<strong>计数器</strong>的效果。</li>
<li>利用<code>ctor</code>初始化<code>int</code>变量默认值是0，
<ul>
<li>在<code>s</code>里出现过，则自减1；</li>
<li>在<code>t</code>里出现过，则自增1；</li>
</ul></li>
<li>要注意，<code>s</code>, <code>t</code>字符串的大小可能不一样。所以需要在计数前，交换一次。</li>
</ul>
<h3 id="官方-way"><a href="https://leetcode-cn.com/problems/valid-anagram/solution/you-xiao-de-zi-mu-yi-wei-ci-by-leetcode/" target="_blank" rel="noopener">官方 way</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() != t.size())   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> counter[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ++counter[s[i] - <span class="string">'a'</span>];</span><br><span class="line">            --counter[t[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it: counter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (it != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用一个<code>int</code>数组构造出一个计数器</li>
</ul>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/valid-anagram/solution/you-xiao-de-zi-mu-yi-wei-ci-by-leetcode/</p>
]]></content>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-84-柱状图中最大的矩形</title>
    <url>/2020/01/19/leetcode%E9%A2%98%E8%A7%A3-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>test env transform on same PC</title>
    <url>/2020/01/14/test-env-transform-on-same-PC/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-239-滑动窗口最大值</title>
    <url>/2020/01/13/leetcode%E9%A2%98%E8%A7%A3-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="labuladong-way"><a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/dan-diao-dui-lie-by-labuladong/" target="_blank" rel="noopener">labuladong way</a></h3>
<h4 id="单调队列">单调队列</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonotonicQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!data.empty() &amp;&amp; data.back() &lt; n) </span><br><span class="line">            data.pop_back();</span><br><span class="line">        data.push_back(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data.front(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.empty() &amp;&amp; data.front() == n)</span><br><span class="line">            data.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    MonotonicQueue window;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) &#123; <span class="comment">//先填满窗口的前 k - 1</span></span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 窗口向前滑动</span></span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">            res.push_back(window.max());</span><br><span class="line">            window.pop(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同于一般最大单调栈之处:</p>
<ul>
<li>只需求滑窗k里面的最大的一个值出来，也就意味着求出最大的max之后，max之前的所有元素可以丢掉了.</li>
<li>仅在<code>滑窗大小 &lt; k</code>时，元素才需push入栈。</li>
</ul>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/sliding-window-maximum/solution/dan-diao-dui-lie-by-labuladong/</p>
]]></content>
      <tags>
        <tag>单调栈</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-901-股票价格跨度</title>
    <url>/2020/01/07/leetcode%E9%A2%98%E8%A7%A3-901-%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/online-stock-span/" target="_blank" rel="noopener">题目</a></h2>
<h4 id="单调递增最大栈">单调递增最大栈</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; prices, cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!prices.empty() &amp;&amp; prices.top() &lt;= price)</span><br><span class="line">        &#123;</span><br><span class="line">            w += cache.top();</span><br><span class="line">            prices.pop();</span><br><span class="line">            cache.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        prices.push(price);</span><br><span class="line">        cache.push(w);</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner* obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>单调栈模板的伪代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (遍历这个数组)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">	&#123;</span><br><span class="line">		栈顶元素出栈;</span><br><span class="line">		对这个出栈值做a操作;</span><br><span class="line">	&#125;</span><br><span class="line">	入栈当前数据;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (栈不为空)</span><br><span class="line">&#123;</span><br><span class="line">	栈顶元素出栈;</span><br><span class="line">	对这个出栈值做b操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题在于，因为单调栈是要把元素都丢弃的，状态都被“折叠”了，我们会丢失长度，所以容易想到，我们需要cache一下之前栈内元素被折叠的长度 cache有很多种方式，可以用hash表等数据结构，也可以用动态规划 但这题的更优解是，使用另一个同步栈来缓存，读者可以根据下面第一版的代码，动笔推导一下折叠过程，就能体会同步栈工作的原理了。</p>
<p>都说编程旷世难题是取名字，名字取好了，问题也就解决了一半（才怪 我们可以将两个栈分别命名为 prices 和 cache</p>
<p>然后就有了下面初版的代码</p>
<p>我们如果发现插入元素满足本身栈的递减需求，则直接返回1，因为该值前一个值是比它大的 如果不满足，则开始折叠，并将栈中，值比它小的所有段落都累计起来，再将自己插入栈中即可</p>
<h2 id="总结">总结</h2>
<ul>
<li>单调栈的题目复杂化方法
<ul>
<li>总会在 <strong>对出栈值做a操作</strong> 和 <strong>对出栈值做b操作</strong> 这2个地方进行一些复杂化</li>
<li>会在 <strong>出栈值出栈的存储方式/处理方式</strong> 进行一些复杂化的操作</li>
</ul></li>
</ul>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/online-stock-span/solution/gu-piao-jie-ge-kua-du-by-leetcode/</p>
]]></content>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈.md</title>
    <url>/2020/01/07/%E5%8D%95%E8%B0%83%E6%A0%88-md/</url>
    <content><![CDATA[<h2 id="单调栈">单调栈</h2>
<p>单调栈模板的伪代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (遍历这个数组)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">	&#123;</span><br><span class="line">		栈顶元素出栈;</span><br><span class="line">		对这个出栈值做a操作;</span><br><span class="line">	&#125;</span><br><span class="line">	入栈当前数据;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (栈不为空)</span><br><span class="line">&#123;</span><br><span class="line">	栈顶元素出栈;</span><br><span class="line">	对这个出栈值做b操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/online-stock-span/solution/dan-diao-zhan-tao-lu-xie-fa-you-hua-wei-guan-fang-/</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-739-每日温度</title>
    <url>/2020/01/07/leetcode%E9%A2%98%E8%A7%A3-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="最大单调递增栈">最大单调递增栈</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(T.size());</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; T.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; T[s.top()] &lt; T[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[s.top()] = i - s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[s.top()] = <span class="number">0</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; res.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = <span class="built_in">map</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是发现时间/空间复杂度都很低，</p>
<ul>
<li>不应该是所有的<code>元素</code>和<code>右边最大(小)元素</code>都用<code>tuple</code>存放在一个容器内。</li>
<li>而应该遍历的时候就直接将结果存放起来</li>
</ul>
<p>优化代码结构后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(T.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; T.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; T[s.top()] &lt; T[i])</span><br><span class="line">            &#123;</span><br><span class="line">                res[s.top()] = i - s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode/</p>
]]></content>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-503-下一个更大元素Ⅱ</title>
    <url>/2020/01/07/leetcode%E9%A2%98%E8%A7%A3-503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%E2%85%A1/</url>
    <content><![CDATA[<h3 id="labuladong-way"><a href="https://leetcode-cn.com/problems/next-greater-element-ii/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-2/" target="_blank" rel="noopener">labuladong way</a></h3>
<h4 id="不严格单调递增栈">不严格单调递增栈</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElements(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n); <span class="comment">// 存放结果</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">// 假装这个数组长度翻倍了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n])</span><br><span class="line">            s.pop();</span><br><span class="line">        res[i % n] = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">        s.push(nums[i % n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="why">Why?</h3>
<ul>
<li>为什么这里是用 <strong>不严格的单调递增栈</strong> 而不是 <strong>严格的单调递增栈</strong></li>
<li>为什么通过<strong>索引翻倍-1</strong>后，是选择方向遍历元素的，而不是正向遍历？</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li><p>通过<strong>索引翻倍-1</strong> 和 <strong>%</strong>运算，来达到模拟数组中元素翻倍的效果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假装这个数组长度翻倍了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n])</span><br><span class="line">		s.pop();</span><br><span class="line">	res[i % n] = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">	s.push(nums[i % n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同时，在元素出栈后，对栈空状态进行判断，</p>
<ul>
<li>若空了则，<code>res</code>对应值为<code>-1</code></li>
<li>若不空则，<code>res</code>对应值为<code>n</code></li>
<li>省去了一个存放<code>tuple</code>的容器的空间大小</li>
</ul></li>
</ul>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/next-greater-element-ii/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-2/</p>
]]></content>
      <tags>
        <tag>循环数组</tag>
        <tag>Next Great Number</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-496-下一个更大元素Ⅰ</title>
    <url>/2020/01/06/leetcode%E9%A2%98%E8%A7%A3-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%E2%85%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="官方解way"><a href="https://leetcode-cn.com/problems/next-greater-element-i/solution/xia-yi-ge-geng-da-yuan-su-i-by-leetcode/" target="_blank" rel="noopener">官方解way</a></h3>
<h4 id="最大单调递增栈">最大单调递增栈</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt; nums2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[s.top()] = nums2[i];</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[s.top()] = <span class="number">-1</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vi.push_back(<span class="built_in">map</span>[nums1[i]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最大单调递增栈的流程">最大单调递增栈的流程：</h4>
<p>数组中元素依次进栈:</p>
<ol type="1">
<li>假如<strong>栈不为空</strong> 且 <strong>栈顶元素小于数组当前元素</strong>, 则将 <strong>栈顶元素出栈</strong> 直至 <strong>栈不为空</strong> 或 <strong>栈顶元素 大于等于 数组当前元素</strong>
<ul>
<li>将栈顶元素和第一个大于栈顶(的栈顶右边)元素，形成一个<code>tuple</code></li>
<li>此处是放到<code>unordered_map</code>中来</li>
</ul></li>
<li>当前元素进栈</li>
<li>当数组中所有元素遍历完之后，将栈中元素依次弹出</li>
<li>遍历存放<code>tuple</code>的容器</li>
</ol>
<h2 id="总结">总结</h2>
<p>这是一个很经典的单调栈题。</p>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/next-greater-element-i/solution/xia-yi-ge-geng-da-yuan-su-i-by-leetcode/</p>
]]></content>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-42-接雨水</title>
    <url>/2020/01/05/leetcode%E9%A2%98%E8%A7%A3-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="官方way">官方way</h3>
<h4 id="最大单调递减栈">3. (最大)单调递减栈</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != height.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; height[cur] &gt; height[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> top = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (s.empty())  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> dist = cur - s.top() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> bounded_height = min(height[s.top()], height[cur]) - height[top];</span><br><span class="line">                ans += dist * bounded_height;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s.push(cur++);</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="维护一个最大单调递减栈的流程如下">维护一个最大单调递减栈的流程如下</h5>
<p>让数组中元素依次进栈:</p>
<ul>
<li><p><strong>假如栈空</strong>，元素直接进栈；</p></li>
<li><p><strong>假如栈顶top元素小于数组cur元素</strong>，则将数组内元素依次弹出直至：</p>
<ul>
<li><p><strong>栈顶元素大于数组cur元素</strong></p></li>
<li><p><strong>栈空</strong></p>
<ul>
<li><p><strong>若栈顶元素pop()后且此时栈不为空</strong>，</p>
<p><code>dist = cur - s.top() - 1;</code>,</p>
<p><code>bounded_height = min(height[s.top()], height[cur]) - height[top];</code></p>
<p><code>ans += dist * bounded_height;</code></p>
<p>由此累加<code>cur</code>元素到<code>top</code>元素的矩形长度进<code>ans</code>;</p></li>
</ul></li>
</ul></li>
<li><p><strong>假如数组中无元素</strong>，则对栈中元素依次出栈;</p></li>
</ul>
<p>PS：在这里是对数组的索引进行进栈操作，而不是具体到元素。</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-199-二叉树的右视图</title>
    <url>/2020/01/05/leetcode%E9%A2%98%E8%A7%A3-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="section"></h2>
<h2 id="section-1"></h2>
<h3 id="官方解">官方解</h3>
<h4 id="非递归dfs">非递归dfs</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rightMostValAtDepth;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; heightStack;</span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        heightStack.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!nodeStack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            root = nodeStack.top(); nodeStack.pop();</span><br><span class="line">            <span class="keyword">int</span> depth = heightStack.top(); heightStack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root)</span><br><span class="line">            &#123;</span><br><span class="line">                maxDepth = max(maxDepth, depth);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!rightMostValAtDepth.count(depth))</span><br><span class="line">                &#123;</span><br><span class="line">                    rightMostValAtDepth[depth] = root-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nodeStack.push(root-&gt;left);</span><br><span class="line">                nodeStack.push(root-&gt;right);</span><br><span class="line">                heightStack.push(depth+<span class="number">1</span>);</span><br><span class="line">                heightStack.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> depth = <span class="number">0</span>; depth &lt;= maxDepth; ++depth)</span><br><span class="line">        &#123;</span><br><span class="line">            vi.push_back(rightMostValAtDepth[depth]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>非递归实现DFS遍历 + 带 树高 状态</p>
<h4 id="非递归bfs">非递归BFS</h4>
<h5 id="java实现">java实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max_depth = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* These two Queues are always synchronized, providing an implicit</span></span><br><span class="line"><span class="comment">         * association values with the same offset on each Queue. */</span></span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; depthQueue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        nodeQueue.add(root);</span><br><span class="line">        depthQueue.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeQueue.remove();</span><br><span class="line">            <span class="keyword">int</span> depth = depthQueue.remove();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                max_depth = Math.max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* The last node that we encounter at a particular depth contains</span></span><br><span class="line"><span class="comment">                * the correct value, so the correct value is never overwritten. */</span></span><br><span class="line">                rightmostValueAtDepth.put(depth, node.val);</span><br><span class="line"></span><br><span class="line">                nodeQueue.add(node.left);</span><br><span class="line">                nodeQueue.add(node.right);</span><br><span class="line">                depthQueue.add(depth+<span class="number">1</span>);</span><br><span class="line">                depthQueue.add(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Construct the solution based on the values that we end up with at the</span></span><br><span class="line"><span class="comment">         * end. */</span></span><br><span class="line">        List&lt;Integer&gt; rightView = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> depth = <span class="number">0</span>; depth &lt;= max_depth; depth++) &#123;</span><br><span class="line">            rightView.add(rightmostValueAtDepth.get(depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="c实现">C++实现</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rightMostValAtDep;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; nodeQue;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; heightQue;</span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        nodeQue.push(root);</span><br><span class="line">        heightQue.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!nodeQue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            root = nodeQue.front();     nodeQue.pop();</span><br><span class="line">            <span class="keyword">int</span> height = heightQue.front(); heightQue.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root)</span><br><span class="line">            &#123;</span><br><span class="line">                maxDepth = max(maxDepth, height);</span><br><span class="line"></span><br><span class="line">                rightMostValAtDep[height] = root-&gt;val;</span><br><span class="line"></span><br><span class="line">                nodeQue.push(root-&gt;left);</span><br><span class="line">                nodeQue.push(root-&gt;right);</span><br><span class="line">                heightQue.push(height+<span class="number">1</span>);</span><br><span class="line">                heightQue.push(height+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxDepth; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vi.push_back(rightMostValAtDep[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>非递归实现BFS遍历 + 带 树高 状态</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-669-修剪二叉搜索树</title>
    <url>/2020/01/02/leetcode%E9%A2%98%E8%A7%A3-669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener">题目</a></h2>
<p>我的思路是先得到满足要求的节点，再重新构建二叉搜索树，不过显然不是最优解。</p>
<h3 id="官方way"><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/solution/xiu-jian-er-cha-sou-suo-shu-by-leetcode/" target="_blank" rel="noopener">官方way</a></h3>
<h4 id="递归-状态判断">递归 + 状态判断</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; R) <span class="keyword">return</span> trimBST(root.left, L, R);</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; L) <span class="keyword">return</span> trimBST(root.right, L, R);</span><br><span class="line"></span><br><span class="line">        root.left = trimBST(root.left, L, R);</span><br><span class="line">        root.right = trimBST(root.right, L, R);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剪枝思路：</p>
<ul>
<li><p><code>root-&gt;val &lt; L</code>,</p>
<p>root及左孩子剪枝，右孩子提升为root</p></li>
<li><p><code>root-&gt;val &gt; R</code></p>
<p>root及右孩子剪枝，左孩子提升为root</p></li>
<li><p><code>L &lt;= root-&gt;val &amp;&amp; root-&gt;val &lt;= R</code></p>
<p>不需要对root剪枝，递归调用左右孩子</p></li>
</ul>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/trim-a-binary-search-tree/solution/xiu-jian-er-cha-sou-suo-shu-by-leetcode/</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-404-左叶子之和</title>
    <url>/2020/01/02/leetcode%E9%A2%98%E8%A7%A3-404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-897-递增顺序查找树</title>
    <url>/2020/01/02/leetcode%E9%A2%98%E8%A7%A3-897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="中序遍历用vector存储结果-按vector中结果依次构建树">中序遍历用vector存储结果 + 按vector中结果依次构建树</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        inOrder(root-&gt;left, vi);</span><br><span class="line">        vi.push_back(root-&gt;val);</span><br><span class="line">        inOrder(root-&gt;right, vi);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">        inOrder(root, vi);</span><br><span class="line"></span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        TreeNode* cur = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it: vi)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;right = <span class="keyword">new</span> TreeNode(it);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="section"></h4>
<h4 id="就地拼接-不使用额外空间复杂度">就地拼接 + 不使用额外空间复杂度</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* cur;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        inOrder(node-&gt;left);</span><br><span class="line">        </span><br><span class="line">        node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        cur-&gt;right = node;</span><br><span class="line">        cur = node;</span><br><span class="line"></span><br><span class="line">        inOrder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        cur = res;</span><br><span class="line">        inOrder(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/increasing-order-search-tree/solution/di-zeng-shun-xu-cha-zhao-shu-by-leetcode/</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-979-在二叉树中分配硬币</title>
    <url>/2020/01/02/leetcode%E9%A2%98%E8%A7%A3-979-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="官方way"><a href="https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/solution/zai-er-cha-shu-zhong-fen-pei-ying-bi-by-leetcode/" target="_blank" rel="noopener">官方way</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distributeCoins</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> L = dfs(node.left);</span><br><span class="line">        <span class="keyword">int</span> R = dfs(node.right);</span><br><span class="line">        ans += Math.abs(L) + Math.abs(R);</span><br><span class="line">        <span class="keyword">return</span> node.val + L + R - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种抽象的思维：</p>
<ul>
<li>抽象：硬币数 <span class="math inline">\(\rightarrow\)</span> 负载量，考虑成: <span class="math inline">\(一个节点的负载量 = abs(硬币数-1)\)</span></li>
<li>节点间的硬币的移动数量: <code>abs(dfs(node-&gt;left))</code> + <code>abs(dfs(node-&gt;right))</code></li>
</ul>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/solution/zai-er-cha-shu-zhong-fen-pei-ying-bi-by-leetcode/</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-222-完全二叉树的节点个数</title>
    <url>/2020/01/02/leetcode%E9%A2%98%E8%A7%A3-222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="wanglihao-way"><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">Wanglihao way</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> left = countLevel(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = countLevel(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.right) + (<span class="number">1</span>&lt;&lt;left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.left) + (<span class="number">1</span>&lt;&lt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countLevel</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用了完全二叉树定义：</p>
<ul>
<li><strong>它是一棵空树或者它的叶子节点只出在最后两层，若最后一层不满则叶子节点只在最左侧。</strong>
<ol type="1">
<li><code>left == right</code>. 说明左子树一定是满二叉树，因为节点已经填充到右子树了，左子树必然填满了。所以左子树的节点总数我们可以直接得到，是<span class="math inline">\(2^{left }- 1\)</span>，加上当前这个root节点，则正好是<span class="math inline">\(2^{left}\)</span>。再对右子树进行递归统计。</li>
<li><code>left != right</code>. 说明此时到了树的倒数第二层了，且倒数第二层已经满了，可以直接得到右子树的节点个数。同理，右子树节点+root节点，总数为<span class="math inline">\(2^{right}\)</span>. 再对左子树进行递归查找。</li>
</ol></li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li><p>完全二叉树的定义引申出通过对左右孩子的判断，来得到对于节点个数的计算：</p>
<ul>
<li><p><code>left == right</code>.</p>
<p>说明左子树一定是满二叉树，因为节点已经填充到右子树了，左子树必然填满了。所以左子树的节点总数我们可以直接得到，是<span class="math inline">\(2^{left }- 1\)</span>，加上当前这个root节点，则正好是<span class="math inline">\(2^{left}\)</span>。再对右子树进行递归统计。</p></li>
<li><p><code>left != right</code>.</p>
<p>说明此时到了树的倒数第二层了，且倒数第二层已经满了，可以直接得到右子树的节点个数。同理，右子树节点+root节点，总数为<span class="math inline">\(2^{right}\)</span>. 再对左子树进行递归查找。</p></li>
<li><p><strong>完全二叉树的高度</strong>：</p>
<p><code>树的高度 = 树的最左节点的深度</code></p></li>
</ul></li>
<li><p>简单的位运算：</p>
<ul>
<li><span class="math inline">\(2^{left} = (1 &lt; &lt; left)\)</span></li>
</ul></li>
</ul>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/count-complete-tree-nodes/</p>
]]></content>
  </entry>
  <entry>
    <title>位运算的总结</title>
    <url>/2019/12/30/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>之后会再专门总结，目前就先这样挖个坑。</p>
<h2 id="referece">Referece</h2>
<p>https://blog.csdn.net/shimazhuge/article/details/24913417</p>
]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-965-单值二叉树</title>
    <url>/2019/12/30/leetcode%E9%A2%98%E8%A7%A3-965-%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/univalued-binary-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="dfs遍历">dfs遍历</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">bool</span> isUT = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || !isUT)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        isUT = (val == root-&gt;val ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val = root-&gt;val;</span><br><span class="line"></span><br><span class="line">        dfs(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isUT;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>树的遍历</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode题解-114-二叉树展开为链表</title>
    <url>/2019/12/30/leetcode%E9%A2%98%E8%A7%A3-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="windliang-way"><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/" target="_blank" rel="noopener">windliang way</a></h3>
<h4 id="对左右子树进行拼接的过程">对左右子树进行拼接的过程</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 1 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line">     / \         \</span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>         <span class="number">6</span>        </span><br><span class="line"><span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line">            </span><br><span class="line"> <span class="comment">//将 2 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>       <span class="number">4</span>  </span><br><span class="line">                 \</span><br><span class="line">                  <span class="number">5</span></span><br><span class="line">                   \</span><br><span class="line">                    <span class="number">6</span>   </span><br><span class="line">        </span><br><span class="line"> <span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>      </span><br><span class="line">         \</span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           \</span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             \</span><br><span class="line">              <span class="number">6</span>         </span><br><span class="line">  </span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// root-&gt;left is nullptr</span></span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// find the righest node of leftSubTree</span></span><br><span class="line">                TreeNode* pre = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (pre-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre = pre-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// make 'pre' node 'right' pointed to the origin rightSubTree</span></span><br><span class="line">                pre-&gt;right = root-&gt;right;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// make leftSubTree insert to rightSubTree</span></span><br><span class="line">                root-&gt;right = root-&gt;left;</span><br><span class="line">                root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// consider next right node</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历">后序遍历</h4>
<p>二叉树展开成为链表的结果就是 <strong>先序遍历</strong> 的结果。</p>
<p>但是按 <strong>先序遍历</strong> 结果来处理的话，更新当前结点的右指针的时候，当前结点的右指针就没有保存下来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// preOrder </span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>所以思考 <strong>反过来，通过后序遍历</strong> 来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// postOrder </span></span><br><span class="line"><span class="number">6</span> &lt;- <span class="number">5</span> &lt;- <span class="number">4</span> &lt;- <span class="number">3</span> &lt;- <span class="number">2</span> &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>即，每遍历一个节点，考虑将当前节点的 <strong>右指针</strong> 指向上一个节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        root-&gt;right = pre;</span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        pre = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="非递归先序遍历">非递归先序遍历</h4>
<p>利用栈保存上一个节点的右指针，并将其更新为当前节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = s.top(); s.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// binary tree expend to linked list</span></span><br><span class="line">            <span class="keyword">if</span> (pre)</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;right = tmp;</span><br><span class="line">                pre-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;right) s.push(tmp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;left)  s.push(tmp-&gt;left);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// update 'pre' node to 'tmp'</span></span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/</p>
]]></content>
      <categories>
        <category>后序遍历</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode题解-172-阶乘后的零</title>
    <url>/2019/12/30/leetcode%E9%A2%98%E8%A7%A3-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">题目</a></h2>
<ul>
<li><p>求<span class="math inline">\(N!\)</span>在尾部有多少个0，即求有多少个2和5.</p></li>
<li><p>由于实际上在<span class="math inline">\(N!\)</span>中，2的个数多于5，所以求5的个数即可，所以结果是<span class="math inline">\(N/5\)</span>吗？</p></li>
<li><p>并不是，因为每过<span class="math inline">\(5^i\)</span>个数之后，都会多出现一个5.</p>
<p><span class="math inline">\(result = N/5 + N/(5^2) + N/(5^3) + ... =((N/5)/5)/5...\)</span></p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            count += n/<span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/</p>
<p>https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/q172-factorial-trailing-zeroes-by-ronhou/</p>
]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode题解-1305-两棵二叉搜索树中的所有元素</title>
    <url>/2019/12/30/leetcode%E9%A2%98%E8%A7%A3-1305-%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="dfs中序遍历-归并排序">dfs中序遍历 + 归并排序</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1, v2;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left, v);</span><br><span class="line">        v.push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAllElements(TreeNode* root1, TreeNode* root2) </span><br><span class="line">    &#123;</span><br><span class="line">        dfs(root1, v1);</span><br><span class="line">        dfs(root2, v2);     </span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; v1.size() &amp;&amp; j &lt; v2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1[i] &lt;= v2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(v1[i++]);  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;                 </span><br><span class="line">                res.push_back(v2[j++]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; v1.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(v1[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; v2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(v2[j++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-1302-层数最深叶子节点的和</title>
    <url>/2019/12/30/leetcode%E9%A2%98%E8%A7%A3-1302-%E5%B1%82%E6%95%B0%E6%9C%80%E6%B7%B1%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/deepest-leaves-sum/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="dfs带层数状态遍历">dfs带层数状态遍历</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLevel = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxLevel &lt; level)</span><br><span class="line">        &#123;</span><br><span class="line">            maxLevel = level;</span><br><span class="line">            sum = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (maxLevel == level)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left, level+<span class="number">1</span>);</span><br><span class="line">        dfs(root-&gt;right, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deepestLeavesSum</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sum</code>, <code>maxLevel</code>也可以改成<code>dfs</code>函数的引用参数。</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-1104-二叉树寻路</title>
    <url>/2019/12/27/leetcode%E9%A2%98%E8%A7%A3-1104-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way"><a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/solution/pythonwei-yun-suan-by-mai-mai-mai-mai-zi/" target="_blank" rel="noopener">MY way</a></h3>
<p>我的思路是，自顶向下遍历到<code>label</code>所在那一层的结点，赋值出来，然后先序遍历输出结果。感觉就不是最优解。</p>
<h3 id="麦麦麦麦子way"><a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/solution/pythonwei-yun-suan-by-mai-mai-mai-mai-zi/" target="_blank" rel="noopener">麦麦麦麦子way</a></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathInZigZagTree</span><span class="params">(self, label: int)</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> label != <span class="number">1</span>:</span><br><span class="line">        res.append(label)</span><br><span class="line">        label &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 这里我采用异或实现</span></span><br><span class="line">        label = label ^(<span class="number">1</span> &lt;&lt; (label.bit_length() - <span class="number">1</span>)) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>]+res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>因为以1为根节点层次编号的满二叉树可以对应到位的表示，所以用位运算的思路即可。</p>
<p>因为每层的顺序在变，所以每次需要对首位外的其它位取反。</p>
<p>举例14=1110b，</p>
<p>先将14右移，变为111b，然后对除第一位外所有位取反变为100b，即它的根节点4，</p>
<p>同理100b，右移变为10b，对除第一位外所有位取反变为11b，即它的根节点3</p>
<p>一直到1结束。</p>
<h2 id="总结">总结</h2>
<ul>
<li><p>这是一道具有数学规律的题，不是很容易地可以发现根节点和两个孩子结点的规律。</p>
<ul>
<li><code>根节点label = (孩子结点label / 2)除最高的1位之外后的所有位按位取反</code></li>
</ul></li>
<li><p>怎么在C++里面统计一个数以二进制时，最后一位到最高的&quot;1&quot;位的位数。</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环统计位数</span></span><br><span class="line"><span class="keyword">unsigned</span> bits, var = (x &lt; <span class="number">0</span>) ? -x : x;</span><br><span class="line"><span class="keyword">for</span> (bits = <span class="number">0</span>; var != <span class="number">0</span>; ++bits) var &gt;&gt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2^n &gt; label &gt;= 2^(n-1) - 1</span></span><br><span class="line"><span class="comment">// n是label结点的层数</span></span><br><span class="line"><span class="keyword">int</span> numberOfBits = <span class="built_in">floor</span>(log2(label)) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="reference">Reference</h2>
<p>https://stackoverflow.com/questions/25754082/how-to-take-twos-complement-of-a-byte-in-c</p>
<p>https://stackoverflow.com/questions/29388711/c-how-to-get-length-of-bits-of-a-variable</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/floor" target="_blank" rel="noopener">std::floor向下取整</a></p>
]]></content>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-112-路径总和</title>
    <url>/2019/12/25/leetcode%E9%A2%98%E8%A7%A3-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归实现">递归实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; pathSum, <span class="keyword">int</span> sum, <span class="keyword">bool</span>&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || res)  <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        pathSum += root-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到达叶子结点时</span></span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; pathSum == sum) res = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left, pathSum, sum, res);</span><br><span class="line">        dfs(root-&gt;right, pathSum, sum, res);</span><br><span class="line"></span><br><span class="line">        pathSum -= root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pathSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        dfs(root, pathSum, sum, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-113-路径总和Ⅱ</title>
    <url>/2019/12/19/leetcode%E9%A2%98%E8%A7%A3-113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E2%85%A1/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归实现">递归实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; pathSum, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        pathSum += root-&gt;val;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; pathSum==sum)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left, pathSum, sum, path);</span><br><span class="line">        dfs(root-&gt;right, pathSum, sum, path);</span><br><span class="line"></span><br><span class="line">        pathSum -= root-&gt;val;</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pathSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        dfs(root, pathSum, sum, path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>简单递归即可实现</li>
<li>使用<code>pathSum</code>变量来记录当前<code>root</code>结点上的路径和</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-513-找树左下角的值</title>
    <url>/2019/12/19/leetcode%E9%A2%98%E8%A7%A3-513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="dfs递归实现">dfs递归实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (h &gt; maxHeight)</span><br><span class="line">            &#123;</span><br><span class="line">                maxHeight = h;</span><br><span class="line">                res = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left, h + <span class="number">1</span>);</span><br><span class="line">        dfs(root-&gt;right, h + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运用2个辅助变量：</p>
<ul>
<li><code>res</code>记录要返回的结点的<code>val</code></li>
<li><code>maxHeight</code>记录要返回的结点的高度，用来确认是最深一个结点上的值</li>
</ul>
]]></content>
      <tags>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-671-二叉树中第二小的节点</title>
    <url>/2019/12/18/leetcode%E9%A2%98%E8%A7%A3-671-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="dfs递归3个辅助变量">dfs递归+3个辅助变量</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> fir = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> sec = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> secIsChange = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> ((root-&gt;val &gt; fir &amp;&amp; root-&gt;val &lt; sec) || root-&gt;val == INT_MAX)  &#123; sec = root-&gt;val;  secIsChange = <span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; fir)                                          &#123; fir = root-&gt;val;  &#125;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> secIsChange?sec:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我这里没有利用到题目给的</p>
<ul>
<li>每个节点仅有<code>0</code>个或<code>2</code>个节点数；</li>
<li>如果一个节点有<code>2</code>个节点数，那么这个节点的值不大于它子节点的值。</li>
</ul>
<h4 id="leetcode-way"><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/solution/ji-bai-liao-100de-javayong-hu-by-reedfan/" target="_blank" rel="noopener">leetcode way</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null || (root.left == null &amp;&amp; root.right == null)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = root.left.val;</span><br><span class="line">        <span class="keyword">int</span> right = root.right.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == root.val) &#123;</span><br><span class="line">            left = findSecondMinimumValue(root.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right == root.val) &#123;</span><br><span class="line">            right = findSecondMinimumValue(root.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="number">-1</span> &amp;&amp; right != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/solution/ji-bai-liao-100de-javayong-hu-by-reedfan/</p>
]]></content>
      <tags>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-230-二叉搜索树中第K小的元素</title>
    <url>/2019/12/18/leetcode%E9%A2%98%E8%A7%A3-230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归中序遍历输出对应元素">递归中序遍历，输出对应元素</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * strzuct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        vi.push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为二叉搜索树的中序遍历结果是由小到大的，所以输出第<code>k-1</code>个元素即可</p>
<h3 id="大力王way"><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/c-zhong-xu-bian-li-ti-jie-by-da-li-wang/" target="_blank" rel="noopener">大力王way</a></h3>
<h4 id="递归控制中序遍历到第k-1个元素">递归，控制中序遍历到第<code>k-1</code>个元素</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span>&amp; res, <span class="keyword">bool</span>&amp; find, <span class="keyword">int</span>&amp; i, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || find) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;left, res, find, i, k);</span><br><span class="line">        <span class="keyword">if</span> (++i == k) &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;right, res, find, i, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        dfs(root, res, find, i, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/c-zhong-xu-bian-li-ti-jie-by-da-li-wang/</p>
]]></content>
      <tags>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-1261-在受污染的二叉树中查找元素</title>
    <url>/2019/12/18/leetcode%E9%A2%98%E8%A7%A3-1261-%E5%9C%A8%E5%8F%97%E6%B1%A1%E6%9F%93%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="dfs遍历树哈希表">dfs遍历树+哈希表</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindElements</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span>;</span><br><span class="line">        root-&gt;val = val;</span><br><span class="line">        s.insert(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)     dfs(root-&gt;left, val*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)    dfs(root-&gt;right, val*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FindElements(TreeNode* root) &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.count(target))    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FindElements object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FindElements* obj = new FindElements(root);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;find(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-109-将有序数组转换为二叉搜索树</title>
    <url>/2019/12/17/leetcode%E9%A2%98%E8%A7%A3-109-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归实现">递归实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (r - l)/<span class="number">2</span> + l; </span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = helper(nums, l, mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = helper(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !nums.size()? <span class="literal">nullptr</span>: helper(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-284-顶端迭代器</title>
    <url>/2019/12/17/leetcode%E9%A2%98%E8%A7%A3-284-%E9%A1%B6%E7%AB%AF%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/peeking-iterator/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="大力王way"><a href="https://leetcode-cn.com/problems/peeking-iterator/solution/c-huan-cun-tou-bu-yuan-su-by-da-li-wang/" target="_blank" rel="noopener">大力王way</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Below is the interface for Iterator, which is already defined for you.</span></span><br><span class="line"><span class="comment">// **DO NOT** modify the interface for Iterator.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Data</span>;</span></span><br><span class="line">	Data* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Iterator(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums);</span><br><span class="line">	Iterator(<span class="keyword">const</span> Iterator&amp; iter);</span><br><span class="line">	<span class="keyword">virtual</span> ~Iterator();</span><br><span class="line">	<span class="comment">// Returns the next element in the iteration.</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// Returns true if the iteration has more elements.</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekingIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> curr;</span><br><span class="line">    <span class="keyword">bool</span> hit_end;</span><br><span class="line">	PeekingIterator(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) : Iterator(nums) &#123;</span><br><span class="line">	    <span class="comment">// Initialize any member here.</span></span><br><span class="line">	    <span class="comment">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class="line">	    <span class="comment">// You should only use the Iterator interface methods.</span></span><br><span class="line">	    hit_end = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Iterator::hasNext()) &#123;</span><br><span class="line">            curr = Iterator::next();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hit_end = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line">	<span class="comment">// Override them if needed.</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hit_end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = curr;</span><br><span class="line">	    <span class="keyword">if</span> (Iterator::hasNext()) &#123;</span><br><span class="line">            curr = Iterator::next();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hit_end = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> !hit_end;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简单修改了一下，把<code>cur</code>, <code>hit_end</code>放到<code>private</code>作用域里了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Below is the interface for Iterator, which is already defined for you.</span></span><br><span class="line"><span class="comment">// **DO NOT** modify the interface for Iterator.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span>;</span></span><br><span class="line">	Data* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Iterator(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums);</span><br><span class="line">	Iterator(<span class="keyword">const</span> Iterator&amp; iter);</span><br><span class="line">	<span class="keyword">virtual</span> ~Iterator();</span><br><span class="line">	<span class="comment">// Returns the next element in the iteration.</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// Returns true if the iteration has more elements.</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekingIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    <span class="keyword">bool</span> hit_end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	PeekingIterator(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) : Iterator(nums) &#123;</span><br><span class="line">	    <span class="comment">// Initialize any member here.</span></span><br><span class="line">	    <span class="comment">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class="line">	    <span class="comment">// You should only use the Iterator interface methods.</span></span><br><span class="line">        hit_end = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Iterator::hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            cur = Iterator::next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            hit_end = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur;    </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line">	<span class="comment">// Override them if needed.</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (hit_end)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = cur;</span><br><span class="line">        <span class="keyword">if</span> (Iterator::hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            cur = Iterator::next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            hit_end = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !hit_end;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>不能拷贝一个基类对象进行直接操作，会涉及到子类调用父类接口的一些写法：
<ul>
<li>这种没有加<code>virtual</code>的<code>override</code>是通过<code>class::function_name</code>来调用的</li>
</ul></li>
<li>用<code>cur</code>表示最前面元素，<code>hit_end</code>表示是否到了尾部</li>
</ul>
]]></content>
      <tags>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-173-二叉搜索树迭代器</title>
    <url>/2019/12/17/leetcode%E9%A2%98%E8%A7%A3-173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="windliang"><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-4-4/" target="_blank" rel="noopener">windliang</a></h3>
<h4 id="队列保存了所有的节点值">队列保存了所有的节点值</h4>
<h5 id="java实现">java实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inorderTraversal(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorderTraversal(root.left);</span><br><span class="line">        queue.offer(root.val);</span><br><span class="line">        inorderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="c实现">C++实现</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        q.push(root-&gt;val);</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> front = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !q.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="要控制中序遍历的进程一个一个输出">要控制中序遍历的进程，一个一个输出</h4>
<h5 id="java实现-1">java实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        cur = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 节点不为空一直压栈</span></span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left; <span class="comment">// 考虑左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 节点为空，就出栈</span></span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            res = cur.val;</span><br><span class="line">            <span class="comment">// 考虑右子树</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur != <span class="keyword">null</span> || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="c实现-1">C++实现</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* cur = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        cur = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur || !s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = s.top(); s.pop();</span><br><span class="line">            res = cur-&gt;val;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur || !s.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>利用 <strong>二叉搜索树</strong> 的 <strong>中序遍历</strong> 是 <strong>升序序列</strong> 的特点，可以提前将树的结构以中序遍历结果存储起来</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-701-二叉搜索树中的插入操作</title>
    <url>/2019/12/16/leetcode%E9%A2%98%E8%A7%A3-701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归实现">递归实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> node = root;</span><br><span class="line">        TreeNode* tmp;</span><br><span class="line">        <span class="keyword">while</span> (node)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = node;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;val == val)   <span class="keyword">return</span> root;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;val &gt; val)    node = node-&gt;left;</span><br><span class="line">            <span class="keyword">else</span>                    node = node-&gt;right;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;val &gt; val)    tmp-&gt;left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">else</span>                   tmp-&gt;right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很简单的题目，就不写非递归实现了。</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-700-二叉搜索树中的搜索</title>
    <url>/2019/12/16/leetcode%E9%A2%98%E8%A7%A3-700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h3 id="递归">递归</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val == val)   <span class="keyword">return</span> root;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; val)    root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span>    root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很简单的题目，就不写非递归实现了</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-814-二叉树剪枝</title>
    <url>/2019/12/16/leetcode%E9%A2%98%E8%A7%A3-814-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/binary-tree-pruning/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="官方way">官方way</h3>
<h4 id="递归">递归</h4>
<h5 id="java实现">java实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">pruneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsOne(root) ? root : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsOne</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> a1 = containsOne(node.left);</span><br><span class="line">        <span class="keyword">boolean</span> a2 = containsOne(node.right);</span><br><span class="line">        <span class="keyword">if</span> (!a1) node.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!a2) node.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node.val == <span class="number">1</span> || a1 || a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="c实现">C++实现</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> lDel = helper(root-&gt;left);</span><br><span class="line">        <span class="keyword">bool</span> lRig = helper(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!lDel)  root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (!lRig)  root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val == <span class="number">1</span> | lDel | lRig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root) ? root : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>自己一开始的递归思路不合理。</li>
<li>递归终止条件： 到达<code>nullptr</code>处，<code>return false</code></li>
<li>递归状态：
<ol type="1">
<li><code>当前结点值 == 1</code></li>
<li><code>左子树 == 全为1</code></li>
<li><code>右子树 == 全为1</code></li>
</ol></li>
</ul>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/binary-tree-pruning/solution/er-cha-shu-jian-zhi-by-leetcode/</p>
]]></content>
      <tags>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-226-翻转二叉树</title>
    <url>/2019/12/16/leetcode%E9%A2%98%E8%A7%A3-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归实现">递归实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* tmp = invertTree(root-&gt;right);</span><br><span class="line">        root-&gt;right = invertTree(root-&gt;left);</span><br><span class="line">        root-&gt;left = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="手动队列层次遍历">手动队列，层次遍历</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> front = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (!front) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> tmp = front-&gt;right;</span><br><span class="line">            front-&gt;right = front-&gt;left;</span><br><span class="line">            front-&gt;left = tmp;</span><br><span class="line"></span><br><span class="line">            q.push(front-&gt;left);</span><br><span class="line">            q.push(front-&gt;right);</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-1008-先序遍历构造二叉树</title>
    <url>/2019/12/16/leetcode%E9%A2%98%E8%A7%A3-1008-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener">题目</a></h2>
<h4 id="递归实现">递归实现</h4>
<p>利用二叉搜索树的前序遍历结果中的左子树序列中的值都小于根节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[l]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">int</span> j = l + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(nums[j] &lt; nums[l])</span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= nums.size())   <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = helper(nums, l+<span class="number">1</span>, j<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = helper(nums, j, r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="手动压栈实现">手动压栈实现</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = preorder.size();</span><br><span class="line">       <span class="keyword">if</span> (!n)  <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">       </span><br><span class="line">       TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">       <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">       s.push(root);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">       &#123;</span><br><span class="line">           TreeNode* node = s.top();</span><br><span class="line">           TreeNode* child = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">           <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top()-&gt;val &lt; child-&gt;val) </span><br><span class="line">           &#123;</span><br><span class="line">               node = s.top();</span><br><span class="line">               s.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (node-&gt;val &lt; child-&gt;val)     node-&gt;right = child;</span><br><span class="line">           <span class="keyword">else</span>                            node-&gt;left = child;</span><br><span class="line">           s.push(child);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="references">References</h2>
<p><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/solution/4ms-c-ti-jie-jie-ti-si-lu-by-nonnus/" target="_blank" rel="noopener">NoNN way</a></p>
<p>https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/solution/jian-kong-er-cha-shu-by-leetcode/</p>
]]></content>
      <tags>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-894-所有可能的满二叉树</title>
    <url>/2019/12/16/leetcode%E9%A2%98%E8%A7%A3-894-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/all-possible-full-binary-trees/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="记忆化搜索">记忆化搜索</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 使用记忆化搜索，避免每次重新计算测试用例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; memo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; allPossibleFBT(<span class="keyword">int</span> N) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if (memo.count(N))    return memo[N];</span></span><br><span class="line">        <span class="keyword">auto</span> it = memo.find(N);</span><br><span class="line">        <span class="keyword">if</span> (it != memo.end())   <span class="keyword">return</span> it-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; vt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vt.push_back(<span class="keyword">new</span> TreeNode(<span class="number">0</span>));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; N; ++x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = N - <span class="number">1</span> - x;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> left: allPossibleFBT(x))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> right: allPossibleFBT(y))</span><br><span class="line">                    &#123;</span><br><span class="line">                        TreeNode* bns = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                        bns-&gt;left = left;</span><br><span class="line">                        bns-&gt;right = right;</span><br><span class="line">                        vt.push_back(bns);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo.insert(make_pair(N, vt));</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> memo[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-617-合并二叉树</title>
    <url>/2019/12/12/leetcode%E9%A2%98%E8%A7%A3-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">题目</a></h2>
<h4 id="递归实现">递归实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t1)    <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (!t2)    <span class="keyword">return</span> t1;</span><br><span class="line"></span><br><span class="line">        t1-&gt;val += t2-&gt;val;</span><br><span class="line">        t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="手动压栈实现">手动压栈实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t1)    <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (!t2)    <span class="keyword">return</span> t1;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;TreeNode*, TreeNode*&gt;&gt; s;</span><br><span class="line">        s.push(make_pair(t1, t2));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> root = s.top(); s.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!root.first|| !root.second)    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            root.first-&gt;val += root.second-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (!root.first-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                root.first-&gt;left = root.second-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.push(make_pair(root.first-&gt;left, root.second-&gt;left));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!root.first-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                root.first-&gt;right = root.second-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.push(make_pair(root.first-&gt;right, root.second-&gt;right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><p>可以用<code>t1</code>, <code>t2</code>的根节点来代替为新的根节点，实现起来会很方便。</p>
<ul>
<li>当你遍历到一个结点，其中只有一棵树有这样的结点的时候，递归实现直接返回另外一棵树的该节点即可。</li>
</ul></li>
</ul>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-938-二叉树搜索树的范围和</title>
    <url>/2019/12/12/leetcode%E9%A2%98%E8%A7%A3-938-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/range-sum-of-bst/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归解">递归解</h4>
<p>要考虑3种情况：</p>
<ol type="1">
<li>L，R分别在root的左，右子树上, <span class="math inline">\(val \in [L,\ R]\)</span></li>
<li>L，R均在root的左子树上, <span class="math inline">\(L&lt; R &lt;val\)</span></li>
<li>L，R均在root的右子树上, <span class="math inline">\(val &gt; L &gt; R\)</span></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (L &lt;= root-&gt;val &amp;&amp; R &gt;= root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L &lt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            helper(root-&gt;right, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (R &gt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            helper(root-&gt;left, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        helper(root, L, R);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="手动压栈">手动压栈</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            root = s.top(); s.pop();</span><br><span class="line">            <span class="keyword">if</span> (!root)	<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (L &lt;= root-&gt;val &amp;&amp; root-&gt;val &lt;= R)	sum += root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (L &lt; root-&gt;val)	s.push(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (R &gt; root-&gt;val)	s.push(root-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-998-最大二叉树Ⅱ</title>
    <url>/2019/12/11/leetcode%E9%A2%98%E8%A7%A3-998-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/maximum-binary-tree-ii/" target="_blank" rel="noopener">题目</a></h2>
<p>没能理解题意。。。</p>
<p>我感觉是给了一个已经构造好的最大二叉树，然后新插入一个值为<code>val</code>的结点进来。</p>
<p><a href="https://leetcode-cn.com/problems/maximum-binary-tree-ii/solution/go-0ms-wu-di-gui-by-yuhhen/" target="_blank" rel="noopener">这个解答</a>告诉了这个题是要做啥。然后发现是对比三幅例子的树图可以得到插入<code>val</code>结点进来的要求。</p>
<p>分成如下2种情况：</p>
<ol type="1">
<li>大于<code>root</code>，则把 <code>root</code>作为<code>val节点</code>的左子树；</li>
<li>小于<code>root</code>，则把 <code>val节点</code>作为<code>root</code>的右子树；</li>
</ol>
<h3 id="secretname-way"><a href="https://leetcode-cn.com/problems/maximum-binary-tree-ii/solution/c-di-gui-jian-ji-dai-ma-by-secretname/" target="_blank" rel="noopener">secretname way</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoMaxTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || root-&gt;val &lt; val)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            node-&gt;left = root;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;right = insertIntoMaxTree(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/maximum-binary-tree-ii/solution/go-0ms-wu-di-gui-by-yuhhen/</p>
<p>https://leetcode-cn.com/problems/maximum-binary-tree-ii/solution/c-di-gui-jian-ji-dai-ma-by-secretname/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的构造</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-654-最大二叉树</title>
    <url>/2019/12/11/leetcode%E9%A2%98%E8%A7%A3-654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归构造树">递归构造树</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = max_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">if</span> (it == nums.end())   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(*it);</span><br><span class="line">        root-&gt;left = helper(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.begin(), it));</span><br><span class="line">        root-&gt;right = helper(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(it + <span class="number">1</span>, nums.end()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        TreeNode* root = helper(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="infinite-way"><a href="https://leetcode-cn.com/problems/maximum-binary-tree/solution/c-dong-tai-gui-hua-by-infinite-15-7/" target="_blank" rel="noopener">infinite way</a></h3>
<h4 id="单调栈">单调栈</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; st(size);</span><br><span class="line">        <span class="keyword">int</span> st_size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">            <span class="keyword">if</span> (st_size == <span class="number">0</span> || st[<span class="number">0</span>]-&gt;val &lt; num) &#123; <span class="comment">// 栈内所有元素都比当前值小</span></span><br><span class="line">                p-&gt;left = st[<span class="number">0</span>];</span><br><span class="line">                st[<span class="number">0</span>] = p;</span><br><span class="line">                st_size = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (st[st_size - <span class="number">1</span>]-&gt;val &gt; num) &#123; <span class="comment">// 栈内所有元素都比当前值大</span></span><br><span class="line">                st[st_size - <span class="number">1</span>]-&gt;right = p;</span><br><span class="line">                st[st_size++] = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 二分查找临界位置</span></span><br><span class="line">                <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> end = st_size - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (begin + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> half = (begin + end) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (st[half]-&gt;val &lt; num)</span><br><span class="line">                        end = half;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        begin = half;</span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;left = st[end];</span><br><span class="line">                st[begin]-&gt;right = p;</span><br><span class="line">                st[begin + <span class="number">1</span>] = p;</span><br><span class="line">                st_size = begin + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> st[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>修改了一下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; st(nums.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> st_size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (st_size == <span class="number">0</span> || st[<span class="number">0</span>]-&gt;val &lt; num)   <span class="comment">// 大于栈顶元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;left = st[<span class="number">0</span>];</span><br><span class="line">                st[<span class="number">0</span>] = p;</span><br><span class="line">                st_size = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st[st_size - <span class="number">1</span>]-&gt;val &gt; num)	<span class="comment">// 小于栈底元素 </span></span><br><span class="line">            &#123;</span><br><span class="line">                st[st_size - <span class="number">1</span>]-&gt;right = p;</span><br><span class="line">                st[st_size++] = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>	<span class="comment">// 在栈中元素时，要找到这个元素的位置，然后设置它的left结点指向小于它的元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> begin = <span class="number">0</span>, end = st_size - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (begin + <span class="number">1</span> &lt; end)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> half = (end - begin) / <span class="number">2</span> + begin;</span><br><span class="line">                   </span><br><span class="line">                    <span class="keyword">if</span> (st[half]-&gt;val &lt; num)    end = half;</span><br><span class="line">                    <span class="keyword">else</span>                        begin = half;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                p-&gt;left = st[end];</span><br><span class="line">                st[begin]-&gt;right = p;</span><br><span class="line">                st[begin + <span class="number">1</span>] = p;</span><br><span class="line">                st_size = begin + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> st[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><p>这题刚好满足最大单调栈的应用场景，</p>
<ul>
<li>树结点的<code>left</code>, <code>right</code>的要求刚好对应单调栈里的左，右部分</li>
</ul></li>
</ul>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/maximum-binary-tree/solution/c-dong-tai-gui-hua-by-infinite-15-7/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>√</tag>
        <tag>单调栈</tag>
        <tag>树的构造</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-1277-统计全为1的正方形子矩阵</title>
    <url>/2019/12/11/leetcode%E9%A2%98%E8%A7%A3-1277-%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-106-从中序与后序遍历序列构造二叉树</title>
    <url>/2019/12/10/leetcode%E9%A2%98%E8%A7%A3-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="hareyukai-way"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/-cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er/" target="_blank" rel="noopener">hareyukai way</a></h3>
<h4 id="递归实现-参数传迭代器">递归实现 + 参数传迭代器</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> buildTree(rbegin(inorder), rend(inorder),</span><br><span class="line">                         rbegin(postorder), rend(postorder));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(RandomIt in_rfirst, RandomIt in_rlast,</span></span></span><br><span class="line"><span class="function"><span class="params">                        RandomIt post_rfirst, RandomIt post_rlast)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in_rfirst == in_rlast) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (post_rfirst == post_rlast) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(*post_rfirst);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> inRootRPos = find(in_rfirst, in_rlast, *post_rfirst);</span><br><span class="line">        <span class="keyword">auto</span> RightSize = distance(in_rfirst, inRootRPos);</span><br><span class="line">        </span><br><span class="line">        root-&gt;right = buildTree(in_rfirst,</span><br><span class="line">                                next(in_rfirst, RightSize),</span><br><span class="line">                                next(post_rfirst),</span><br><span class="line">                                next(post_rfirst, RightSize + <span class="number">1</span>));</span><br><span class="line">        root-&gt;left = buildTree(next(inRootRPos),</span><br><span class="line">                               in_rlast,</span><br><span class="line">                               next(post_rfirst, RightSize + <span class="number">1</span>),</span><br><span class="line">                               post_rlast);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简单修改了一下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">using</span> It = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(It inFir, It inLast, It postFir, It postLast)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inFir == inLast || postFir == postLast) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(*postFir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> inRootPos = find(inFir, inLast, *postFir);</span><br><span class="line">        <span class="keyword">auto</span> RightSize = distance(inFir, inRootPos);</span><br><span class="line"></span><br><span class="line">        root-&gt;right = buildTree(inFir, next(inFir, RightSize), next(postFir), next(postFir, RightSize + <span class="number">1</span>));</span><br><span class="line">        root-&gt;left = buildTree(next(inRootPos), inLast, next(postFir, RightSize + <span class="number">1</span>), postLast);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder.rbegin(), inorder.rend(), postorder.rbegin(), postorder.rend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-105-从前序与中序遍历序列构造二叉树</title>
    <url>/2019/12/10/leetcode%E9%A2%98%E8%A7%A3-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="当当喵-way"><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/solution/chao-ji-rong-yi-li-jie-qi-shi-he-qiu-quan-lu-jing-/" target="_blank" rel="noopener">当当喵 way</a></h3>
<h4 id="dfs遍历-isleft来标注当前节点状态即可">dfs遍历 + isLeft来标注当前节点状态即可</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSum</span><span class="params">(TreeNode* root, <span class="keyword">bool</span> isLeft)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isLeft &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            getSum(root-&gt;left, <span class="literal">true</span>);</span><br><span class="line">            getSum(root-&gt;right, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        getSum(root, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/sum-of-left-leaves/solution/chao-ji-rong-yi-li-jie-qi-shi-he-qiu-quan-lu-jing-/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-652-寻找重复的子树</title>
    <url>/2019/12/10/leetcode%E9%A2%98%E8%A7%A3-652-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="序列化-重复子序列dp解法-反序列化回去时找到对应子树root结点">序列化 + 重复子序列DP解法 + 反序列化回去时找到对应子树root结点</h4>
<p>感觉代价过高，而且在反序列化回去找到对应结点时会很麻烦。</p>
<h3 id="yushinan"><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/solution/simple-solution-by-yushinan-2/" target="_blank" rel="noopener">yushinan</a></h3>
<h4 id="序列化hash取出重复子树的头结点">序列化+hash取出重复子树的头结点</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; counts;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">    serialize(root, counts, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp; counts,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">    <span class="built_in">string</span> key = to_string(root-&gt;val) + <span class="string">","</span> </span><br><span class="line">        + serialize(root-&gt;left, counts, ans) + <span class="string">","</span> </span><br><span class="line">        + serialize(root-&gt;right, counts, ans);</span><br><span class="line">    <span class="keyword">if</span> (++counts[key] == <span class="number">2</span>)</span><br><span class="line">      ans.push_back(root);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="yuguorui"><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/solution/c-xu-lie-hua-jie-fa-by-yuguorui/" target="_blank" rel="noopener">*yuguorui</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubTreeCount</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TreeNode* root;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">size_t</span>, SubTreeCount&gt; dict;</span><br><span class="line">	hash&lt;<span class="built_in">string</span>&gt; hasher;</span><br><span class="line">	<span class="built_in">vector</span>&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123;</span><br><span class="line">		serialize(root);</span><br><span class="line">		<span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; item: dict) &#123;</span><br><span class="line">			<span class="keyword">if</span> (item.second.count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				res.push_back(item.second.root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> serialize(TreeNode* root) &#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> hasher(<span class="string">"[]"</span>);</span><br><span class="line">		<span class="keyword">char</span> buf[<span class="number">2048</span>];</span><br><span class="line">		<span class="built_in">snprintf</span>(buf, <span class="number">2048</span>, <span class="string">"[%d,%d,%d]"</span>, root-&gt;val, serialize(root-&gt;left), serialize(root-&gt;right));</span><br><span class="line">		<span class="keyword">size_t</span> res = hasher(buf);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dict.count(res) == <span class="number">0</span>) &#123;</span><br><span class="line">			dict.insert(pair&lt;<span class="keyword">size_t</span>, SubTreeCount&gt;(res, &#123;root, <span class="number">1</span>&#125;));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dict[res].count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用了<code>hash&lt;string&gt;</code>后结果，作为判断这一子序列是否出现过的情况/有重复子串的情况；</li>
<li>用<code>snprintf</code>的IO流来生成对应序列化结果。</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>对整棵树中，每一颗子树都进行序列化，并利用<code>unordered_map</code>得到每个子树的序列化结果是否重复</li>
<li>对于序列化路径有：<strong>node.path = node.val + node.left.path + node.right.path</strong></li>
<li>这里的序列化，可以不用序列化<code>null</code></li>
</ul>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/find-duplicate-subtrees/solution/simple-solution-by-yushinan-2/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>hash</tag>
        <tag>序列化</tag>
        <tag>innovative solution</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-606-根据二叉树创建字符串</title>
    <url>/2019/12/09/leetcode%E9%A2%98%E8%A7%A3-606-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="官方"><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/solution/gen-ju-er-cha-shu-chuang-jian-zi-fu-chuan-by-leetc/" target="_blank" rel="noopener">官方</a></h3>
<h4 id="递归实现">递归实现</h4>
<p>考虑4种情况：</p>
<ol type="1">
<li>如果当前节点有两个孩子，那我们在递归时，需要在两个孩子的结果外都加上一层括号；</li>
<li>如果当前节点没有孩子，那我们不需要在节点后面加上任何括号；</li>
<li>如果当前节点只有左孩子，那我们在递归时，只需要在左孩子的结果外加上一层括号，而不需要给右孩子加上任何括号；</li>
<li>如果当前节点只有右孩子，那我们在递归时，需要先加上一层空的括号 <code>()</code> 表示左孩子为空，再对右孩子进行递归，并在结果外加上一层括号。</li>
</ol>
<h5 id="java实现">java实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tree2str</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(t.left==<span class="keyword">null</span> &amp;&amp; t.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t.val+<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(t.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t.val+<span class="string">"("</span>+tree2str(t.left)+<span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> t.val+<span class="string">"("</span>+tree2str(t.left)+<span class="string">")("</span>+tree2str(t.right)+<span class="string">")"</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改下排版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tree2str</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (!t)		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (!t.left &amp;&amp; !t.right)	<span class="keyword">return</span> t.val + <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (!t.right)	<span class="keyword">return</span> t.val + <span class="string">"("</span> + tree2str(t.left) + <span class="string">")"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> t.val+<span class="string">"("</span>+tree2str(t.left)+<span class="string">")("</span>+tree2str(t.right)+<span class="string">")"</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="c实现">C++实现</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (!t)	<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (!t-&gt;left &amp;&amp; !t-&gt;right)	<span class="keyword">return</span> to_string(t-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (!t-&gt;right)	<span class="keyword">return</span> to_string(t-&gt;val) + <span class="string">"("</span> + tree2str(t-&gt;left) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span>	to_string(t-&gt;val) + <span class="string">"("</span> + tree2str(t-&gt;left) + <span class="string">")("</span> + tree2str(t-&gt;right) + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="非递归手动压栈">非递归手动压栈</h3>
<ul>
<li>因为要保存括号，所以需要一个集合存储所有遍历过的节点</li>
<li>它没有子节点，什么都不做</li>
<li>有两个节点，右孩子先入栈，再左孩子入栈，保证先序遍历顺序</li>
<li>如果只有左孩子，则左孩子入栈</li>
<li>如果只有右孩子，则末尾添加一个<code>()</code>后，再将右孩子入栈</li>
</ul>
<h5 id="java实现-1">java实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tree2str</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        Stack &lt; TreeNode &gt; stack = <span class="keyword">new</span> Stack &lt; &gt; ();</span><br><span class="line">        stack.push(t);</span><br><span class="line">        Set &lt; TreeNode &gt; visited = <span class="keyword">new</span> HashSet &lt; &gt; ();</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            t = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(t)) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                s.append(<span class="string">")"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited.add(t);</span><br><span class="line">                s.append(<span class="string">"("</span> + t.val);</span><br><span class="line">                <span class="keyword">if</span> (t.left == <span class="keyword">null</span> &amp;&amp; t.right != <span class="keyword">null</span>)</span><br><span class="line">                    s.append(<span class="string">"()"</span>);</span><br><span class="line">                <span class="keyword">if</span> (t.right != <span class="keyword">null</span>)</span><br><span class="line">                    stack.push(t.right);</span><br><span class="line">                <span class="keyword">if</span> (t.left != <span class="keyword">null</span>)</span><br><span class="line">                    stack.push(t.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(<span class="number">1</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="c实现-1">C++实现</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!t)	<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;TreeNode*&gt; visited;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(t);</span><br><span class="line">       	</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            t = s.top();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (visited.find(t) != visited.end())</span><br><span class="line">            &#123;</span><br><span class="line">            	s.pop();</span><br><span class="line">                str += <span class="string">")"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                visited.insert(t);</span><br><span class="line">                str += <span class="string">"("</span> + to_string(t-&gt;val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!t-&gt;left &amp;&amp; t-&gt;right)	str += <span class="string">"()"</span>;</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right)	s.push(t-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left)	s.push(t-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.substr(<span class="number">1</span>, str.size() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{align*}
&amp; e.g. \\
&amp; INPUT:  &amp; [1,2,3,4] \\
&amp; OUTPUT: &amp; (1\\
&amp; &amp; (1(2\\
&amp; &amp;(1(2(4\\
&amp; &amp;(1(2(4)\\
&amp; &amp;(1(2(4)) \\
&amp; &amp;(1(2(4))(3\\
&amp; &amp;(1(2(4))(3)\\
&amp; &amp;(1(2(4))(3))\\
\end{align*}
\]</span></p>
<h3 id="mrhuang"><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/solution/cgao-xiao-di-cun-fang-fa-by-mrhuang-3/" target="_blank" rel="noopener">MrHuang</a></h3>
<ul>
<li>用<code>stringstream</code>代替<code>string</code></li>
<li>用<code>lambda</code>表达式代替<code>函数</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        function&lt;<span class="keyword">void</span>(TreeNode*)&gt; helper = [&amp;ss, &amp;helper](TreeNode* t)&#123;</span><br><span class="line">            ss&lt;&lt;t-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    ss&lt;&lt;<span class="string">"()("</span>;</span><br><span class="line">                    helper(t-&gt;right);</span><br><span class="line">                    ss&lt;&lt;<span class="string">')'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                ss&lt;&lt;<span class="string">'('</span>;</span><br><span class="line">                helper(t-&gt;left);</span><br><span class="line">                ss&lt;&lt;<span class="string">')'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ss&lt;&lt;<span class="string">'('</span>;</span><br><span class="line">                helper(t-&gt;left);</span><br><span class="line">                ss&lt;&lt;<span class="string">")("</span>;</span><br><span class="line">                helper(t-&gt;right);</span><br><span class="line">                ss&lt;&lt;<span class="string">')'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        helper(t);</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        ss&gt;&gt;s;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/construct-string-from-binary-tree/solution/gen-ju-er-cha-shu-chuang-jian-zi-fu-chuan-by-leetc/</p>
<p>https://leetcode-cn.com/problems/construct-string-from-binary-tree/solution/cgao-xiao-di-cun-fang-fa-by-mrhuang-3/</p>
<p>https://stackoverflow.com/questions/1701067/how-to-check-that-an-element-is-in-a-stdset</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>栈</tag>
        <tag>括号匹配</tag>
        <tag>stringstream</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-297-二叉树的序列化与反序列化</title>
    <url>/2019/12/09/leetcode%E9%A2%98%E8%A7%A3-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="手动队列序列化-手动出队反序列化">手动队列序列化 + 手动出队反序列化</h4>
<p>因为C++ STL没有<code>split</code>, <code>boost</code>里面有。</p>
<p>所以考虑自己实现一个<code>split</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitStrToStrArray(<span class="built_in">string</span> s, <span class="built_in">string</span> delimiter)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> token;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(token != s)&#123;</span><br><span class="line">      token = s.substr(<span class="number">0</span>,s.find_first_of(delimiter));</span><br><span class="line">      s = s.substr(s.find_first_of(delimiter) + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//printf("%s ",token.c_str());</span></span><br><span class="line">      vs.push_back(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据题意要求写了个如下的出来，包括测试用例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      TreeNode *left;</span><br><span class="line">      TreeNode *right;</span><br><span class="line">      TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitStrToStrArray(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">const</span> <span class="built_in">string</span>&amp; delimiter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// remove "[" and "]"</span></span><br><span class="line">    <span class="built_in">string</span> str = s.substr(<span class="number">1</span>, s.size() - <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">string</span> token;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(token != str)&#123;</span><br><span class="line">      token = str.substr(<span class="number">0</span>,str.find_first_of(delimiter));</span><br><span class="line">      str = str.substr(str.find_first_of(delimiter) + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//printf("%s ",token.c_str());</span></span><br><span class="line">      vs.push_back(token);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">genNodebyStr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">"null"</span>)    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode(stoi(s));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="string">"[null,]"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> res = to_string(root-&gt;val) + <span class="string">","</span>;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> top = q.front();    q.pop_front();</span><br><span class="line">            <span class="keyword">if</span> (top-&gt;left)     </span><br><span class="line">            &#123;</span><br><span class="line">                q.push_back(top-&gt;left);     </span><br><span class="line">                res += to_string(top-&gt;left-&gt;val) + <span class="string">","</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res += <span class="string">"null,"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (top-&gt;right)     </span><br><span class="line">            &#123;</span><br><span class="line">                q.push_back(top-&gt;right);    </span><br><span class="line">                res += to_string(top-&gt;right-&gt;val) + <span class="string">","</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res += <span class="string">"null,"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="string">"["</span> + res + <span class="string">"]"</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        cout &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs = splitStrToStrArray(data, <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        TreeNode* root = genNodebyStr(vs[index++]);</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!root)  q.push_back(root);</span><br><span class="line">        TreeNode* node = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            node = q.front(); q.pop_front();</span><br><span class="line">            node-&gt;left = genNodebyStr(vs[index++]);</span><br><span class="line">            node-&gt;right = genNodebyStr(vs[index++]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)     q.push_back(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)    q.push_back(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    TreeNode* n1 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode* n2 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode* n4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    TreeNode* n5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = n1;    root-&gt;right = n2;</span><br><span class="line">    n2-&gt;left = n4;      n2-&gt;right = n5;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Codec c;</span><br><span class="line">    c.deserialize(c.serialize(root));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stoi(<span class="string">"12"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是发现这个过不了测试用例，然后输出后发现为</p>
<p><code>[1,2,3,null,null,4,5,null,null,null,null,]</code></p>
<p>而不是要求的:</p>
<p><code>[1,2,3,null,null,4,5]</code></p>
<p>所以应该是说，最下面一层叶子要序列化它的<code>null</code>孩子。</p>
<h3 id="ting-yu-way"><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/c-version-by-zzyuting/" target="_blank" rel="noopener">Ting Yu way</a></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        serialize(root,out);</span><br><span class="line">        <span class="keyword">return</span> out.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(in);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root,<span class="built_in">ostringstream</span>&amp; out)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            out&lt;&lt;root-&gt;val&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">            serialize(root-&gt;left,out);</span><br><span class="line">            serialize(root-&gt;right,out);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里一定要带着空格，因为在输入的时候用来表示当前输入结束</span></span><br><span class="line">            out&lt;&lt;<span class="string">"# "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span>&amp; in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        in&gt;&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(val==<span class="string">"#"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">        root-&gt;left=deserialize(in);</span><br><span class="line">        root-&gt;right=deserialize(in);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="官方"><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-leet/" target="_blank" rel="noopener">官方</a></h2>
<img src="/2019/12/09/leetcode题解-297-二叉树的序列化与反序列化/12/09/leetcode题解-297-二叉树的序列化与反序列化/serial_deserial.png" title="serial_to_deserial">
<p><code>Binary Search Tree</code> 的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。</p>
<p>可以遍历树来完成上述任务。众所周知，我们有两个一般策略：</p>
<ul>
<li>广度优先搜索（BFS） 我们按照高度的顺序从上到下逐级扫描树。更高级别的节点将先于较低级别的节点访问。</li>
<li>深度优先搜索（DFS)
<ul>
<li>在这个策略中，我们采用深度作为优先顺序，这样我们就可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。</li>
<li>根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为 preorder、inorder 和 postorder 。</li>
</ul></li>
</ul>
<p>然而，在这个任务中，DFS 策略更适合我们的需要，因为相邻节点之间的链接自然地按顺序编码，这对后面的反序列化任务非常有帮助。</p>
<p>因此，在这个解决方案中，我们用 preorder DFS 策略演示了一个示例。您可以在 leetcode explore上查看有关二叉搜索树的更多教程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Serialization</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">rserialize</span><span class="params">(TreeNode root, String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Recursive serialization.</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      str += <span class="string">"null,"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      str += str.valueOf(root.val) + <span class="string">","</span>;</span><br><span class="line">      str = rserialize(root.left, str);</span><br><span class="line">      str = rserialize(root.right, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rserialize(root, <span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">rdeserialize</span><span class="params">(List&lt;String&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Recursive deserialization.</span></span><br><span class="line">    <span class="keyword">if</span> (l.get(<span class="number">0</span>).equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">      l.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(l.get(<span class="number">0</span>)));</span><br><span class="line">    l.remove(<span class="number">0</span>);</span><br><span class="line">    root.left = rdeserialize(l);</span><br><span class="line">    root.right = rdeserialize(l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    String[] data_array = data.split(<span class="string">","</span>);</span><br><span class="line">    List&lt;String&gt; data_list = <span class="keyword">new</span> LinkedList&lt;String&gt;(Arrays.asList(data_array));</span><br><span class="line">    <span class="keyword">return</span> rdeserialize(data_list);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>利用<code>sstream</code>里的<code>istringstream</code>和<code>ostringstream</code>来解决字符串相关问题，是我之前没想到的</li>
<li></li>
</ul>
<h2 id="reference">Reference</h2>
<p>https://stackoverflow.com/questions/14265581/parse-split-a-string-in-c-using-string-delimiter-standard-c</p>
<p>https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/c-version-by-zzyuting/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>stringstream</tag>
        <tag>序列化</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-94-二叉树的中序遍历</title>
    <url>/2019/12/08/leetcode%E9%A2%98%E8%A7%A3-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归实现">递归实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> ;</span><br><span class="line">        helper(root-&gt;left); </span><br><span class="line">        vi.push_back(root-&gt;val);</span><br><span class="line">        helper(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        helper(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="手动压栈实现">手动压栈实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root)     </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!s.empty() || root)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root)   </span><br><span class="line">                &#123;</span><br><span class="line">                    s.push(root);</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    root = s.top(); s.pop();</span><br><span class="line">                    vi.push_back(root-&gt;val);</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>因为中序遍历是 &quot;<strong>左根右</strong>&quot;，所以得
<ul>
<li>先遍历到最左的结点，则这个结点可能是 &quot;<strong>左根右</strong>&quot;中的 <strong>左</strong> 或者 <strong>根</strong> 或者 <strong>null</strong></li>
<li>若为 <strong>左</strong>/<strong>根</strong>， 则 都需保存它的右孩子(为<strong>空</strong>/<strong>不空</strong>)，然后继续考察他的 ”<strong>左根右</strong>“结构。</li>
<li>若<strong>不为null</strong>， 则 保存当前结点，且继续往左孩子遍历</li>
<li>若 <strong>为null</strong>，则 弹栈 并 打印当前栈顶元素值，然后往右孩子遍历</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>√</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-590-N叉树的后序遍历</title>
    <url>/2019/12/08/leetcode%E9%A2%98%E8%A7%A3-590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-589-N叉树的前序遍历</title>
    <url>/2019/12/08/leetcode%E9%A2%98%E8%A7%A3-589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>leetcode题解-145-二叉树的后序遍历</title>
    <url>/2019/12/08/leetcode%E9%A2%98%E8%A7%A3-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归实现">递归实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        helper(root-&gt;left);</span><br><span class="line">        helper(root-&gt;right);</span><br><span class="line">        vi.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        helper(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="非递归手动压栈逆序输出">非递归手动压栈+逆序输出</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(root);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!s.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> top = s.top();    s.pop();</span><br><span class="line">                vi.push_back(top-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (top-&gt;left)     s.push(top-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (top-&gt;right)    s.push(top-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vi.rbegin(), vi.rend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="非递归手动压栈-辅助变量判断右孩子是否访问过">非递归手动压栈 + 辅助变量判断右孩子是否访问过</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; mystack;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr || !mystack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(curr)</span><br><span class="line">            &#123;</span><br><span class="line">                mystack.push(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = mystack.top();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//若右节点已经访问过或者没有右节点  则输出该节点值</span></span><br><span class="line">            <span class="keyword">if</span>(!curr-&gt;right || pre == curr-&gt;right)&#123;</span><br><span class="line">                mystack.pop();</span><br><span class="line">                ans.push_back(curr-&gt;val);    </span><br><span class="line">                pre = curr;</span><br><span class="line">                curr = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">                pre = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/c-by-jjjjjz-2/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>√</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-144-二叉树的前序遍历</title>
    <url>/2019/12/08/leetcode%E9%A2%98%E8%A7%A3-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归实现">递归实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> ;</span><br><span class="line">        vi.push_back(root-&gt;val);</span><br><span class="line">        helper(root-&gt;left); </span><br><span class="line">        helper(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        helper(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="手动压栈实现">手动压栈实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">            s.push(root);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!s.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> top = s.top(); s.pop();</span><br><span class="line">                vi.push_back(top-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (top-&gt;right)    s.push(top-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (top-&gt;left)    s.push(top-&gt;left); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<ul>
<li>因为前序遍历是 ”<strong>根左右</strong>“，所以手动入栈的时候是 <strong>先右孩子，再左孩子</strong></li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>√</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-429-N叉树的层序遍历</title>
    <url>/2019/12/06/leetcode%E9%A2%98%E8%A7%A3-429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归实现bfs">递归实现BFS</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; vvi, <span class="keyword">int</span> level, Node* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add new vector&lt;int&gt; for saving new level elements</span></span><br><span class="line">        <span class="keyword">if</span> (vvi.size() == level)</span><br><span class="line">        &#123;</span><br><span class="line">            vvi.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vvi[level].push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : root-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            helper(vvi, level+<span class="number">1</span>, it);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(Node* root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvi;</span><br><span class="line">        helper(vvi, <span class="number">0</span>, root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vvi;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="手动队列bfs">手动队列BFS</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvi;</span><br><span class="line">        <span class="built_in">deque</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> front = q.front();</span><br><span class="line">                q.pop_front();</span><br><span class="line"></span><br><span class="line">                vi.push_back(front-&gt;val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : front-&gt;children)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (it) q.push_back(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vvi.push_back(vi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vvi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>BFS</tag>
        <tag>√</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-63-二叉树的平均值</title>
    <url>/2019/12/06/leetcode%E9%A2%98%E8%A7%A3-63-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>BFS</tag>
        <tag>√</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-103-二叉树的锯齿形层次遍历</title>
    <url>/2019/12/05/leetcode%E9%A2%98%E8%A7%A3-103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="手动bfs-奇逆序">手动BFS + 奇逆序</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvi;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以加个depth变量，depth为偶数时，[size-1, 0]来存储变量</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> front = q.front();</span><br><span class="line">                q.pop_front();</span><br><span class="line"></span><br><span class="line">                vi.push_back(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;left)   q.push_back(front-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;right)  q.push_back(front-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vvi.push_back(vi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; vvi.size(); ++i, ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vvi[i] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vvi[i].rbegin(), vvi[i].rend());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vvi;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>加个depth变量，depth为偶数时，[size-1, 0]来存储变量 OR 插入后逆序，因为<code>vector::insert</code>代价是<span class="math inline">\(O(N)\)</span>，所以一直从头部差，时间cost过大，或者 用<code>deque</code>，然后用<code>deque</code>中元素赋值给<code>vector</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvi;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以加个depth变量，depth为偶数时，[size-1, 0]来存储变量</span></span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">            ++depth;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> front = q.front();</span><br><span class="line">                q.pop_front();</span><br><span class="line"></span><br><span class="line">                vi.push_back(front-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (front-&gt;left)   q.push_back(front-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;right)  q.push_back(front-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!depth&amp;(depth<span class="number">-1</span>))   vi = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vi.rbegin(), vi.rend());   </span><br><span class="line"></span><br><span class="line">            vvi.push_back(vi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; vvi.size(); ++i, ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vvi[i] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vvi[i].rbegin(), vvi[i].rend());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vvi;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归-奇逆序">递归 + 奇逆序</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; vvi, <span class="keyword">int</span> level, TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add new vector&lt;int&gt; for saving new level elements</span></span><br><span class="line">        <span class="keyword">if</span> (vvi.size() == level)</span><br><span class="line">        &#123;</span><br><span class="line">            vvi.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vvi[level].push_back(root-&gt;val);</span><br><span class="line">        helper(vvi, level+<span class="number">1</span>, root-&gt;left);</span><br><span class="line">        helper(vvi, level+<span class="number">1</span>, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvi;</span><br><span class="line">        helper(vvi, <span class="number">0</span>, root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; vvi.size(); ++i, ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vvi[i] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vvi[i].rbegin(), vvi[i].rend());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vvi;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>BFS</tag>
        <tag>√</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-107-二叉树的层次遍历Ⅱ </title>
    <url>/2019/12/05/leetcode%E9%A2%98%E8%A7%A3-107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E2%85%A1/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="手动队列bfs-reverse结果">手动队列<strong>BFS</strong> + reverse结果</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvi;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> front = q.front();</span><br><span class="line">                q.pop_front();</span><br><span class="line"></span><br><span class="line">                vi.push_back(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;left)   q.push_back(front-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;right)  q.push_back(front-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vvi.push_back(vi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(vvi.rbegin(), vvi.rend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归bfs-逆序">递归BFS + 逆序</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; vvi, <span class="keyword">int</span> level, TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add new vector&lt;int&gt; for saving new level elements</span></span><br><span class="line">        <span class="keyword">if</span> (vvi.size() == level)</span><br><span class="line">        &#123;</span><br><span class="line">            vvi.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vvi[level].push_back(root-&gt;val);</span><br><span class="line">        helper(vvi, level+<span class="number">1</span>, root-&gt;left);</span><br><span class="line">        helper(vvi, level+<span class="number">1</span>, root-&gt;right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvi;</span><br><span class="line">        helper(vvi, <span class="number">0</span>, root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (vvi.rbegin(), vvi.rend());   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有没有办法遍历的时候直接逆序插入呢？？</p>
<h2 id="总结">总结</h2>
<ul>
<li>递归方式BFS实现层次遍历时，需要在<code>vector&lt;vector&lt;int&gt;&gt;</code>的对应层数上存储，所以在<code>helper</code>函数上，需要传参</li>
</ul>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-ceng-ci-bian-li-c-by-huang-fu-mai-yan/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-102-二叉树的层次遍历</title>
    <url>/2019/12/05/leetcode%E9%A2%98%E8%A7%A3-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="手动队列bfs">手动队列<strong>BFS</strong></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvi;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> front = q.front();</span><br><span class="line">                q.pop_front();</span><br><span class="line"></span><br><span class="line">                vi.push_back(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;left)   q.push_back(front-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;right)  q.push_back(front-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vvi.push_back(vi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vvi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间:<span class="math inline">\(O(N)\)</span>, 空间:<span class="math inline">\(O(N)\)</span></p>
<h3 id="官方way">官方way</h3>
<h4 id="递归">递归</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; levels = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// start the current level</span></span><br><span class="line">        <span class="keyword">if</span> (levels.size() == level)</span><br><span class="line">            levels.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// fulfil the current level</span></span><br><span class="line">         levels.get(level).add(node.val);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// process child nodes for the next level</span></span><br><span class="line">         <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(node.left, level + <span class="number">1</span>);</span><br><span class="line">         <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(node.right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> levels;</span><br><span class="line">        helper(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> levels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间:<span class="math inline">\(O(N)\)</span>, 空间:<span class="math inline">\(O(N)+O(logN)= O(N)\)</span>，因为递归自动压栈需要维护一个栈，故空间上常数项系数更大</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; vvi, <span class="keyword">int</span> level, TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// add new vector&lt;int&gt; for saving new level elements</span></span><br><span class="line">        <span class="keyword">if</span> (vvi.size() == level)</span><br><span class="line">        &#123;</span><br><span class="line">            vvi.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vvi[level].push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)     helper(vvi, level+<span class="number">1</span>, root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)    helper(vvi, level+<span class="number">1</span>, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvi;</span><br><span class="line">        helper(vvi, <span class="number">0</span>, root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vvi;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>优化递归函数<code>helper</code>后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; vvi, <span class="keyword">int</span> level, TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add new vector&lt;int&gt; for saving new level elements</span></span><br><span class="line">        <span class="keyword">if</span> (vvi.size() == level)</span><br><span class="line">        &#123;</span><br><span class="line">            vvi.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vvi[level].push_back(root-&gt;val);</span><br><span class="line">        helper(vvi, level+<span class="number">1</span>, root-&gt;left);</span><br><span class="line">        helper(vvi, level+<span class="number">1</span>, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvi;</span><br><span class="line">        helper(vvi, <span class="number">0</span>, root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vvi;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>错误点：</p>
<ul>
<li>需要提前用哨兵记住队列的长度<code>size</code>， 否则在遍历对应层时，长度不断变大，影响结果</li>
<li>对入队的结点来说，只需要入队左右子树非空结点即可。</li>
<li>递归方式BFS实现层次遍历时，需要在<code>vector&lt;vector&lt;int&gt;&gt;</code>的对应层数上存储，所以在<code>helper</code>函数上，需要传参</li>
</ul>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-ci-bian-li-by-leetcode/</p>
<p>https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-ceng-ci-bian-li-c-by-huang-fu-mai-yan/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-110-平衡二叉树</title>
    <url>/2019/12/05/leetcode%E9%A2%98%E8%A7%A3-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">题目</a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    int helper(const TreeNode* root, int level, bool&amp; res)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!root)  return level;</span><br><span class="line"></span><br><span class="line">        int lH = helper(root-&gt;left, level + 1, res);</span><br><span class="line">        if (!res)   return level;</span><br><span class="line"></span><br><span class="line">        int rH = helper(root-&gt;right, level + 1, res);</span><br><span class="line">        if (!res)   return level;</span><br><span class="line"></span><br><span class="line">        if (abs(lH - rH) &gt; 1)    res = false;</span><br><span class="line"></span><br><span class="line">        return max(lH, rH);    </span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    bool isBalanced(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        bool res = true;</span><br><span class="line"></span><br><span class="line">        helper(root, 1, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要保证返回当前结点的 <strong>树高</strong> 和 <strong>是否平衡</strong>。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-559-N叉树的最大深度</title>
    <url>/2019/12/05/leetcode%E9%A2%98%E8%A7%A3-559-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归">递归</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;children.empty())  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Height;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : root-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            Height.push_back(maxDepth(it));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *max_element(Height.begin(), Height.end()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="手动压栈dfs">手动压栈DFS</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;children.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;Node*, <span class="keyword">int</span>&gt;&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>.push(make_pair(root, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_depth = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> top = <span class="built_in">stack</span>.top().first;</span><br><span class="line">            <span class="keyword">int</span> depth = <span class="built_in">stack</span>.top().second;</span><br><span class="line">            max_depth = max(max_depth, depth);</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : top-&gt;children)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(make_pair(it, depth+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="层次遍历">层次遍历</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>.push(root);</span><br><span class="line">    <span class="keyword">int</span> max_depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">queue</span>.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        max_depth++;			</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="built_in">queue</span>.size(); size; size--) </span><br><span class="line">        &#123;</span><br><span class="line">            Node* curr = <span class="built_in">queue</span>.front(); </span><br><span class="line">            <span class="built_in">queue</span>.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node* it : curr-&gt;children)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">queue</span>.push(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_depth;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-111-二叉树的最小深度</title>
    <url>/2019/12/05/leetcode%E9%A2%98%E8%A7%A3-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="递归实现">递归实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l_depth, r_depth;</span><br><span class="line">        l_depth = minDepth(root-&gt;left);</span><br><span class="line">        r_depth = minDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !(root-&gt;left) || !(root-&gt;right) ? l_depth + r_depth + <span class="number">1</span> : min(l_depth, r_depth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="手动压栈dfs">手动压栈DFS</h4>
<p>手动压栈，存储对应树结点和其高度，然后更新左右子树为空时的树高作为最小深度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>.push(make_pair(root, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min_depth = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> top = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line"></span><br><span class="line">            root = top.first;</span><br><span class="line">            <span class="keyword">int</span> depth = top.second;</span><br><span class="line">            <span class="keyword">if</span> (!(root-&gt;left) &amp;&amp; !(root-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                min_depth = min(min_depth, depth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(make_pair(root-&gt;left, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(make_pair(root-&gt;right, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="层次遍历">层次遍历</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        q.push_back(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q.size(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* top = q.front();</span><br><span class="line">                q.pop_front();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!(top-&gt;left) &amp;&amp; !(top-&gt;right))    <span class="keyword">return</span> depth;</span><br><span class="line">                <span class="keyword">if</span> (top-&gt;left)   q.push_back(top-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (top-&gt;right)  q.push_back(top-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/li-jie-zhe-dao-ti-de-jie-shu-tiao-jian-by-user7208/</p>
<h2 id="总结">总结</h2>
<ul>
<li>被情况<span class="math inline">\([1, 2]\)</span>卡住了，因为计算的树深度是指root到leaf(左右孩子为空)的深度，此时应该是2，这个case一开始通过不了</li>
<li>左右子树有一个为空时，则返回左右子树的深度之和 + 1即可。
<ul>
<li>即，省略了对于左，右子树两个子树的两次判断为一次。</li>
<li>一种代码优化结构。</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-104-二叉树的最大深度</title>
    <url>/2019/12/04/leetcode%E9%A2%98%E8%A7%A3-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="my-way">My way</h3>
<h4 id="简单递归实现">简单递归实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left)+<span class="number">1</span>, maxDepth(root-&gt;right)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间<span class="math inline">\(O(N)\)</span>仅超过51%，空间<span class="math inline">\(O(log(N)) + O(N) = O(N)\)</span>超过19%，说明递归压栈吃了不少空间，尝试改成非递归。</p>
<h4 id="手动压栈">手动压栈</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; <span class="built_in">stack</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (root)	<span class="built_in">stack</span>.push(pair(root, <span class="number">1</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">stack</span>.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		pair&lt;TreeNode*, <span class="keyword">int</span>&gt; cur = <span class="built_in">stack</span>.top();</span><br><span class="line">        <span class="built_in">stack</span>.pop();</span><br><span class="line">        root = cur.first;</span><br><span class="line">        <span class="keyword">int</span> cur_depth = cur.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root)</span><br><span class="line">        &#123;</span><br><span class="line">            depth = max(depth, cur_depth);</span><br><span class="line">            <span class="built_in">stack</span>.push(pair(root-&gt;left, cur_depth+<span class="number">1</span>));</span><br><span class="line">            <span class="built_in">stack</span>.push(pair(root-&gt;right, cur_depth+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间<span class="math inline">\(O(N)\)</span>仅超过51%，空间<span class="math inline">\(O(N)\)</span>超过50%，手动压栈节省了不少空间。</p>
<p>有没有时间上更优化的解法呢？</p>
<h4 id="层次遍历">层次遍历</h4>
<h3 id="section"></h3>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-326-3的幂</title>
    <url>/2019/12/02/leetcode%E9%A2%98%E8%A7%A3-326-3%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">题目</a></h2>
<p>我只会第一种循环迭代，后面3种方法均出自leetcode官方题解。</p>
<h3 id="循环迭代">1. 循环迭代</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间: <span class="math inline">\(O(log_b(n))\)</span></p>
<p>空间: <span class="math inline">\(O(1)\)</span></p>
<h3 id="基准转换">2. 基准转换</h3>
<p>将所有的数转化为以3为基数的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(n, <span class="number">3</span>).matches(<span class="string">"^10*$"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间: <span class="math inline">\(O(log_3n)\)</span></p>
<p>空间: <span class="math inline">\(O(log_3n)\)</span></p>
<h3 id="运算法">3. 运算法</h3>
<p><span class="math display">\[
n = 3^i i = log_3(n)i = \frac{log_b(n)}{log_b(3)}
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Math.log10(n) / Math.log10(<span class="number">3</span>)) % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决精度错误，应该设置一个较小的<code>epsilon</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (Math.log(n) / Math.log(<span class="number">3</span>) + epsilon) % <span class="number">1</span> &lt;= <span class="number">2</span> * epsilon;</span><br></pre></td></tr></table></figure>
<h3 id="整数限制">4. 整数限制</h3>
<p>在Java中，该变量是4个byte，则最大值为<span class="math inline">\(\frac{2^{32}}{2} - 1 = 2147483647\)</span>，并得到最大的3的幂为<span class="math inline">\(3^{19} = 1162251467\)</span>.</p>
<ul>
<li>若<code>n</code>是3的幂，则$ 3^{19} % n == 0$必成立</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间: <span class="math inline">\(O(1 )\)</span></p>
<p>空间: <span class="math inline">\(O( 1)\)</span></p>
<h2 id="references">References</h2>
<p>https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-231-2的幂</title>
    <url>/2019/12/02/leetcode%E9%A2%98%E8%A7%A3-231-2%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/power-of-two/submissions/" target="_blank" rel="noopener">题目</a></h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; !(n&amp;(n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>考虑：</p>
<ul>
<li><p><code>num &gt; 0</code>时，才会是一个数的幂。负数和0不会是一个正整数的幂。</p></li>
<li><p><code>!(num&amp;(num-1))</code>时，用来判断<code>num</code>是不是2的幂，</p>
<ul>
<li>因为一个数是2的幂的话，则它2进制的第一位必然是1，与<code>num-1</code>与运算后，结果必然为0</li>
</ul></li>
</ul>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/power-of-four/solution/e-you-shi-yi-dao-zhuang-bi-jie-fa-de-suan-fa-ti-2/</p>
<p>https://www.geeksforgeeks.org/program-to-find-whether-a-no-is-power-of-two/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-324-4的幂</title>
    <url>/2019/12/02/leetcode%E9%A2%98%E8%A7%A3-324-4%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/power-of-four/solution/" target="_blank" rel="noopener">题目</a></h2>
<h3 id="非位运算解">非位运算解：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mod;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mod = num % <span class="number">4</span>;</span><br><span class="line">            num /= <span class="number">4</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (mod != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="位运算">位运算：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">0</span> &amp;&amp; !(num&amp;(num<span class="number">-1</span>)) &amp;&amp; !(num &amp; <span class="number">0xAAAAAAAA</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>考虑：</p>
<ul>
<li><code>num &gt; 0</code>时，才会是一个数的幂。负数和0不会是一个正整数的幂。</li>
<li><code>!(num&amp;(num-1))</code>时，用来判断<code>num</code>是不是2的幂，
<ul>
<li>因为一个数是2的幂的话，则它2进制的第一位必然是1，与<code>num-1</code>与运算后，结果必然为0</li>
</ul></li>
<li><code>!(num &amp; 0xAAAAAAAA)</code>, 用来判断<code>num</code>是不是4的幂，
<ul>
<li>因为一个数是4的幂的话，则它2进制必然第一位是1且第一位是奇数位，<code>0xA=1010</code>，则4的幂与其求与运算后，则为0，求反得1</li>
</ul></li>
</ul>
<h2 id="总结">总结</h2>
<p>位运算小技巧：</p>
<ul>
<li><code>!(n&amp;(n-1))</code>，用于判断<code>n</code>是不是2的幂</li>
<li><code>!(num&amp;(num-1)) &amp;&amp; !(num &amp; 0xAAAAAAAA)</code>, 用于判断<code>n</code>是不是4的幂</li>
<li>对于<code>n</code>的幂，可以先枚举一定的例子，然后对枚举结果进行归纳找到规律。</li>
</ul>
<h2 id="reference">Reference</h2>
<p>https://leetcode-cn.com/problems/power-of-four/solution/e-you-shi-yi-dao-zhuang-bi-jie-fa-de-suan-fa-ti-2/</p>
<p>https://www.geeksforgeeks.org/program-to-find-whether-a-no-is-power-of-two/</p>
<p>https://www.geeksforgeeks.org/find-whether-a-given-number-is-a-power-of-4-or-not/</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题.md</title>
    <url>/2019/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-md/</url>
    <content><![CDATA[<p>背包问题总共有9种，称为<strong>背包9讲</strong>。</p>
<ol type="1">
<li>01背包问题</li>
<li>完全背包问题</li>
<li>多重背包问题</li>
<li>混合背包问题</li>
<li>二维费用的背包问题</li>
<li>分组背包问题</li>
<li>背包问题求方案数</li>
<li>求背包问题的方案</li>
<li>有依赖的背包问题</li>
</ol>
<p>有<span class="math inline">\(N\)</span>件物品和一个容量是<span class="math inline">\(V\)</span>的背包。</p>
<blockquote>
<p>不同背包问题的条件：每件物品只能使用一次。</p>
</blockquote>
<p>第<span class="math inline">\(i\)</span>件物品的体积是 <span class="math inline">\(v_i\)</span>，价值是 <span class="math inline">\(w_i\)</span>。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。</p>
<h4 id="输入格式">输入格式</h4>
<p>第一行两个整数，<span class="math inline">\(N, V\)</span>用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 <span class="math inline">\(N\)</span> 行，每行两个整数 <span class="math inline">\(v_i, w_i\)</span>，用空格隔开，分别表示第 <span class="math inline">\(i\)</span> 件物品的体积和价值。</p>
<h4 id="输出格式">输出格式</h4>
<p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围">数据范围</h4>
<p><span class="math inline">\(0&lt;N,V≤10000\)</span> <span class="math inline">\(0&lt;v_i,w_i≤10000\)</span></p>
<h4 id="输入样例">输入样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<h4 id="输出样例">输出样例：</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h2 id="背包问题">01背包问题</h2>
<h3 id="题目描述">题目描述</h3>
<p>有<span class="math inline">\(N\)</span>件物品和一个容量是<span class="math inline">\(V\)</span>的背包。</p>
<blockquote>
<p>每件物品只能使用一次。</p>
</blockquote>
<p>第<span class="math inline">\(i\)</span>件物品的体积是 <span class="math inline">\(v_i\)</span>，价值是 <span class="math inline">\(w_i\)</span>。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。</p>
<h4 id="输入格式-1">输入格式</h4>
<p>第一行两个整数，<span class="math inline">\(N, V\)</span>用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 <span class="math inline">\(N\)</span> 行，每行两个整数 <span class="math inline">\(v_i, w_i\)</span>，用空格隔开，分别表示第 <span class="math inline">\(i\)</span> 件物品的体积和价值。</p>
<h4 id="输出格式-1">输出格式</h4>
<p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围-1">数据范围</h4>
<p><span class="math inline">\(0&lt;N,V≤10000\)</span> <span class="math inline">\(0&lt;v_i,w_i≤10000\)</span></p>
<h4 id="输入样例-1">输入样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<h4 id="输出样例-1">输出样例：</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="解">解</h3>
<h4 id="状态">状态：</h4>
<p>状态<span class="math inline">\(f[i][j]\)</span>表示前<span class="math inline">\(i\)</span>个物品的总体积<span class="math inline">\(j\)</span>下，总价值为<span class="math inline">\(f[i][j]\)</span>.</p>
<p><span class="math inline">\(result = f[i][j]\)</span></p>
<p>初始状态：<span class="math inline">\(f[0][0] = 0\)</span></p>
<p>终止状态：<span class="math inline">\(f[n][m]\)</span></p>
<h4 id="状态转移方程">状态转移方程：</h4>
<p>考虑第<span class="math inline">\(i\)</span>个状态和<span class="math inline">\(i-1\)</span>个状态间的递推关系:</p>
<ul>
<li><p>不选第<span class="math inline">\(i\)</span>个物品，<span class="math inline">\(f[i][j] = f[i-1][j]\)</span></p></li>
<li><p>选第<span class="math inline">\(i\)</span>个物品，<span class="math inline">\(f[i][j] = f[i-1][j-v[i]] + w[i]\)</span></p></li>
<li><p><span class="math inline">\(f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+ w[i])\)</span></p>
<p>其中<span class="math inline">\(v[i]\)</span>是第<span class="math inline">\(i\)</span>个物品的体积, <span class="math inline">\(w[i]\)</span>是第<span class="math inline">\(j\)</span>个物品的价值</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> V[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (j &gt;= m)</span><br><span class="line">			&#123;</span><br><span class="line">				f[i][j] = max(f[i][j], f[i<span class="number">-1</span>][j-v[i]] + w[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="因为状态i每次都仅依赖状态i-1故可以优化额外空间复杂度为ologn">因为状态<span class="math inline">\(i\)</span>每次都仅依赖状态<span class="math inline">\(i-1\)</span>，故可以优化额外空间复杂度为<span class="math inline">\(O(logN)\)</span></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)	<span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= v[i]; --j)</span><br><span class="line">			f[j] = max(f[j], f[j-v[i]] + w[i]);</span><br><span class="line">			</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    所有f[i] = 0, 则输出f[m];</span></span><br><span class="line"><span class="comment">    假如仅f[0] = 0, 则需要遍历一遍枚举出最小值;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化输入部分后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;=v; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = max(f[j], f[j-v] + w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>因为要依赖dp表中上一层的状态，要先更新下标比较大的dp数组元素，此时通过状态转移方程求最大值的时候还未更新下标较小的dp数组元素，即下标较小的dp数组元素还是上一层的值，所以要逆序遍历。</p></li>
<li><p>要保证在1维DP中计算<span class="math inline">\(f[j]\)</span>状态时，用的是<span class="math inline">\(f[i-1][j-v[i]]\)</span>而不是<span class="math inline">\(f[i][j-v[i]]\)</span>的</p></li>
<li><p>！不能理解的时候再去看dp表，因为要保证这一层的状态依赖于上一层的状态。</p>
<ul>
<li><p>e.g. 若顺序计算的话</p>
<p>对于 <span class="math inline">\(i=2, j=6, v[2] = 3\)</span>，</p>
<p><span class="math inline">\(dp[6]=max(dp[6], dp[6-v[2]]+w[2]) = max(dp[6], dp[3] + w[2])\)</span></p>
<p>因为动态规划是第<span class="math inline">\(i\)</span>层的状态依赖于第<span class="math inline">\(i-1\)</span>层的。</p>
<p>这时，要计算<span class="math inline">\(max\)</span>外的<span class="math inline">\(dp[6]\)</span>，要用到<span class="math inline">\(max\)</span>内的<span class="math inline">\(dp[6], dp[3]\)</span>。</p>
<p>其中<span class="math inline">\(max\)</span>内的<span class="math inline">\(dp[6]\)</span>是第<span class="math inline">\(i-1\)</span>层的，是<span class="math inline">\(dp[3]\)</span>是第<span class="math inline">\(i\)</span>层的，故使得状态转移不满足要求，所以得逆序。</p>
<p>可以见 <a href="https://www.cnblogs.com/lanhj/archive/2012/12/05/2802437.html" target="_blank" rel="noopener">此处例子</a></p></li>
</ul></li>
</ul>
<h2 id="完全背包问题">完全背包问题</h2>
<p>有<span class="math inline">\(N\)</span>件物品和一个容量是<span class="math inline">\(V\)</span>的背包。</p>
<blockquote>
<p>每件物品都有无限件可用。</p>
</blockquote>
<p>第<span class="math inline">\(i\)</span>件物品的体积是 <span class="math inline">\(v_i\)</span>，价值是 <span class="math inline">\(w_i\)</span>。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。</p>
<h4 id="输入格式-2">输入格式</h4>
<p>第一行两个整数，<span class="math inline">\(N, V\)</span>用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 <span class="math inline">\(N\)</span> 行，每行两个整数 <span class="math inline">\(v_i, w_i\)</span>，用空格隔开，分别表示第 <span class="math inline">\(i\)</span> 件物品的体积和价值。</p>
<h4 id="输出格式-2">输出格式</h4>
<p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围-2">数据范围</h4>
<p><span class="math inline">\(0&lt;N,V≤10000\)</span> <span class="math inline">\(0&lt;v_i,w_i≤10000\)</span></p>
<h4 id="输入样例-2">输入样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<h4 id="输出样例-2">输出样例：</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="解-1">解：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要累加每一次的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = max(f[j], f[j-v] + w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上看就是，把 <strong>01背包</strong> 的代码的二重循环，由重后往前遍历，改成了重前往后遍历。</p>
<p>从状态转移方程上来看，通过二维DP表的形式:</p>
<ul>
<li><p><span class="math inline">\(f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+ w[i])\)</span></p>
<p><span class="math inline">\(max(不选第i个物品，\ 选了第i个物品)\)</span></p></li>
<li><p><span class="math inline">\(if\ j-v[i]*k &lt;= 0 \\f[i][j] = max(f[i-1][j], f[i][j-v[i]]+ w[i], f[i][j-v[i]*2]+w[i]*2+...)\)</span></p>
<p><span class="math inline">\(max(不选第i个物品，\ 选了第i个物品1次, \ 选了第i个物品2次, ...)\)</span></p>
<blockquote>
<p>现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v= 0..V的顺序循环。</p>
<p>或者由这个2维动态转移方程得来。</p>
</blockquote></li>
</ul>
<h2 id="混合背包问题">混合背包问题</h2>
<h2 id="references">References</h2>
<p>https://www.cnblogs.com/jbelial/articles/2116074.html</p>
<p>https://www.bilibili.com/video/av33930433?p=1</p>
<p>https://www.acwing.com/solution/acwing/content/3982/</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-264-丑数Ⅱ</title>
    <url>/2019/11/27/leetcode%E9%A2%98%E8%A7%A3-264-%E4%B8%91%E6%95%B0%E2%85%A1/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/ugly-number-ii/submissions/" target="_blank" rel="noopener">题目</a></h2>
<ol type="1">
<li>用STL实现小根堆</li>
</ol>
<p>按理说应该实现些其它功能，比如：</p>
<ul>
<li>vecotor中是否包含multiple elements</li>
<li>堆的一些常用功能，如：heapify</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; vi = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        make_heap(vi.begin(), vi.end(), greater&lt;&gt;());</span><br><span class="line">        <span class="keyword">long</span> top;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pop_heap(vi.begin(), vi.end(), greater&lt;&gt;());</span><br><span class="line">            </span><br><span class="line">            top = vi.back();</span><br><span class="line">            vi.pop_back();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (find(vi.begin(), vi.end(), top*<span class="number">2</span>) == vi.end())</span><br><span class="line">            &#123;</span><br><span class="line">                vi.push_back(top*<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (find(vi.begin(), vi.end(), top*<span class="number">3</span>) == vi.end())</span><br><span class="line">            &#123;</span><br><span class="line">                vi.push_back(top*<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (find(vi.begin(), vi.end(), top*<span class="number">5</span>) == vi.end())</span><br><span class="line">            &#123;</span><br><span class="line">                vi.push_back(top*<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            make_heap(vi.begin(), vi.end(), greater&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际上效率低了，因为用原生的<code>make_heap</code>需要重新构造一次堆，但是用<code>heapify</code>这种调整堆结构会快很多。</p>
<ol start="2" type="1">
<li>DP实现</li>
</ol>
<p>状态转移方程： <span class="math display">\[
dp[i] = min(2*dp[l_2], 3*dp[l_3], 5*dp[l_5])
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; dp(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l2 = <span class="number">1</span>, l3 = <span class="number">1</span>, l5 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = min(<span class="number">2</span>*dp[l2], min(<span class="number">3</span>*dp[l3], <span class="number">5</span>*dp[l5]));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt;= <span class="number">2</span>*dp[l2])</span><br><span class="line">            &#123;</span><br><span class="line">                l2 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt;= <span class="number">3</span>*dp[l3])</span><br><span class="line">            &#123;</span><br><span class="line">                l3 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt;= <span class="number">5</span>*dp[l5])</span><br><span class="line">            &#123;</span><br><span class="line">                l5 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/ugly-number-ii/solution/dui-he-dong-tai-gui-hua-by-powcai/" target="_blank" rel="noopener">powcai解</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-204-计数质数</title>
    <url>/2019/11/27/leetcode%E9%A2%98%E8%A7%A3-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<h2 id="section"></h2>
<h2 id="题目"><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">题目</a></h2>
<p>最佳思路，<strong>Sieve of Eratosthenes</strong> 又或者叫 <strong>数筛</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] isPrim = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    Arrays.fill(isPrim, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) </span><br><span class="line">        <span class="keyword">if</span> (isPrim[i]) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) </span><br><span class="line">                isPrim[j] = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (isPrim[i]) count++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isPrime[n];</span><br><span class="line">        <span class="built_in">memset</span>(isPrime, <span class="literal">true</span>, <span class="keyword">sizeof</span>(isPrime));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i*i; j &lt; n; j += i)</span><br><span class="line">                &#123;</span><br><span class="line">					isPrim[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i]) ++count;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>质数的判断上的条件优化
<ul>
<li>只用判断到<span class="math inline">\(\sqrt{n}\)</span>即可，我之前都是判断到<span class="math inline">\(n/2\)</span></li>
</ul></li>
<li>我对于数筛法的理解是：</li>
<li>一种 <strong>记忆化搜索</strong>， 减少了重复子过程的计算。
<ul>
<li>非质数 = 质数 * 质数</li>
<li>非质数 = 非质数 * 非质数/质数</li>
</ul></li>
</ul>
<h2 id="references">References</h2>
<p><a href="https://leetcode-cn.com/problems/count-primes/solution/ru-he-gao-xiao-pan-ding-shai-xuan-su-shu-by-labula/" target="_blank" rel="noopener">labuladong 解</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-263-丑数</title>
    <url>/2019/11/27/leetcode%E9%A2%98%E8%A7%A3-263-%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/ugly-number/" target="_blank" rel="noopener">题目</a></h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ori = num;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num /= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num /= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num /= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ori == num)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路">思路：</h4>
<p>丑数： 因数包括 1，2， 3， 5的数。</p>
<p>所以考虑 <strong>非丑数</strong> 的2种情况：</p>
<ol type="1">
<li>除了1，2，3，5的质数</li>
<li>因数除了 1，2，3，5外，还有质数的非质数</li>
</ol>
<ul>
<li>模2， 3，5后，这个数还是原来的值 =&gt; 非丑数</li>
<li>模2， 3，5后，这个数为1 =&gt; 丑数</li>
<li>模2， 3，5后，这个数为一个不为1的数，继续模2，3，5，直至出现上面两种情况。</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>数学题，考虑找规律，找补集思考</li>
<li>质数 常涉及到 <span class="math inline">\(/, \%\)</span>运算？</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-202-快乐数</title>
    <url>/2019/11/27/leetcode%E9%A2%98%E8%A7%A3-202-%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-1155-掷骰子的N种方法</title>
    <url>/2019/11/21/leetcode%E9%A2%98%E8%A7%A3-1155-%E6%8E%B7%E9%AA%B0%E5%AD%90%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; <span class="number">1</span> || f &lt; <span class="number">1</span> || target &lt; <span class="number">1</span> || target &gt; d*f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">int</span> MIN = min(f, target);</span><br><span class="line">        <span class="comment">// 3.</span></span><br><span class="line">        <span class="keyword">int</span> MAX = d*f;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(d+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(MAX+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= MIN; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= d; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 因为每个筛子至少丢出来的值是 &gt;=1 的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= MAX; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; j - k &gt;= <span class="number">0</span> &amp;&amp; k &lt;= f; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i<span class="number">-1</span>][j-k]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[d][target];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-403-青蛙过河</title>
    <url>/2019/11/14/leetcode%E9%A2%98%E8%A7%A3-403-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/frog-jump/" target="_blank" rel="noopener">题目</a></h2>
<h2 id="my-way">My way</h2>
<h3 id="暴力解">1.暴力解</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> curPos, <span class="keyword">int</span> jumpSize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nextPos = curPos+<span class="number">1</span>; nextPos &lt; stones.size(); ++nextPos)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">// gap值表示curPos位置 跳到 i位置 的跳跃距离</span></span><br><span class="line">            <span class="keyword">int</span> gap = stones[nextPos] - stones[curPos];</span><br><span class="line">            <span class="keyword">if</span> (gap &gt;= jumpSize - <span class="number">1</span> &amp;&amp; gap &lt;= jumpSize + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="comment">// 能跳到i位置，则递归下去</span></span><br><span class="line">                <span class="keyword">if</span> (helper(stones, nextPos, gap))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curPos == stones.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="记忆化搜索">2. 记忆化搜索</h3>
<p>利用暴力解的递归关系，使用一个数组提前存储好对应的值，然后查询的时候遇到已有的结果则提前跳出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> curPos, <span class="keyword">int</span> jumpSize, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mem)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 已有的计算结果则提前跳出</span></span><br><span class="line">        <span class="keyword">if</span> (mem[curPos][jumpSize] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mem[curPos][jumpSize];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nextPos = curPos+<span class="number">1</span>; i &lt; stones.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// gap值表示curPos位置 跳到 i位置 的跳跃距离</span></span><br><span class="line">            <span class="keyword">int</span> gap = stones[nextPos] - stones[curPos];</span><br><span class="line">            <span class="keyword">if</span> (gap &gt;= jumpSize - <span class="number">1</span> &amp;&amp; gap &lt;= jumpSize + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 能从curPos位置 跳到 i位置上，则记录为1</span></span><br><span class="line">                <span class="keyword">if</span> (helper(stones, nextPos, gap, mem) == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    mem[nextPos][gap] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 假如能跳到最后一个位置上，则记录下，反之同理</span></span><br><span class="line">        mem[curPos][jumpSize] = (curPos == stones.size()<span class="number">-1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> mem[curPos][jumpSize];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mem(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (helper(stones, <span class="number">0</span>, <span class="number">0</span>, mem) == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="dp">3.<del>DP</del></h3>
<p>在思考怎么通过已有的递归中的依赖关系 &lt;=&gt; dp的状态转移方程上去。</p>
<p>发现假如是使用2维DP表的话，是不可成立的，因为一个i值需要对应多个j值，所以无从下手。</p>
<h2 id="官方解">官方解</h2>
<h3 id="记忆化搜索-二分查找">1.记忆化搜索 + 二分查找</h3>
<p>在检索位置<code>curPos</code> + <code>jumpSize</code>时候，使用二分搜索来查找位置上是否有石头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[stones.length][stones.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> can_Cross(stones, <span class="number">0</span>, <span class="number">0</span>, memo) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">can_Cross</span><span class="params">(<span class="keyword">int</span>[] stones, <span class="keyword">int</span> ind, <span class="keyword">int</span> jumpsize, <span class="keyword">int</span>[][] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[ind][jumpsize] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[ind][jumpsize];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ind1 = Arrays.binarySearch(stones, ind + <span class="number">1</span>, stones.length, stones[ind] + jumpsize);</span><br><span class="line">        <span class="keyword">if</span> (ind1 &gt;= <span class="number">0</span> &amp;&amp; can_Cross(stones, ind1, jumpsize, memo) == <span class="number">1</span>) &#123;</span><br><span class="line">            memo[ind][jumpsize] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ind2 = Arrays.binarySearch(stones, ind + <span class="number">1</span>, stones.length, stones[ind] + jumpsize - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ind2 &gt;= <span class="number">0</span> &amp;&amp; can_Cross(stones, ind2, jumpsize - <span class="number">1</span>, memo) == <span class="number">1</span>) &#123;</span><br><span class="line">            memo[ind][jumpsize - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ind3 = Arrays.binarySearch(stones, ind + <span class="number">1</span>, stones.length, stones[ind] + jumpsize + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ind3 &gt;= <span class="number">0</span> &amp;&amp; can_Cross(stones, ind3, jumpsize + <span class="number">1</span>, memo) == <span class="number">1</span>) &#123;</span><br><span class="line">            memo[ind][jumpsize + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[ind][jumpsize] = ((ind == stones.length - <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> memo[ind][jumpsize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dp-1">2.DP</h3>
<p>在动态规划方法中，我们会利用散列表 mapmap，对于散列表中的 key:valuekey:value，keykey 表示当前石头的位置，valuevalue 是一个包含 jumpsizejumpsize 的集合，其中每个 jumpsizejumpsize 代表可以通过大小为 jumpysizejumpysize 的一跳到达当前位置。</p>
<p>首先我们对散列表初始化，keykey 为所有石头的位置，除了位置 0 对应的 valuevalue 为包含一个值 0 的集合以外，其余都初始化为空集。接下来，依次遍历每个位置上的石头。对于每个 currentPositioncurrentPosition，遍历 valuevalue 中每个 jumpsizejumpsize，判断位置 currentPosition + newjumpsizecurrentPosition+newjumpsize 是否存在于 mapmap 中，对于每个 jumpsizejumpsize，newjumpsizenewjumpsize 分别为 jumpsize-1jumpsize−1，jumpsizejumpsize，jumpsize+1jumpsize+1。如果找到了，就在对应的 valuevalue 集合里新增 newjumpsizenewjumpsize。重复这个过程直到结束。如果在结束的时候，最后一个位置对应的集合非空，那也就意味着我们可以到达终点，如果还是空集那就意味着不能到达终点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Set&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">            map.put(stones[i], <span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(<span class="number">0</span>).add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k : map.get(stones[i])) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> step = k - <span class="number">1</span>; step &lt;= k + <span class="number">1</span>; step++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (step &gt; <span class="number">0</span> &amp;&amp; map.containsKey(stones[i] + step)) &#123;</span><br><span class="line">                        map.get(stones[i] + step).add(step);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(stones[stones.length - <span class="number">1</span>]).size() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>暴力递归解总是有的，不过要找出一个靠谱的递归实现，然后可以通过其优化为 用一个数组存好结果的记忆化搜索的方式；</li>
<li>dp数组可以是 <strong>hash散列</strong> 这种存储方式，不一定是 数组 的存储方式。</li>
</ul>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/frog-jump/solution/qing-wa-guo-he-by-leetcode/" target="_blank" rel="noopener">官方解</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>DFS</tag>
        <tag>数组</tag>
        <tag>特殊DP数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-638-大礼包</title>
    <url>/2019/11/04/leetcode%E9%A2%98%E8%A7%A3-638-%E5%A4%A7%E7%A4%BC%E5%8C%85/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/shopping-offers/" target="_blank" rel="noopener">题目</a></h2>
<h2 id="my-way">My way</h2>
<p>题目有提到 <strong>大礼包以优惠的价格捆绑销售一组物品</strong> &lt;=&gt; <strong>大礼包价格更优惠，优先级更高</strong>。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>DFS</tag>
        <tag>数组</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-312-戳气球</title>
    <url>/2019/11/04/leetcode%E9%A2%98%E8%A7%A3-312-%E6%88%B3%E6%B0%94%E7%90%83/</url>
    <content><![CDATA[<h2 id="my-way">My way</h2>
<h4 id="很蠢的思路">很蠢的思路：</h4>
<ul>
<li>选择<code>min</code>值，爆掉，然后循环至结束。</li>
</ul>
<p>测都不用测。。。</p>
<p>没想到怎么往DP上面套。</p>
<h2 id="ivan_allen-解">ivan_allen 解</h2>
<h4 id="思路转变">思路转变：</h4>
<p><strong>气球从头到尾爆炸 &lt;=&gt; 气球从尾到头爆炸</strong></p>
<h4 id="状态转移方程">状态转移方程:</h4>
<p><span class="math display">\[
dp[i][j] = max(dp[i][j],\ nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j]), \text{if $k \in\ [i,\ j]$}
\]</span></p>
<h4 id="遍历方式">遍历方式：</h4>
<ul>
<li>控制子数组长度<code>len</code></li>
<li>子数组首尾<code>i</code>, <code>j</code></li>
<li>使用<code>k</code>对数组分割</li>
</ul>
<h4 id="二维dp实现">二维DP实现：</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加哨兵在头尾，因为假如最后只删一个数字的时候，是需要乘以2个1的</span></span><br><span class="line">        nums.insert(nums.begin(), <span class="number">1</span>);</span><br><span class="line">        nums.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只能按长度打表</span></span><br><span class="line">        <span class="comment">// dp[i][j], j - i &gt;= 2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; m; ++len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j]);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><p>思路的转变：</p>
<ul>
<li><strong>气球从头到尾爆炸 &lt;=&gt; 气球从尾到头爆炸</strong></li>
</ul></li>
<li><p><strong>头尾虚拟1的添加</strong> 类似于之前<strong>虚拟0的添加</strong> 和 <strong>哨兵的思想</strong></p></li>
</ul>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/burst-balloons/solution/dong-tai-gui-hua-by-ivan_allen-2/" target="_blank" rel="noopener">ivan_allen解</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>分治算法</tag>
        <tag>哨兵</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-62-不同路径</title>
    <url>/2019/11/04/leetcode%E9%A2%98%E8%A7%A3-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="my-way">My way</h2>
<h3 id="维dp">1. 2维DP</h3>
<h4 id="状态转移方程">状态转移方程：</h4>
<p><span class="math display">\[
\begin{align*}
&amp; dp[i][j] = dp[i-1][j] + dp[i][j-1] \\
\end{align*}
\]</span></p>
<h4 id="base-case">base case:</h4>
<p><span class="math display">\[
\begin{align*}
&amp; dp[i][j] = 1,\ \text{if $i==1$ or $j==1$} \\
\end{align*}
\]</span></p>
<h4 id="corner-case">corner case:</h4>
<p><span class="math display">\[
\begin{align*}
&amp; dp[i][j] = 1, \text{if $i == 1$ and $j == 1$} \\
&amp; AND \\
&amp; return\ function
\end{align*}
\]</span></p>
<h3 id="维dp-1">2. 1维DP</h3>
<p>还可以转换成1维DP.</p>
<h2 id="powcai-way">powcai way</h2>
<h3 id="组合数学">组合数学：</h3>
<p>PS： 这个排列组合的方法其实我想到过，但是没有找出通项公式 :cry:</p>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/" target="_blank" rel="noopener">powcai 解</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>2维DP-to-1维DP</tag>
        <tag>组合数学</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-413.等差数列划分</title>
    <url>/2019/11/03/leetcode%E9%A2%98%E8%A7%A3-413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h2 id="my-way">My way</h2>
<h4 id="状态转移方程">状态转移方程:</h4>
<p><span class="math display">\[
dp[i][j] = 
\begin{cases}
&amp; 2^{j-i-2}-1 &amp; \text{if $A[i:j]$是等差数列}\\
&amp; dp[i-1][j] + dp[i][j-1] &amp; otherwise\\
\end{cases}
\]</span></p>
<h2 id="官方解">官方解</h2>
<h3 id="优雅暴力">2. 优雅暴力</h3>
<h3 id="递归">3. 递归</h3>
<h4 id="状态定义">状态定义：</h4>
<p><span class="math display">\[
\begin{align*} 
&amp; sum:\ 数组A中的所有的等差数列的个数 \\
&amp; slice(A,\ i):\ 求区间(k,\ i)中，而不在区间(k,\ j)中等差数列的个数，其中j&lt;i. \\
&amp;
\end{align*}
\]</span></p>
<ul>
<li>假设知道了<span class="math inline">\(slice(A, i-1)\)</span>的值为x, 同时这个区间元素用<span class="math inline">\([a_0, a_1, a_2, ..., a_{i-1}]\)</span>来表示。</li>
<li>若这个区间本身就是一个等差数列，那么这里所有相邻元素之间的差值是相等的。</li>
<li>现加入一个元素<span class="math inline">\(a_i\)</span>将区间扩展为<span class="math inline">\((0,\ i)\)</span>，如果扩展之后的区间还是一个等差数列，那么一定存在<span class="math inline">\(a_i - a_{(i-1)} == a_{(i-1)} -a_{(i-2)}\)</span>.</li>
<li><p>故每加入一个新元素，就会多出<span class="math inline">\(ap\)</span>个等差数列。其中新增的等差数列的区间为<span class="math inline">\((0,i), (1,i), ..., (i-2, i)\)</span>, 这些区间总数为<span class="math inline">\(x+1\)</span>. 这是因为除了区间<span class="math inline">\((0,i)\)</span>之外，其余的区间如<span class="math inline">\((1,i), (2,i),...,(i-2,i)\)</span>都可以对应到之前的区间<span class="math inline">\((0,i-1), (1,i-1), ...,(i-3,i-1)\)</span>上去，其值为<span class="math inline">\(x\)</span>.</p></li>
<li>因此，每次调用<code>slices</code>, 如果第<span class="math inline">\(i\)</span>个元素与前一个元素的差值正好等于之前的差值，我们直接就可以算出新增的等差数列的个数<span class="math inline">\(ap\)</span>, 同时可以更新<span class="math inline">\(sum\)</span>.</li>
<li><p>但是，如果新元素跟之前一个元素的差值不等于之前的差值，也就不会增加等差数列的个数</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        slices(A, A.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slices</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">            ap = <span class="number">1</span> + slices(A, i - <span class="number">1</span>);</span><br><span class="line">            sum += ap;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            slices(A, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dp">4.DP</h3>
<h4 id="状态定义-1">状态定义：</h4>
<p><span class="math display">\[
\begin{align*}
&amp; dp:\ 存储在区间(k,i), 而不在区间(k,j)中的等差数列个数，其中j&lt;i\\
&amp; 
\end{align*}
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp[i] = <span class="number">1</span> + dp[i - <span class="number">1</span>];</span><br><span class="line">                sum += dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="o1空间复杂度dp">5.<span class="math inline">\(O(1)空间复杂度\)</span>DP</h3>
<p>对于<span class="math inline">\(dp\)</span>数组来说，仅有<span class="math inline">\(dp[i-1]\)</span>决定<span class="math inline">\(dp[i]\)</span>.</p>
<p>故只用保存最近一个<span class="math inline">\(dp\)</span> 就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp = <span class="number">1</span> + dp;</span><br><span class="line">                sum += dp;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                dp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="公式计算">6. 公式计算</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += (count + <span class="number">1</span>) * (count) / <span class="number">2</span>;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum += count * (count + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="reference">reference</h2>
<h3 id="extended">extended</h3>
<p><a href="https://stackoverflow.com/questions/3221812/how-to-sum-up-elements-of-a-c-vector" target="_blank" rel="noopener">How to sum up elements of a C++ vector?</a></p>
<p><a href="https://stackoverflow.com/questions/58681103/how-to-sum-up-a-vector-of-vector-int-in-c-without-loops" target="_blank" rel="noopener">how to sum up a vector of vector int in C++ without loops</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>递归</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-303-区域和检索 - 数组不可变</title>
    <url>/2019/11/03/leetcode%E9%A2%98%E8%A7%A3-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">题目</a></h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="my-way">My way</h2>
<h3 id="暴力法">1. 暴力法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        dp = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += dp[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>结果，时间复杂度极低，仅超过10%的解。</p>
<p>很明显是要先用dp数组存入各个索引<span class="math inline">\(i\)</span>, <span class="math inline">\(j\)</span>对应的值。</p>
<h3 id="维dp">2. 2维DP</h3>
<h4 id="状态转移方程">状态转移方程：</h4>
<p><span class="math display">\[
dp[i][j] = dp[i][j-1] + nums[j-1]
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums):dp(nums.size()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.size()+<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= nums.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>] + nums[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>结果更慢了，仅超过5%的解。。。</p>
<p>应该是哪里思路出了问题...</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> **dp;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span><br><span class="line">    &#123;</span><br><span class="line">        m = nums.size() + <span class="number">1</span>;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>*[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= nums.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += nums[j<span class="number">-1</span>];</span><br><span class="line">                dp[i][j] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~NumArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> []dp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> []dp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>换成原生数组，时间复杂度仅超过7%，仍然很糟糕。。。</p>
<p>假如直接静态数组<code>int dp[INT_MAX][INT_MAX];</code>，内存会炸掉。。。</p>
<h2 id="官方way">官方way</h2>
<h3 id="缓存">2. 缓存</h3>
<p>将计算结果提前存入到 <strong>哈希表</strong> 中。</p>
<p>PS：而我用的是<code>vector&lt;vector&lt;int&gt;&gt; dp, int **dp</code>, 感觉没区别，应该是<code>resize()/动态分配内存</code>那耗费了不少时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Pair&lt;Integer, Integer&gt;, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            map.put(Pair.create(i, j), sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(Pair.create(i, j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缓存-1">3. 缓存</h3>
<p>优化空间复杂度从<span class="math inline">\(O(n^2) = &gt; O(n)\)</span>. <span class="math display">\[
sum[k] = 
\begin{cases}
&amp; \sum_{i=0}^{k-1} nums[i] &amp; , k &gt; 0 \\
&amp; 0                        &amp; , k == 0\\
\end{cases}
\]</span> 优化为: <span class="math display">\[
sumrange(i,\ j)= sum[j+1] - sum[i]
\]</span> java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[j + <span class="number">1</span>] - sum[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++: use array</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span> [nums.size() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~NumArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> []sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[j + <span class="number">1</span>] - sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>但这也只超过了 78.45%...</p>
<p>C++: user <code>vector&lt;int&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        dp.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            dp.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[j+<span class="number">1</span>]-dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>超过了96.23%，代码类似 <a href="https://leetcode-cn.com/problems/range-sum-query-immutable/solution/qu-yu-he-jian-suo-shu-zu-bu-ke-bian-by-gpe3dbjds1/" target="_blank" rel="noopener">陈乐乐解2</a>.</p>
<p>但仔细看她代码，你会发现她在C++编码时，有个很不好的习惯，我在这纠正了，就不指出来了。</p>
<h2 id="总结">总结</h2>
<ul>
<li>傻了，老想着把计算结果存起来，到时候直接取，居然忘记了
<ul>
<li><span class="math inline">\(sumrange(i,\ j)= sum[j+1] - sum[i]\)</span></li>
</ul></li>
<li>这里也用到了插入了一个虚拟 0 作为 sum 数组中的第一个元素。
<ul>
<li>这个技巧可以避免在 sumrange 函数中进行额外的条件检查，对于base case, corner case等等</li>
<li>PS：尽管，我其实喜欢加上对于base case, corner case的检查，但却是实现起来有些冗余</li>
</ul></li>
</ul>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/solution/qu-yu-he-jian-suo-shu-zu-bu-ke-bian-by-leetcode/" target="_blank" rel="noopener">官方解</a></p>
<p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/solution/qu-yu-he-jian-suo-shu-zu-bu-ke-bian-by-leetcode/" target="_blank" rel="noopener">陈乐乐解</a></p>
<h3 id="extended">extended</h3>
<p><a href="https://stackoverflow.com/questions/936687/how-do-i-declare-a-2d-array-in-c-using-new" target="_blank" rel="noopener">How do I declare a 2d array in C++ using new?</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>2维dp</tag>
        <tag>插入1个虚拟0</tag>
        <tag>数组</tag>
        <tag>hash</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-1143-最公共子序列长</title>
    <url>/2019/11/03/leetcode%E9%A2%98%E8%A7%A3-1143-%E6%9C%80%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%95%BF/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/longest-common-subsequence/submissions/" target="_blank" rel="noopener">题目</a></h2>
<p>简单DP，只给出状态转移方程。</p>
<h4 id="状态转移方程">状态转移方程</h4>
<p><span class="math display">\[
dp[i][j] = 
\begin{cases}
&amp;   dp[i-1][j-1]+1, &amp; \text{if $text1[i]==text2[j]$} \\
&amp;   max(dp[i-1][j],\ dp[i][j-1]), &amp; otherwise \\
\end{cases}
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.size() + <span class="number">1</span>, n = text2.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>这里只求，<strong>最大公共子序列的长度</strong>，简单的2维DP即可实现</li>
<li>记住，这种在状态转移方程中存在<code>f[i] = f[i-1]</code>的递推式情况下，
<ul>
<li>将设置 <code>新数组长度 = 旧数组长度 + 1</code></li>
<li>从而可以减少在<code>base case</code>, <code>corner case</code>的语句，减少代码冗余程度。</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>2维dp</tag>
        <tag>最大公共子序列</tag>
        <tag>插入1个虚拟0</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-931-下降路径最小和</title>
    <url>/2019/11/02/leetcode%E9%A2%98%E8%A7%A3-931-%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/" target="_blank" rel="noopener">题目</a></h2>
<h2 id="my-way">My way</h2>
<h3 id="二维dp">1.二维DP</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.size();</span><br><span class="line">        <span class="keyword">int</span> n = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(A);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = A[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j+<span class="number">1</span>]) + A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j + <span class="number">1</span> == n)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]) + A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = min(min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]), dp[i<span class="number">-1</span>][j+<span class="number">1</span>]) + A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *min_element(dp[m<span class="number">-1</span>].begin(), dp[m<span class="number">-1</span>].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="一维dp">2.一维DP</h3>
<p>可以将二维DP压缩至一维DP处理。</p>
<h2 id="section"></h2>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>√</tag>
        <tag>2维dp</tag>
        <tag>2维DP-to-1维DP</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-714-买卖股票的最佳时机含手续费</title>
    <url>/2019/11/01/leetcode%E9%A2%98%E8%A7%A3-714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</url>
    <content><![CDATA[<h2 id="my-way"><del>My way</del></h2>
<p>一开始审题失误了，没有看到股票可以 <strong>多次买入，卖出</strong>。</p>
<p>所以想了个 <strong>只准单次买入，卖出的解法</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">mycomp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *max_element(a.begin(), a.end()) &lt; *max_element(b.begin(), b.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> n = prices.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;      </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>] + prices[j] - prices[j<span class="number">-1</span>] - fee;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> itv = max_element(dp.begin(), dp.end(), mycomp); <span class="comment">// find the vector </span></span><br><span class="line">                                                     <span class="comment">// with the max element</span></span><br><span class="line">        <span class="keyword">return</span> *max_element((*itv).begin(), (*itv).end()); <span class="comment">// finds the max element </span></span><br><span class="line">                                                        <span class="comment">// in the desired vector</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="官方解">官方解</h2>
<p>通过第<span class="math inline">\(i\)</span>天和<span class="math inline">\(i-1\)</span>天<span class="math inline">\(cash,\ hold\)</span>的递推关系，来得到最后最大收益。</p>
<p>*但是给我的感觉，这个思路，并不是很好捋清楚。</p>
<h4 id="状态定义">状态定义：</h4>
<p><span class="math display">\[
\begin{align*}
&amp; cash:\ 不持有股票时的最大利润 \\
&amp; hold:\ 持有股票时的最大利润\\
\end{align*}
\]</span></p>
<h4 id="状态转移方程">状态转移方程：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cash = Math.max(cash, hold + prices[i] - fee);	<span class="comment">// max(原来请况，假设第i天卖出股票)</span></span><br><span class="line">hold = Math.max(hold, cash - prices[i]);		<span class="comment">// max(原来情况，假设第i天买进股票)</span></span><br></pre></td></tr></table></figure>
<h4 id="base-case">Base case</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cash = <span class="number">0</span>;</span><br><span class="line">hold = -prices[<span class="number">0</span>]; <span class="comment">// 假设第0天买了股票</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>, hold = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            cash = Math.max(cash, hold + prices[i] - fee);</span><br><span class="line">            hold = Math.max(hold, cash - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="e.g.">e.g.</h4>
<p>$$ <span class="math display">\[\begin{align*}
&amp;输入: prices = [1, 3, 2, 8, 4, 9], fee = 2\\
&amp;输出: 8\\
&amp;解释: 能够达到的最大利润:  \\
&amp;在此处买入 prices[0] = 1\\
&amp;在此处卖出 prices[3] = 8\\
&amp;在此处买入 prices[4] = 4\\
&amp;在此处卖出 prices[5] = 9\\
&amp;总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. \\

\end{align*}\]</span> $$</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>prices</th>
<th>cash</th>
<th>hold</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>0</td>
<td>-1</td>
</tr>
<tr class="even">
<td>1</td>
<td>3</td>
<td>max(0, -1+3-2)=0</td>
<td>max(0, 0-3)=-3</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td>max(0, -1+2-2)=0</td>
<td>max(-1, 0-2)=-1</td>
</tr>
<tr class="even">
<td>3</td>
<td>8</td>
<td>max(0, -1+8-2)=5</td>
<td>max(-1, 5-8)=-1</td>
</tr>
<tr class="odd">
<td>4</td>
<td>4</td>
<td>max(5, -1+4-2)=5</td>
<td>max(-1, 5-4)=1</td>
</tr>
<tr class="even">
<td>5</td>
<td>9</td>
<td>max(5, 1+9-2)=8</td>
<td>max(1, 8-9)=-1</td>
</tr>
</tbody>
</table>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-shou-xu-fei-/" target="_blank" rel="noopener">官方解</a></p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-2/" target="_blank" rel="noopener">laluladong解</a></p>
<h3 id="extended">extended</h3>
<p><a href="https://stackoverflow.com/questions/36228231/find-the-max-value-in-vectorvectorint-without-for-loop" target="_blank" rel="noopener">Find the max value in vector&gt; without for loop</a></p>
<p><a href="https://www.tablesgenerator.com/markdown_tables" target="_blank" rel="noopener">markdown generator</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>贪心算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-647-回文子串</title>
    <url>/2019/11/01/leetcode%E9%A2%98%E8%A7%A3-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">题目</a></h2>
<h2 id="my-way"><del>My way</del></h2>
<h4 id="状态定义">状态定义：</h4>
<p><span class="math display">\[
\begin{align*}
&amp; s:\ 字符串s\\
&amp; i:\ 字符串s第i位\\
&amp; j:\ 字符串s第j位\\
&amp; s[i:j]:\ 字符串s第i位到第j位的子串, s[i,j]\\
&amp; dp[i][j]:\ dp数组在s[i,j]上是否为回文串的记录。
\end{align*}
\]</span></p>
<h4 id="base-case">Base case：</h4>
<p><span class="math display">\[
\begin{align*}
&amp;s[i][j] = 1, &amp;\text{if $i==j$}\ 
\end{align*}
\]</span></p>
<h4 id="状态转移方程">状态转移方程：</h4>
<p><span class="math display">\[
s[i-1][j+1] = 
\begin{cases}
&amp; 1,\ \text{if $s[i] == s[j]$}\\
&amp; 0,\ otherwise
\end{cases}
\]</span></p>
<h3 id="error">Error:</h3>
<p>在如何实现数组遍历上面，出现了问题。</p>
<p>套用了 <strong>glamour</strong>的逆向对角遍历思路：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.size();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m - i - <span class="number">1</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> row = j;</span><br><span class="line">                <span class="keyword">int</span> column = i + j;</span><br><span class="line">                <span class="keyword">bool</span> cur = s[row] == s[column];</span><br><span class="line">                <span class="keyword">if</span> (cur &amp;&amp; (i == <span class="number">1</span> || dp[row+<span class="number">1</span>][column<span class="number">-1</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[row][column] = <span class="literal">true</span>;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="glamour-way">Glamour way</h2>
<h3 id="dp-逆向对角遍历">1.DP + 逆向对角遍历</h3>
<h4 id="逆向对角遍历思路">逆向对角遍历思路：</h4>
<img src="/2019/11/01/leetcode题解-647-回文子串/11/01/leetcode题解-647-回文子串/dp1.png" title="pic1">
<p>上图中同一条直线上的值有前者依赖于后者的关系，因此我们应该以对角线方向遍历</p>
<img src="/2019/11/01/leetcode题解-647-回文子串/11/01/leetcode题解-647-回文子串/dp2.png" title="pic2">
<blockquote>
<p>但是本方法在發現一字符串不是回文串后，仍然對包含其的字符串進行回文判斷。</p>
<p>此方法包含了<strong>冗餘的判斷，因此還有優化的地方。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = s.length();</span><br><span class="line">       <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> len;</span><br><span class="line">       <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">       <span class="keyword">int</span> i;</span><br><span class="line">       <span class="keyword">int</span> j;</span><br><span class="line">       <span class="keyword">int</span> row, column;</span><br><span class="line">       <span class="keyword">boolean</span> current;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">           dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">           count++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt;= len - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">               row = j;</span><br><span class="line">               column = i + j;</span><br><span class="line">               current = s.charAt(row) == s.charAt(column);</span><br><span class="line">               <span class="keyword">if</span>(current &amp;&amp; (i == <span class="number">1</span> || dp[row + <span class="number">1</span>][column - <span class="number">1</span>]))&#123;</span><br><span class="line">                   dp[row][column] = <span class="keyword">true</span>;</span><br><span class="line">                   count++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="分治法-中心扩散法">2. 分治法 + 中心扩散法</h3>
<blockquote>
<p><strong>分治法</strong>，对以不同字符为中心的回文分而治之，同时又将回文的长度分为奇数和偶数，奇数的中心有一个，而偶数的中心有两个.</p>
<p>有一個規律：</p>
<ul>
<li>回文串左右兩邊同時去掉一個字符仍然是回文串；反之一個字符串不是回文串，</li>
<li>那麽他左右兩邊不論加上什麽字符都不可能是回文串.</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i;</span><br><span class="line">       <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">           count += countPalindrome(s, i, i);</span><br><span class="line">           count += countPalindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPalindrome</span> <span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left--) == s.charAt(right++))&#123;</span><br><span class="line">           count++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>C++实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.size();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt += countPalindrome(s, i, i);    <span class="comment">// even length of string</span></span><br><span class="line">            cnt += countPalindrome(s, i, i+<span class="number">1</span>);  <span class="comment">// old length of string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPalindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.size() &amp;&amp; s[l--] == s[r++])</span><br><span class="line">        &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/palindromic-substrings/solution/dong-tai-gui-hua-yun-xing-shi-jian-11mszhong-xin-k/" target="_blank" rel="noopener">glamour解法</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>数组对角遍历</tag>
        <tag>字符串</tag>
        <tag>中心扩散法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-712-两个字符串的最小ASCII删除和</title>
    <url>/2019/11/01/leetcode%E9%A2%98%E8%A7%A3-712-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8FASCII%E5%88%A0%E9%99%A4%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/" target="_blank" rel="noopener">题目</a></h2>
<h2 id="官方解">官方解</h2>
<h4 id="状态定义">状态定义：</h4>
<p><span class="math display">\[
\begin{align*}
&amp; i:\ \text{字符串}s1的第i位\\
&amp; j:\ \text{字符串}s2的第j位\\
&amp; s1[i:]:\ 第i位到末尾的子串\\
&amp; s2[j:]:\ 第j位到末尾的子串\\
&amp; dp[i][j]:\ 表示使字符串s1[i:],s2[j:]从第i位到末尾的子串相等，要删除的ASCII码值最小 
\end{align*}
\]</span></p>
<h4 id="状态转移方程">状态转移方程：</h4>
<p><span class="math display">\[
\begin{align*}
dp[i][j] = \begin{cases} &amp; min(dp[i+1][j] + s1.asciiAtPos(i), dp[i][j+1] + s2.asciiAtPos(j))\ &amp; \text{if $s1[i] != s2[j]$ }\\
&amp; df[i-1][j-1]\ &amp;\text{if $s1[i] = s2[j]$} \end{cases}
\end{align*}
\]</span></p>
<h4 id="base-case">Base case:</h4>
<p><span class="math display">\[
\begin{align*}
&amp;dp[i][j] = 0  &amp;\text{if $i == 0$ and $j == 0$} 
\end{align*}
\]</span></p>
<h4 id="corner-case">Corner case:</h4>
<p><span class="math display">\[
dp[i][j] = 
\begin{cases}
&amp; dp[i+1][j] + s1.asciiAtPos(i) &amp; \text{if $s[j:].size() == 0$, 即$j==s1.size()$}\\
&amp; dp[i][j+1] + s2.asciiAtPos(j) &amp; \text{if $s[i:].size() == 0$, 即$i==s1.size()$}\\
\end{cases}
\]</span></p>
<h4 id="c实现">C++实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(s1.size()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s2.size()+<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = s1.size(), n = s2.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][n] = dp[i+<span class="number">1</span>][n] + s1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[m][j] = dp[m][j+<span class="number">1</span>] + s2[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1[i] == s2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i+<span class="number">1</span>][j] + s1[i], dp[i][j+<span class="number">1</span>] + s2[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getStrAsciiSum</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="java实现">Java实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][s2.length()] = dp[i+<span class="number">1</span>][s2.length()] + s1.codePointAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = s2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            dp[s1.length()][j] = dp[s1.length()][j+<span class="number">1</span>] + s2.codePointAt(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = s2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j] + s1.codePointAt(i),</span><br><span class="line">                                        dp[i][j+<span class="number">1</span>] + s2.codePointAt(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>类似于 <a href="https://leetcode-cn.com/problems/longest-common-subsequence" target="_blank" rel="noopener">最长公共子序列</a> 的一道题。</li>
<li>在 二维DP数组初始化的时候，没有考虑到初始化大小为<span class="math inline">\((m+1)*(n+1)\)</span> .
<ul>
<li>对于<span class="math inline">\(dp[m][n] = 0\)</span>其实是一种 <strong>base case</strong>，</li>
<li>是考虑到第<span class="math inline">\(m\)</span>位字符到第<span class="math inline">\(m\)</span>位字符上的一个情况，即 空串情况。</li>
</ul></li>
</ul>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/solution/liang-ge-zi-fu-chuan-de-zui-xiao-asciishan-chu-he-/" target="_blank" rel="noopener">leetcode官方解</a></p>
<p><a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/solution/asciima-zui-da-de-zi-xu-lie-zui-chang-gong-tong-zi/" target="_blank" rel="noopener">Falcon解</a></p>
<h3 id="extended">Extended</h3>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string" target="_blank" rel="noopener">std::basic_string</a></p>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string/substr" target="_blank" rel="noopener">basic_string/substr</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>插入1个虚拟0</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-95-不同的二叉搜索树2</title>
    <url>/2019/10/31/leetcode%E9%A2%98%E8%A7%A3-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">题目</a></h2>
<h2 id="官方解">官方解</h2>
<p>简要改自官网解。</p>
<p>利用树的遍历，以递归方式实现不同二叉树的构造。</p>
<img src="/2019/10/31/leetcode题解-95-不同的二叉搜索树2/10/31/leetcode题解-95-不同的二叉搜索树2/tree.png" title="tree">
<p>我们从序列 <span class="math inline">\(1 ...n\)</span> 中取出数字 <span class="math inline">\(i\)</span>，作为当前树的树根。于是，剩余 <span class="math inline">\(i - 1\)</span> 个元素可用于左子树，<span class="math inline">\(n - i\)</span> 个元素用于右子树。 如 前文所述，这样会产生 <span class="math inline">\(G(i - 1)\)</span> 种左子树 和 <span class="math inline">\(G(n - i)\)</span> 种右子树，其中 <span class="math inline">\(G\)</span> 是卡特兰数。</p>
<p>现在，我们对序列 <span class="math inline">\(1 ... i - 1\)</span> 重复上述过程，以构建所有的左子树；然后对 <span class="math inline">\(i + 1 ... n\)</span> 重复，以构建所有的右子树。</p>
<p>这样，我们就有了树根 <span class="math inline">\(i\)</span> 和可能的左子树、右子树的列表。</p>
<p>最后一步，对两个列表循环，将左子树和右子树连接在根上。</p>
<p>C++实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// [start, end]</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generate_trees(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; all_trees;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            all_trees.push_back(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> all_trees;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pick up a root </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTrees = generate_trees(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTrees = generate_trees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> l : leftTrees)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> r : rightTrees)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function">TreeNode* <span class="title">curTree</span><span class="params">(i)</span></span>;</span><br><span class="line">                    curTree-&gt;left = l;</span><br><span class="line">                    curTree-&gt;right = r;</span><br><span class="line">                    all_trees.push_back(curTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> all_trees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> generate_trees(<span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Java实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> LinkedList&lt;TreeNode&gt; <span class="title">generate_trees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; all_trees = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">      all_trees.add(<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">return</span> all_trees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pick up a root</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">      <span class="comment">// all possible left subtrees if i is choosen to be a root</span></span><br><span class="line">      LinkedList&lt;TreeNode&gt; left_trees = generate_trees(start, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// all possible right subtrees if i is choosen to be a root</span></span><br><span class="line">      LinkedList&lt;TreeNode&gt; right_trees = generate_trees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// connect left and right trees to the root i</span></span><br><span class="line">      <span class="keyword">for</span> (TreeNode l : left_trees) &#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode r : right_trees) &#123;</span><br><span class="line">          TreeNode current_tree = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">          current_tree.left = l;</span><br><span class="line">          current_tree.right = r;</span><br><span class="line">          all_trees.add(current_tree);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> all_trees;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode/" target="_blank" rel="noopener">官方解</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>树的遍历</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-1227-风机座位分配概率</title>
    <url>/2019/10/31/leetcode%E9%A2%98%E8%A7%A3-1227-%E9%A3%8E%E6%9C%BA%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D%E6%A6%82%E7%8E%87/</url>
    <content><![CDATA[<h2 id="my-way"><del>My way</del></h2>
<p>习惯不是很好。。最开始试答案试出来结果的。</p>
<p><span class="math inline">\(1/n\)</span>, <span class="math inline">\(1/2\)</span>, 然后得到正确解。。</p>
<p>因为第一眼看上去就是组合数学题，就类似你买彩票，先买后买的顺序不影响概率。</p>
<h3 id="简单思路"><del>简单思路</del></h3>
<p>为什么试<span class="math inline">\(1/n\)</span>，以为要考虑的是<span class="math inline">\(n\)</span>个状态取1个。</p>
<p>后来发现应该是<span class="math inline">\(1/2\)</span>，感觉解释起来就有问题了。</p>
<h2 id="水氷leoooooowinterock-way">水氷/Leoooooo/winterock way</h2>
<p>简单递推dp的思路，在此略作修改。</p>
<h4 id="状态定义">状态定义：</h4>
<p><span class="math display">\[
\begin{align*}
&amp; i:\ 第i个入座的人 \\
&amp; n:\ 一共有n个座位 \\
&amp; f[i]:\ 第i个入座的人，坐到自己位置上的概率 \\
\end{align*}
\]</span></p>
<h4 id="状态转移方程">*状态转移方程：</h4>
<p><span class="math display">\[
\begin{align*}
f[i] = 1/n + (n-2)/n * f(n-1) 
\end{align*}
\]</span></p>
<h5 id="leoooooo给出的推导过程"><strong>Leoooooo</strong>给出的推导过程：</h5>
<p>$$ <span class="math display">\[\begin{alignat}{1}
f(n) = &amp; 1/n                      &amp; // \text{1st person picks his own seat, probability = 1/n} \\
    &amp;+ 1/n * 0                    &amp; // \text{1st person picks last one&#39;s seat, probability = 1/n} \\
    &amp;+ (n-2)/n *                  &amp; // \text{1st person picks one of seat from 2nd to (n-1)th, probability = (n-2)/n} \\
    &amp;( \\
        &amp;\ \ \ 1/(n-2) * f(n-1)         &amp; // \text{1st person pick 2nd&#39;s seat, 2nd person becomes the new &quot;careless&quot; person, and there are n-1 seats left. it becomes subproblem of n-1.}\\
        &amp;\ \ \ 1/(n-2) * f(n-2)         &amp; // \text{1st person pick 3rd&#39;s seat, 2nd person will pick his own seat, 3nd person becomes the new &quot;careless&quot; person, and there are n-2 seats left. it becomes subproblem of n-2.}\\
        &amp;\ \ \ ......\\
        &amp;\ \ \ 1/(n-2) * f(2)           &amp; // \text{1st person pick (n-1)th&#39;s seat, (n-1)th person becomes the new &quot;careless&quot; person, there are 2 seats left.}\\
    &amp;) \\ \\
    
=&gt; &amp; f(n) = 1/n                                                      &amp; \text{\{when $n &lt;= 2$\}} \\
   &amp; f(n) = 1/n + 1/n * ( f(n-1) + f(n-2) + f(n-3) + ... + f(2) )    &amp; \text{\{when $n &gt; 2$\}} \\
\end{alignat}\]</span> $$</p>
<p>根据<strong>winterock</strong>给出的解释，简单来说:</p>
<p>按照条件概率，分成3种情况，在此以1号为例子：</p>
<ol type="1">
<li><span class="math inline">\(1/n\)</span>, 第1个人，选择了自己的座位，则对<span class="math inline">\(2,...,n\)</span>位置空出来了，他们必然可以做到自己的位置，即<span class="math inline">\(n\)</span>可以坐到自己的位置；</li>
<li><span class="math inline">\(1/n*0\)</span>, 第1个人坐到<span class="math inline">\(n\)</span>位置上，则<span class="math inline">\(n\)</span>必然坐不到自己位置上；</li>
<li><span class="math inline">\((n-2)/n * (...)\)</span> ，这个情况，简单来说就是，如果<span class="math inline">\(i\)</span>坐到<span class="math inline">\(k\)</span>位置上，则<span class="math inline">\((i,\ k)\)</span>里的人都能坐到自己位置上来，因为每个人看到自己位置空的时候必然坐上来。具体举例不展开了，很容易想明白。</li>
</ol>
<h5 id="证明结论为fn12">证明结论为<span class="math inline">\(f(n)=1/2\)</span>:</h5>
<p><span class="math display">\[
\begin{align*}
&amp; \text{When}\ n &lt;= 2 \\
&amp; \ f(n) = 1/n \\
&amp; \text{When}\ n &gt; 2\ \text{(all these 5 formulas are correct, we can choose any one of them)} \\
 &amp; \ f(n) = 1/n + 1/n * ( f(n-1) + f(n-2) + f(n-3) + ... + f(2) )  \\
 &amp; \ f(n+1) = f(n)\\
 &amp; \ f(n) = 1/n + (n-2)/n * f(n)   \\
 &amp; \ f(n) = 1/n + (n-2)/n * f(n-1) \ \text{is correct too since} f(n) == f(n-1) \\
 &amp; \ f(n) = 1/2 \\
 \end{align*}
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> f[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            f[i] = (<span class="number">1</span> + (i - <span class="number">2</span>) * f[i - <span class="number">1</span>]) / (<span class="keyword">double</span>)i;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>怎么<strong>求出合理的递推式用于状态转移方程</strong>。
<ul>
<li>这里是用了 <strong>条件概率</strong>来入手。</li>
<li>然后通过思考发现了这样一个规律:
<ul>
<li>如果<span class="math inline">\(i\)</span>坐到<span class="math inline">\(k\)</span>位置上，则<span class="math inline">\((i,\ k)\)</span>里的人都能坐到自己位置上来，因为每个人看到自己位置空的时候必然坐上来。</li>
</ul></li>
</ul></li>
<li>有没有从组合数学的思路的解法呢？</li>
</ul>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/airplane-seat-assignment-probability/solution/han-you-zhuang-tai-zhuan-yi-fang-cheng-tui-chu-de-/" target="_blank" rel="noopener">水氷 leetcode 解</a></p>
<p><a href="https://leetcode.com/problems/airplane-seat-assignment-probability/discuss/414864/True-formula-and-explanations-for-all-other-formulas" target="_blank" rel="noopener">Leoooooo 状态转移方程详解</a></p>
<p><a href="https://leetcode.com/problems/airplane-seat-assignment-probability/discuss/411905/It&#39;s-not-obvious-to-me-at-all.-Foolproof-explanation-here!!!-And-proof-for-why-it&#39;s-12" target="_blank" rel="noopener">winterock 状态转移方程详解</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>数学题</tag>
        <tag>插入1个虚拟0</tag>
        <tag>动态规划</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-120-三角形最小路径</title>
    <url>/2019/10/31/leetcode%E9%A2%98%E8%A7%A3-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/triangle/submissions/" target="_blank" rel="noopener">题目</a></h2>
<h2 id="my-way">My way</h2>
<p>很简单的二维dp思路，每一层的元素依赖于上一层同列元素和上一层前一列元素。</p>
<h3 id="二维dp">二维DP</h3>
<h4 id="状态定义">状态定义：</h4>
<p><span class="math display">\[
\begin{align*}
&amp; i:\ 行号 \\
&amp; j:\ 列号 \\
&amp; triangle[i][j]:\ 原始三角形上的i行,\ j列的数字 \\
&amp; dp[i][j]:\ dp数组的i行,\ j列上的数字 \\
&amp; 0 &lt;= i == j &lt;= n, n为行数
\end{align*}
\]</span></p>
<h4 id="状态转移方程">状态转移方程:</h4>
<p><span class="math display">\[
dp[i][j] = triangle[i][j] + min\{dp[i-1][j-1],\ dp[i-1][j] \}
\]</span></p>
<h4 id="base-case">Base case:</h4>
<p><span class="math display">\[
dp[i][j] = triangle[i][j],\ \text{if $i == 0$ and $j == 0$}
\]</span></p>
<h4 id="corner-case">Corner case:</h4>
<p><span class="math display">\[
dp[i][j] = triangle[i][j] + dp[i-1][j],\ \text{if $j == 0$} \\
dp[i][j] = triangle[i][j] + dp[i-1][j-1],\ \text{if $i == j$}
\]</span></p>
<h5 id="c实现">C++实现</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(triangle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; triangle.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangle[i].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = triangle[i][j] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = triangle[i][j] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = triangle[i][j] + min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *min_element(dp[triangle.size()<span class="number">-1</span>].begin(), dp[triangle.size()<span class="number">-1</span>].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="一维dp">一维DP</h3>
<p>如何仅使用<span class="math inline">\(O(n)\)</span>大小的额外空间呢？</p>
<p>因为每一行的状态仅依赖于上一行的状态，故可将二维DP to 一维DP.</p>
<p>对空间复杂度进行优化。</p>
<h4 id="状态定义-1">状态定义：</h4>
<p><span class="math display">\[
\begin{align*}
&amp; i:\ 行号 \\
&amp; j:\ 列号 \\
&amp; triangle[i][j]:\ 原始三角形上的i行,\ j列的数字 \\
&amp; dp[k]:\ dp数组的第k个数字 \\
&amp; 0 &lt;= j &lt;= i &lt;= k == n, n为行数 \\
\end{align*}
\]</span></p>
<h4 id="状态转移方程-1">状态转移方程:</h4>
<p><span class="math display">\[
dp[j] = triangle[i][j] + min\{dp[j-1], dp[j]\}
\]</span></p>
<h4 id="base-case-1">Base case:</h4>
<p><span class="math display">\[
dp[j] = triangle[i][j],\ \text{if $i == 0$ and $j == 0$}
\]</span></p>
<h4 id="corner-case-1">Corner case:</h4>
<p><span class="math display">\[
dp[j] = triangle[i][j] + dp[j],\ \text{if $j == 0$} \\
dp[j] = triangle[i][j] + dp[j-1],\ \text{if $i == j$}
\]</span></p>
<h5 id="c实现-1">C++实现</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(triangle.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= triangle.size() - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = triangle[i].size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = triangle[i][j] + dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = triangle[i][j] + dp[j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = triangle[i][j] + min(dp[j<span class="number">-1</span>], dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *min_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="elon-way">Elon way</h2>
<p>关键能有这个思路上的转变：</p>
<p><strong>自顶向下最短距离</strong> &lt;=&gt; <strong>自底向上最短距离</strong></p>
<h3 id="自顶向下-记忆化搜索">自顶向下, 记忆化搜索</h3>
<ul>
<li>思路类似上面 <strong>二维DP</strong>。</li>
<li>还利用了<strong>树的遍历</strong>思维解决问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    Integer[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        row = triangle.size();</span><br><span class="line">        memo = <span class="keyword">new</span> Integer[row][row];</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,<span class="number">0</span>, triangle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">int</span> c, List&lt;List&lt;Integer&gt;&gt; triangle)</span></span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println("helper: level="+ level+ " c=" + c);</span></span><br><span class="line">        <span class="keyword">if</span> (memo[level][c]!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[level][c];</span><br><span class="line">        <span class="keyword">if</span> (level==row-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[level][c] = triangle.get(level).get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = helper(level+<span class="number">1</span>, c, triangle);</span><br><span class="line">        <span class="keyword">int</span> right = helper(level+<span class="number">1</span>, c+<span class="number">1</span>, triangle);</span><br><span class="line">        <span class="keyword">return</span> memo[level][c] = Math.min(left, right) + triangle.get(level).get(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自底向上-dp">自底向上, DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[] minlen = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = row-<span class="number">1</span>;level&gt;=<span class="number">0</span>;level--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=level;i++)&#123;   <span class="comment">//第i行有i+1个数字</span></span><br><span class="line">            minlen[i] = Math.min(minlen[i], minlen[i+<span class="number">1</span>]) + triangle.get(level).get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minlen[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>这里的<strong>自顶向下</strong>，<strong>自底向上</strong> 感觉就是我之前所理解的<strong>二维DP</strong>。不过我是采用非递归方式实现的，而这里是递归方式实现的。</li>
<li>*思考题目后，思路上的转变:
<ul>
<li><strong>自顶向下最短距离</strong> &lt;=&gt; <strong>自底向上最短距离</strong></li>
</ul></li>
<li>以及多多尝试 <strong>递归方式实现此类DP</strong>。</li>
</ul>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/triangle/solution/di-gui-ji-yi-hua-sou-suo-zai-dao-dp-by-crsm/" target="_blank" rel="noopener">Elon leetcode解法</a></p>
<h3 id="extended">extended</h3>
<p><a href="https://stackoverflow.com/questions/13015932/how-to-find-minimum-value-from-vector" target="_blank" rel="noopener">How to find minimum value from vector? [closed]</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>插入1个虚拟0</tag>
        <tag>动态规划</tag>
        <tag>2维DP</tag>
        <tag>2维DP-to-1维DP</tag>
        <tag>自顶向下DP</tag>
        <tag>自底向上DP</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-64-最小路径和</title>
    <url>/2019/10/30/leetcode%E9%A2%98%E8%A7%A3-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h2 id="my-way">My way</h2>
<p>第一眼感觉就是一个当前表格状态依赖于左边表格状态和上边表格状态的二维DP题。</p>
<h3 id="状态定义">状态定义：</h3>
<p><span class="math display">\[
\begin{align*}
&amp; i:\ 表示第i行 \\
&amp; j:\ 表示第j列 \\
&amp; [i,\ j]:\ 表示第i行，j列上的数字\\
&amp; grid[i][j]:\ 表示原始网格上第i行，j列上的数字\\
&amp; dp[i][j]:\ 表示经过某些步之后，达到第i行，j列的时候，这个数字和的最小值\\
\end{align*}
\]</span></p>
<h3 id="状态转移方程">状态转移方程：</h3>
<p><span class="math display">\[
\begin{align*}
&amp; dp[i][j] = grid[i][j] + max(df[i-1][j],\ df[i][j-1])
\end{align*}
\]</span></p>
<h3 id="base-case">Base Case:</h3>
<p><span class="math display">\[
\begin{align*}
&amp; df[0][0] = grid[0][0]
\end{align*}
\]</span></p>
<h3 id="corner-case">Corner Case:</h3>
<p><span class="math display">\[
\begin{align*}
&amp; df[i][j] = grid[i][j] + df[i, j-1],\ \text{if $j-1$ == 0} \\
&amp; df[i][j] = grid[i][j] + df[i-1, j],\ \text{if $j-1$ == 0}
\end{align*}
\]</span></p>
<p>C++实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvi(grid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vvi[i][j] = grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vvi[i][j] = grid[i][j] + vvi[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vvi[i][j] = grid[i][j] + vvi[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    vvi[i][j] = grid[i][j] + min(vvi[i<span class="number">-1</span>][j], vvi[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vvi[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="可以试试斜着遍历">可以试试斜着遍历</h3>
<p>!对于<span class="math inline">\(m*n\ array\)</span>来说，不太好实现。</p>
<p>有一个思路就是补成正方形之后，然后以对角线的方式倾斜遍历数组。</p>
<h2 id="官方解">官方解</h2>
<h3 id="暴力">1.暴力</h3>
<p>不做解释了。</p>
<h3 id="二维dp">2.二维DP</h3>
<p>类似我的思路。</p>
<h3 id="一维dp">3.一维DP</h3>
<p>因为这里每个阶段的状态仅依赖上一个表格状态和左一个表格的状态，</p>
<p>再加上我们利用按行遍历的方式，依次求出每一行对应的<span class="math inline">\(dp[i][j]\)</span>，然后得到结果。</p>
<h4 id="官方java解">官方Java解</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid[<span class="number">0</span>].length];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = grid.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = grid[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">               <span class="keyword">if</span>(i == grid.length - <span class="number">1</span> &amp;&amp; j != grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">                   dp[j] = grid[i][j] +  dp[j + <span class="number">1</span>];</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(j == grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                   dp[j] = grid[i][j] + dp[j];</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(j != grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                   dp[j] = grid[i][j] + Math.min(dp[j], dp[j + <span class="number">1</span>]);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   dp[j] = grid[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重上到下c实现">重上到下，C++实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(grid[<span class="number">0</span>].size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = grid[i][j] + dp[j<span class="number">-1</span>]; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = grid[i][j] + dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = grid[i][j] + min(dp[j], dp[j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[grid[<span class="number">0</span>].size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-by-leetcode/" target="_blank" rel="noopener">leetcode 官方解</a></p>
<h3 id="extended">extended</h3>
<p><a href="https://stackoverflow.com/questions/21346343/traverse-an-array-diagonally" target="_blank" rel="noopener">Traverse an array diagonally</a></p>
<p><a href="https://stackoverflow.com/questions/2862802/traverse-2d-array-matrix-diagonally" target="_blank" rel="noopener">Traverse 2D m*n Array (Matrix) Diagonally</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>√</tag>
        <tag>动态规划</tag>
        <tag>2维DP</tag>
        <tag>2维DP-to-1维DP</tag>
        <tag>数组对角遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-96-不同的二叉搜索树</title>
    <url>/2019/10/29/leetcode%E9%A2%98%E8%A7%A3-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">题目</a></h2>
<h2 id="官方解">官方解</h2>
<p>思考题目中，输入为<span class="math inline">\(n\)</span>，表示由<span class="math inline">\(n\)</span>个节点来构成二叉搜索树。</p>
<p>可以考虑到的是，每个子树的根节点不同，则为一个新的子树结构(包括 <strong>叶节点</strong>)。</p>
<p>所以要考虑到如何从 <strong>根节点</strong> 入手，以及对于当前根节点的左右子树的递推的方式解决。</p>
<h3 id="动态规划">动态规划</h3>
<h4 id="状态定义">状态定义：</h4>
<p>考虑到涉及到 <strong>输入节点个数<span class="math inline">\(n\)</span></strong> 和所取 <strong>根节点<span class="math inline">\(i\)</span></strong>，可以定义如下： <span class="math display">\[
\begin{align*}
&amp; F(i,\ n) = \text{以$i$为根节点，长度为$n$的二叉搜索树的树的个数} \\
&amp; G(n) = \text{长度为$n$的二叉搜索树的树的个数} \\
\end{align*}
\]</span> 可以得到如下</p>
<h4 id="状态转移方程递推公式">状态转移方程/递推公式：</h4>
<p><span class="math display">\[
\begin{align*}
&amp; G(n) = \sum_{i=1}^{n}F(i,\ n) \\
&amp; F(i,\ n) = G(i-1) * G(n-i),\ 因为同一长度n的二叉搜索树个数一样 \\
&amp; so\ we\ get: \\
&amp; G(n) = \sum_{i=1}^{n}\{G(i-1) * G(n-i)\} \\
&amp; 0 &lt;= i &lt;= n
\end{align*}
\]</span></p>
<h4 id="base-case">Base case:</h4>
<p><span class="math display">\[
\begin{align*}
&amp; G(0) = 0\\
&amp; G(1) = 1\\
&amp; 0 &lt;= i &lt;= n
\end{align*}
\]</span></p>
<p><span class="math inline">\(G[0] = 0\)</span>，</p>
<ul>
<li>一方面说明 <strong>空树也是一种二叉搜索树</strong>。</li>
<li>一方面为了 <strong>构造的递推式中涉及到乘法，要保证乘积因子不为0才可</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] G = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">        G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G[n];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数学way">数学way</h3>
<h4 id="数学归纳法">数学归纳法：</h4>
<p>可以归纳得出：<span class="math inline">\(G(n)\)</span>的值被称为Catalan数<span class="math inline">\(C_n\)</span>。</p>
<p>定义如下： <span class="math display">\[
\begin{align*}
&amp; C_0 = 1, \\
&amp; C_{n+1} = \frac{2(2n+1)}{n+2} C_n
\end{align*}
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: we should use long here instead of int, otherwise overflow</span></span><br><span class="line">    <span class="keyword">long</span> C = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      C = C * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) C;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>要考虑到二叉搜索树的基本定义之一
<ul>
<li>左子树上的值 &lt; 根节点 &lt; 右子树上的值</li>
<li><strong>空树也是二叉搜索树的一种</strong></li>
</ul></li>
<li>*如何摸索出状态定义的中的2个状态：<span class="math inline">\(n\)</span>, <span class="math inline">\(i\)</span>.
<ul>
<li>题目已给条件中的状态有: <strong>构成二叉搜索树的序列长度</strong><span class="math inline">\(n\)</span>。</li>
<li>考虑到子树的根节点不同，影响到二叉搜索树的结构，所以推测出: <strong><span class="math inline">\(i\)</span>是<span class="math inline">\([0,\ n]\)</span>中取的一个值作为根节点</strong>。</li>
</ul></li>
<li>*<strong>Catalan数</strong>，一个组合数学问题常常涉及到的。</li>
</ul>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/" target="_blank" rel="noopener">leetcode官方解</a></p>
<p><a href="%5Bhttps://zh.wikipedia.org/zh-hk/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0%5D(https://zh.wikipedia.org/zh-hk/卡塔兰数)">wikipidia-cn: catalan number</a></p>
<p><a href="https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0" target="_blank" rel="noopener">baidu baike: 卡特兰数</a></p>
<h3 id="extended">extended</h3>
<p><a href="https://en.cppreference.com/w/cpp/language/memory_model" target="_blank" rel="noopener">C++ memory model</a></p>
<p><a href="https://en.cppreference.com/w/c/language/memory_model" target="_blank" rel="noopener">C memory model</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>插入1个虚拟0</tag>
        <tag>动态规划</tag>
        <tag>Catalan数</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解-1221-分割平衡字符串</title>
    <url>/2019/10/28/leetcode%E9%A2%98%E8%A7%A3-1221-%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/submissions/" target="_blank" rel="noopener">题目</a></h2>
<p>虽然打的是 <strong>贪心算法</strong> 的tag，但是我感觉实际上是括号匹配的简单变种。</p>
<h2 id="解法">解法</h2>
<h3 id="括号匹配栈的做法">括号匹配/栈的做法</h3>
<p>考虑L, R分别对应左右两个括号。</p>
<p>利用stack的<code>push</code>, <code>pop</code>和括号匹配的基本思路来完成。</p>
<ol type="1">
<li>栈为空，<code>push</code>当前元素。</li>
<li><code>top</code>元素 等于 当前元素，<code>push</code>当前元素，否则<code>pop</code> <code>top</code>元素。</li>
<li>栈为空，平衡次数+1。</li>
</ol>
<h4 id="ps-注意思路实现是带有先后顺序的">PS: 注意思路实现是带有先后顺序的。</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; sc;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sc.empty() || c == sc.top())</span><br><span class="line">            &#123;</span><br><span class="line">                sc.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sc.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sc.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="利用数字计数代替括号匹配做法">利用数字计数代替括号匹配做法</h3>
<p>因为这里不同于括号匹配需要是一个<code>&lt;&gt;</code>的匹配状态，可以是<code>LR</code>, <code>RL</code>, <code>LLRR</code>, <code>RRLL</code>，</p>
<p>也就是说可以看成一个<strong>简单版本的括号匹配</strong>过程，</p>
<p>因为不需要要求<code>L</code>, <code>R</code>之间的先后关系，所以可以通过 <strong>数字计数</strong> 取代掉 <strong>栈括号匹配</strong> 的过程。</p>
<ol type="1">
<li>若当前元素为<code>L</code>, 计数<code>++num</code>；为<code>R</code>, 计数<code>--num</code>;</li>
<li>若<code>num == 0</code>, 则平衡次数+1。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it &lt; s.end(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it == <span class="string">'L'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --num;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>这题提及的&quot;<strong>尽可能多的平衡字符串分割</strong>“ + 实例，说明了这里的字符串分割是不存在前后分割出的字符串结果有交集的。
<ul>
<li>可以思考到，正常的从头到尾的一次遍历即可。</li>
</ul></li>
<li>提及的” <strong>‘L’和'R'字符的数量是相同的</strong> &quot;, 并没有提及到 <strong>L</strong>和<strong>R</strong>要有前后顺序的关系
<ul>
<li>可以思考到，利用 <strong>数字计数法</strong> 代替 <strong>括号匹配法</strong>。</li>
</ul></li>
</ul>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/solution/java-tan-xin-suan-fa-by-nan-lin/" target="_blank" rel="noopener">Karua leetcode 题解</a></p>
<p><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/solution/java-ji-yu-zhan-shi-xian-by-amanehayashi/" target="_blank" rel="noopener">amanehayashi leetcode 题解</a></p>
<h3 id="extended">Extended</h3>
<p><a href="https://en.cppreference.com/w/cpp/container/stack" target="_blank" rel="noopener">std::stack</a></p>
<p><a href="https://en.cppreference.com/w/cpp/header/stack" target="_blank" rel="noopener">STL header stack</a></p>
<p><a href="https://en.cppreference.com/w/cpp/iterator" target="_blank" rel="noopener">iterator library</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>栈</tag>
        <tag>贪心算法</tag>
        <tag>线性表</tag>
        <tag>括号匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解: 877.石子游戏</title>
    <url>/2019/10/27/leetcode%E9%A2%98%E8%A7%A3-877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/stone-game/" target="_blank" rel="noopener">题目</a></h2>
<h2 id="官方解">官方解</h2>
<h3 id="数学way">数学way</h3>
<p>直接从官方解处摘抄过来，很有意思的数学归纳证明思想。如下：</p>
<p>显然，亚历克斯总是赢得 2 堆时的游戏。 通过一些努力，我们可以获知她总是赢得 4 堆时的游戏。</p>
<p>如果亚历克斯最初获得第一堆，她总是可以拿第三堆。 如果她最初取到第四堆，她总是可以取第二堆。第一 + 第三，第二 + 第四 中的至少一组是更大的，所以她总能获胜。</p>
<p>我们可以将这个想法扩展到 N 堆的情况下。设第一、第三、第五、第七桩是白色的，第二、第四、第六、第八桩是黑色的。 亚历克斯总是可以拿到所有白色桩或所有黑色桩，其中一种颜色具有的石头数量必定大于另一种颜色的。</p>
<p>因此，亚历克斯总能赢得比赛。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="综评最高解">综评最高解</h2>
<p>在dp解释上强于官方解，简要摘取部分过程，详细见reference处。</p>
<p>对于<span class="math inline">\(piles=[3, 9, 1, 2]\)</span>,</p>
<img src="/2019/10/27/leetcode题解-877-石子游戏/10/27/leetcode题解-877-石子游戏/dp_table_1.png" title="dp_table">
<h4 id="定义状态">定义<strong>状态</strong>：</h4>
<p><span class="math display">\[
dp[i][j].fir\ or\ dp[i][j].sec\\
其中：\\
0 &lt;= i &lt; piles.length, i相当于石子堆最左堆\\
i &lt;= j &lt; piles.length, j相当于石子堆最右堆
\]</span> 其中， <span class="math display">\[
dp[i][j].fir表示，对于piles[i...j]这部分石子，先手能获得的最高分数 \\
dp[i][j].sec表示，对于piles[i...j]这部分石子，后手能获得的最高分数
\]</span></p>
<h4 id="状态转移方程为"><strong>状态转移方程</strong>为：</h4>
<p><span class="math display">\[
dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec) \\
\]</span></p>
<p>$$ <span class="math display">\[\begin{align*}
&amp; if 先手选择左边:
    dp[i][j].sec = dp[i+1][j].fir \\
&amp; if 先手选择右边:
    dp[i][j].sec = dp[i][j-1].fir \\

&amp; 解释：\\

&amp; 我作为后手，要等先手先选择，有两种情况： \\
&amp; 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j] \\
&amp; 此时轮到我，我变成了先手；\\
&amp; 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1] \\ 
&amp; 此时轮到我，我变成了先手。\\
\end{align*}\]</span> $$</p>
<h4 id="base-case">base case</h4>
<p><span class="math display">\[
\begin{align*}
&amp; dp[i][j].fir = piles[i] \\
&amp; dp[i][j].sec = 0 \\
&amp; 其中 0 &lt;= i == j &lt; n \\
&amp; 解释：i 和 j 相等就是说面前只有一堆石头 piles[i] \\
&amp; 那么显然先手的得分为 piles[i] \\
&amp; 后手没有石头拿了，得分为 0 \\
\end{align*}
\]</span></p>
<img src="/2019/10/27/leetcode题解-877-石子游戏/10/27/leetcode题解-877-石子游戏/dp_table_2.png" title="dp_table">
<p>这里需要注意一点，我们发现 <span class="math inline">\(base\ case\)</span>是斜着的，而且我们推算 <code>dp[i][j]</code> 时需要用到 <code>dp[i+1][j]</code> 和 <code>dp[i][j-1]</code>：</p>
<img src="/2019/10/27/leetcode题解-877-石子游戏/10/27/leetcode题解-877-石子游戏/dp_table_3.png" title="dp_table">
<p>所以说算法不能简单的一行一行遍历 <code>dp</code> 数组，<strong>而要斜着遍历数组</strong>：</p>
<img src="/2019/10/27/leetcode题解-877-石子游戏/10/27/leetcode题解-877-石子游戏/dp_table_4.png" title="dp_table">
<h4 id="实现">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize dp array</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;(n, make_pair(<span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fill with base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i].first = piles[i];</span><br><span class="line">            dp[i][i].second = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// traverse array in a diagonal way</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; ++l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - l; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + l - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 先手选择最左边或者最右边的分数</span></span><br><span class="line">                <span class="keyword">int</span> left = piles[i] + dp[i+<span class="number">1</span>][j].second;</span><br><span class="line">                <span class="keyword">int</span> right = piles[j] + dp[i][j<span class="number">-1</span>].second;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 套用状态转移方程</span></span><br><span class="line">                <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j].first = left;</span><br><span class="line">                    dp[i][j].second = dp[i+<span class="number">1</span>][j].first;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j].first = right;</span><br><span class="line">                    dp[i][j].second = dp[i][j<span class="number">-1</span>].first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; res(dp[<span class="number">0</span>][n<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.first - res.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>综评Java实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回游戏最后先手和后手的得分之差 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoneGame</span><span class="params">(<span class="keyword">int</span>[] piles)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = piles.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">    Pair[][] dp = <span class="keyword">new</span> Pair[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++)</span><br><span class="line">            dp[i][j] = <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 填入 base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i].fir = piles[i];</span><br><span class="line">        dp[i][i].sec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 斜着遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - l; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = l + i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 先手选择最左边或最右边的分数</span></span><br><span class="line">            <span class="keyword">int</span> left = piles[i] + dp[i+<span class="number">1</span>][j].sec;</span><br><span class="line">            <span class="keyword">int</span> right = piles[j] + dp[i][j-<span class="number">1</span>].sec;</span><br><span class="line">            <span class="comment">// 套用状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                dp[i][j].fir = left;</span><br><span class="line">                dp[i][j].sec = dp[i+<span class="number">1</span>][j].fir;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j].fir = right;</span><br><span class="line">                dp[i][j].sec = dp[i][j-<span class="number">1</span>].fir;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Pair res = dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res.fir - res.sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><p>二维DP，也是递推问题，但是给人的没有一维DP那么好处理。</p>
<ul>
<li><strong>状态定义</strong>，一般涉及到2个状态<span class="math inline">\(i,\ j\)</span>。可以用表格法表示，有点类似0-1背包问题。</li>
<li><strong>状态转移方程</strong>，一般涉及到上一状态的2个状态。</li>
<li><strong>base case</strong>, 我的理解是一般类似于 <strong>corner case</strong>的存在，是一个需要考虑到的初始条件。</li>
</ul></li>
<li><p><strong>斜着遍历数组</strong>，这个在实现的时候，也不是一件非常容易的事情。</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// traverse array in a diagonal way</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; ++l)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - l; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">int</span> j = i + l - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
若<span class="math inline">\(n = 4\)</span>, 则依次遍历： <span class="math display">\[
\begin{align*}
&amp; [0,\ 1],\ [1,\ 2], [2,\ 3], [3,\ 4] \\ 
&amp; [0,\ 2],\ [1,\ 3], [2,\ 4] \\
&amp; [0,\ 3],\ [1,\ 4] \\
&amp; [0,\ 4] \\
\end{align*}
\]</span></li>
</ul></li>
</ul>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/stone-game/solution/jie-jue-bo-yi-wen-ti-de-dong-tai-gui-hua-tong-yong/" target="_blank" rel="noopener">labuladong: leetcode解</a></p>
<p><a href="https://leetcode-cn.com/problems/stone-game/solution/shi-zi-you-xi-by-leetcode/" target="_blank" rel="noopener">leetcode 官方解</a></p>
<h3 id="extended">extended</h3>
<p><a href="https://en.cppreference.com/w/cpp/utility/pair" target="_blank" rel="noopener">std::pair</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/vector" target="_blank" rel="noopener">std::vector</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>二维dp</tag>
        <tag>博弈问题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解: 1025.除数博弈</title>
    <url>/2019/10/24/leetcode%E9%A2%98%E8%A7%A3-1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/divisor-game/" target="_blank" rel="noopener">题目</a></h2>
<h2 id="my-way">My way:</h2>
<p>这题靠归纳推理，首先很明显就能看出来偶数的时候Alice赢了；</p>
<p>然后多举了几个例子就发现奇数的时候Bob赢了。</p>
<p>就直接一个条件语句，结束。</p>
<p>但是尝试套dp的做法的时候，没捋清楚，看了综评最高的，基本懂了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(N &amp; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="综评最高解">综评最高解</h2>
<h3 id="归纳法">1.归纳法：</h3>
<p>基本思路：</p>
<ul>
<li><p>最终结果应该是占到 2 的赢，占到 1 的输；</p></li>
<li><p>若当前为奇数，奇数的约数只能是奇数或者 1，因此下一个一定是偶数；</p></li>
<li><p>若当前为偶数， 偶数的约数可以是奇数可以是偶数也可以是 1，因此直接减 1，则下一个是奇数；</p></li>
</ul>
<p>因此，<strong>奇则输，偶则赢</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divisorGame</span><span class="params">(self, N: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> N%<span class="number">2</span>==<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="dp">2.DP:</h3>
<ul>
<li>定义状态
<ul>
<li><span class="math inline">\(i\)</span>: 数字<span class="math inline">\(N\)</span>为<span class="math inline">\(i\)</span>时；</li>
<li><span class="math inline">\(f[i]\)</span>: 数字<span class="math inline">\(N\)</span>为<span class="math inline">\(i\)</span>时，Alice的胜负状况，<code>true</code>为胜，<code>false</code>为负。</li>
</ul></li>
<li>定义状态转移方程：</li>
</ul>
<p><span class="math display">\[
f[i] = \begin{cases} 
true, &amp; \text{if}\ f[i-j] == false,\ \text{if}\ i\ \%\ j == 0\ \\
      &amp; and\ j\ is\ unsigned\ integer\ which \in (0, N) \  \\
false, &amp; \text{otherwise}
\end{cases}
\]</span></p>
<h4 id="实现">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vi(N+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vi[i-j] == <span class="literal">false</span> &amp;&amp; i % j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vi[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>综评解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divisorGame</span><span class="params">(self, N: int)</span> -&gt; bool:</span></span><br><span class="line">        target = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">        target[<span class="number">1</span>] = <span class="number">0</span> <span class="comment">#若爱丽丝抽到1，则爱丽丝输</span></span><br><span class="line">        <span class="keyword">if</span> N&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        </span><br><span class="line">            target[<span class="number">2</span>] = <span class="number">1</span> <span class="comment">#若爱丽丝抽到2，则爱丽丝赢</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,N+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i//<span class="number">2</span>):</span><br><span class="line">                    <span class="comment"># 若j是i的余数且target[i-j]为假（0）的话，则代表当前为真（1）</span></span><br><span class="line">                    <span class="keyword">if</span> i%j==<span class="number">0</span> <span class="keyword">and</span> target[i-j]==<span class="number">0</span>:</span><br><span class="line">                        target[i] = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> target[N]==<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>初等数学review:
<ul>
<li>奇数的因数： {奇数}</li>
<li>偶数的因数： {偶数}</li>
<li>奇数的最大公因数 = 奇数</li>
</ul></li>
<li>目前做到的dp还是简单递推问题，可以简单套换成：
<ul>
<li>状态<span class="math inline">\(i\)</span>就是数字为<span class="math inline">\(i\)</span>的时候</li>
<li><span class="math inline">\(f[i]\)</span>就是数字为<span class="math inline">\(i\)</span>时候，结果为<span class="math inline">\(f[i]\)</span></li>
</ul></li>
</ul>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/divisor-game/solution/python3gui-na-fa-by-pandawakaka/" target="_blank" rel="noopener">pandawakaka 给出的解</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>数学题</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解: 338.比特位计数</title>
    <url>/2019/10/23/leetcode%E9%A2%98%E8%A7%A3-338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">题目</a></h2>
<h2 id="my-way">My way:</h2>
<p>这题tag是dp，按着dp的思路写出了 <strong>状态</strong>， <strong>状态转移方程</strong>包括 <em>边界条件</em>， <em>常规情况</em>。</p>
<p>大致思路如下：</p>
<ul>
<li><p>定义状态：</p>
<ul>
<li><span class="math inline">\(i\)</span>: 数字为<span class="math inline">\(i\)</span>时；</li>
<li><span class="math inline">\(f[i]\)</span>: 数字为i时，<span class="math inline">\(f[i]\)</span>表示有多少个1，在数字<span class="math inline">\(i\)</span>的二进制表示形式下。</li>
</ul></li>
<li><p>状态转移方程：</p>
<ul>
<li><p>边界：<span class="math inline">\(f[0] = [\ \ ]\)</span></p></li>
<li><p>正常情况：(第一时间也拿不出来，通过举例拿到的，)</p>
<p>eg.</p>
<p><span class="math inline">\(f[1] = 1\)</span></p>
<p><span class="math inline">\(f[2] = 1\)</span></p>
<p><span class="math inline">\(f[3] = 1 + 1 = f[2] + f[1]\)</span></p>
<p><span class="math inline">\(f[4] = 1\)</span></p>
<p><span class="math inline">\(f[5] = 2 = f[4] + f[1]\)</span></p>
<p><span class="math inline">\(f[6] = 2 = f[4] + f[2]\)</span></p>
<p><span class="math inline">\(f[7] = 3 = f[4] + f[2] + f[1]\)</span></p>
<p>得到： <span class="math display">\[
f[i] = \begin{cases}
[\ \ ], &amp; \text{if}\ i == 0 \\
1, &amp; \text{if}\ i == 2^m,\ \text{m is unisgned integer} \\
1 + f[i - j], &amp; \text{if}\ 2^j &lt; i &lt; 2^{j+1},\ \text{j is unsigned integer}
\end{cases}
\]</span> 合并下情况有： <span class="math display">\[
f[i] = 1 + f[i-j],\ \text{if}\ 2^j &lt; i &lt; 2^{j+1},\ \text{j is unsigned integer}
\]</span></p></li>
</ul></li>
</ul>
<p>然后以Cpp实现了如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; num+<span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; <span class="built_in">pow</span>(<span class="number">2</span>, j) &lt;= i; ++j)</span><br><span class="line">            &#123;&#125;</span><br><span class="line">            j = <span class="built_in">pow</span>(<span class="number">2</span>, j<span class="number">-1</span>);</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">int</span> val;</span><br><span class="line">            <span class="keyword">if</span> (i-j<span class="number">-1</span> == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">1</span> + vi[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">            vi.push_back(val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过很遗憾这是一种<strong>很低效的解法</strong></p>
<h2 id="standard-way">Standard Way</h2>
<p>详细解释见之后reference的官方解释link处，这里只给出最后的思路/状态转移方程和我的一些理解及实现。</p>
<h3 id="pop-count">1.Pop Count</h3>
<h4 id="思路">思路</h4>
<p>利用位运算<code>x &amp; (x - 1)</code>来不断消除最右边的一位1，直至数字为0时，可以算出这个数字有多少位1。</p>
<p><strong>PS</strong>：确实没想到位运算这块，思维狭隘了。</p>
<h4 id="实现">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi &#123;<span class="number">0</span>, <span class="number">1</span>, &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; num + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vi.push_back(pop_count(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_count</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 x &amp;= x - 1 的位运算操作，来消除掉一个数从左到右的最右边的一个1</span></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">for</span> (count = <span class="number">0</span>; num != <span class="number">0</span>; ++count)</span><br><span class="line">        &#123;</span><br><span class="line">            num &amp;= num - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>官方解这里利用了 default initialization来implicit初始化 未初始化的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; ++i)</span><br><span class="line">            ans[i] = popcount(i);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">popcount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">for</span> (count = <span class="number">0</span>; x != <span class="number">0</span>; ++count)</span><br><span class="line">          x &amp;= x - <span class="number">1</span>; <span class="comment">//zeroing out the least significant nonzero bit</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划-最高有效位">2. 动态规划 + 最高有效位</h3>
<h4 id="状态转移方程">状态转移方程</h4>
<p>结合1解法的<code>pop_count</code> <span class="math inline">\(P(x)\)</span>函数来，有以下状态转移函数： <span class="math display">\[
P(x+b) = P(x) + 1, b= 2^m &gt; x
\]</span></p>
<h4 id="我的理解">我的理解</h4>
<p>能想到最左最高有效位刚好多一个1的情况，这个1在m位的话，则是多了<span class="math inline">\(2^m\)</span>值。</p>
<h4 id="实现-1">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi(num+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 可以不初始化为，gcc, clang下，float, double, size_t, unsigned会由default initialization初始化0</span></span><br><span class="line">        <span class="comment">// 同理, string会初始化为''</span></span><br><span class="line">        <span class="comment">//vi[0] = 0;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用外部循环来找到满足 b = 2^m &gt; x的情况</span></span><br><span class="line">        <span class="comment">// i = 0是因为每4个一循环，给下4个取值</span></span><br><span class="line">        <span class="keyword">for</span> ( ; b &lt;= num; b &lt;&lt;= <span class="number">1</span>, x = <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (x &lt; b &amp;&amp; x + b &lt;= num)</span><br><span class="line">            &#123;</span><br><span class="line">                vi[x+b] = vi[x] + <span class="number">1</span>;</span><br><span class="line">                ++x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里官方解的Java实现有个非常巧妙的地方：</p>
<ul>
<li>利用了 <code>while (b &lt;= num) {...}</code>的外部循环来找到 <span class="math inline">\(b = 2^m &gt; x\)</span> 的<span class="math inline">\(b\)</span>值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># standard solution</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// [0, b) is calculated</span></span><br><span class="line">        <span class="keyword">while</span> (b &lt;= num) &#123;</span><br><span class="line">            <span class="comment">// generate [b, 2b) or [b, num) from [0, b)</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; b &amp;&amp; i + b &lt;= num)&#123;</span><br><span class="line">                ans[i + b] = ans[i] + <span class="number">1</span>;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            i = <span class="number">0</span>;   <span class="comment">// reset i</span></span><br><span class="line">            b &lt;&lt;= <span class="number">1</span>; <span class="comment">// b = 2b</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划-最低有效位">3. 动态规划 + 最低有效位</h3>
<h4 id="状态转移方程-1">状态转移方程</h4>
<p>同样基于<code>pop_count()</code>函数 <span class="math display">\[
P(x) = P(x/2) + (x\ mod\ 2)
\]</span></p>
<h4 id="我的理解-1">我的理解</h4>
<p>同理2解法，由最高有效位，想到最低有效位：</p>
<h4 id="实现-2">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi(num+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( ; i &lt; num + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vi[i] = vi[i/<span class="number">2</span>] + (i % <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里官方解，利用了位运算来代替已有的<code>/</code>和<code>%</code>运算：</p>
<ul>
<li><code>x &gt;&gt; 1</code> &lt;=&gt; <code>x / 2</code></li>
<li><code>x &amp; 1</code> &lt;=&gt; <code>x % 2</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        ans[i] = ans[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>); <span class="comment">// x / 2 is x &gt;&gt; 1 and x % 2 is x &amp; 1</span></span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划-最后设置位">4.动态规划 + 最后设置位</h3>
<h4 id="状态转移方程-2">状态转移方程</h4>
<p>同样基于<code>pop_count()</code>函数 <span class="math display">\[
P(x) = P(x\ \&amp;\ (x-1)) + 1
\]</span></p>
<h4 id="我的理解-2">我的理解</h4>
<p>利用位运算<code>x &amp; (x-1)</code>消除最右边的一位“1”，</p>
<p>使得 <code>x</code> 比 <code>x &amp; (x-1)</code> 少一位“1”， 加上这个“1”即可.</p>
<h4 id="实现-3">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi(num+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vi[i] = vi[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>官方解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        ans[i] = ans[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><p>简单DP，注意定义好状态，写出状态转移方程，然后注意corner case。写成代码即可。</p></li>
<li><p>注意涉及到 <strong>2进制</strong>， <strong>全0 1 的数字</strong>， <strong>非负整数, unsigned, size_t, size_type</strong>等等，</p>
<p>往位运算上面想。</p></li>
<li><p>总结这里的位运算操作，之后考虑全部总结下常见位运算操作, 我记得耗子有篇文章总结了很多这方面的。</p>
<ul>
<li><code>x &amp; (x - 1)</code> 消除 <code>x</code> 的最右边的一位1. (PS: 这一个确实不熟悉，虽然也见过)</li>
<li><code>x &lt;&lt; 2</code> &lt;=&gt; <code>x * 2</code></li>
<li><code>x &gt;&gt; 2</code> &lt;=&gt; <code>x / 2</code></li>
<li><code>x &amp; 1</code> &lt;=&gt; <code>x % 2</code></li>
</ul>
<p>(PS：那篇文章link找不到了)</p></li>
</ul>
<h2 id="reference">Reference</h2>
<p><a href="https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode/" target="_blank" rel="noopener">leetcode官方解答</a></p>
<p><a href="https://tex.stackexchange.com/questions/9065/large-braces-for-specifying-values-of-variables-by-condition" target="_blank" rel="noopener">Large braces for specifying values of variables by condition</a></p>
<h3 id="extended-knowledge">Extended knowledge</h3>
<p><a href="https://en.cppreference.com/w/cpp/utility/bitset/bitset" target="_blank" rel="noopener">std::bitset<n>::bitset in cppreference</n></a></p>
<p><a href="https://stackoverflow.com/questions/7349689/how-to-print-using-cout-a-number-in-binary-form" target="_blank" rel="noopener">How to print (using cout) a number in binary form?</a></p>
<p><a href="http://www.enseignement.polytechnique.fr/informatique/INF478/docs/Cpp/en/cpp/language/default_initialization.html" target="_blank" rel="noopener">default initialization</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/lifetime" target="_blank" rel="noopener">lifetime</a></p>
<p><a href="https://stackoverflow.com/questions/48775464/why-does-c-initialise-a-stdvector-with-zeros-but-not-a-stdarray" target="_blank" rel="noopener">Why does c++ initialise a std::vector with zeros, but not a std::array?</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>×</tag>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>位运算</tag>
        <tag>插入1个虚拟0</tag>
      </tags>
  </entry>
  <entry>
    <title>小结及之后</title>
    <url>/2019/10/23/%E5%B0%8F%E7%BB%93%E5%8F%8A%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<h2 id="小结">小结</h2>
<p>之前都去打了些结构化数据的比赛，也补了不少基础知识，尽管没有按当初的计划来。</p>
<p>尽管我觉得目前取得成绩不太够用吧，总结下有：</p>
<ul>
<li>上海电信“添翼杯”成绩预测20名（吐槽下这破比赛结束，官网就没了？？？）</li>
<li>kaggle Instant Gratification solo铜牌</li>
<li>19讯飞反欺诈，初赛第8，复赛a榜14，b榜24</li>
<li>DataCastle 国能日新光伏预测功率第二届第6名</li>
</ul>
<p>多多少少打了些咸鱼成绩出来。</p>
<p>最惨的还是讯飞，基本上2-3个月天天熬。初赛最后分数还算不错，到了复赛因为数据量太大，导致CatBoost在Shrink Model的时候峰值占用的内存会高到至少100g+和租的辣鸡DBC服务器疯狂卡结果，最后几天把我队的两个模型结果卡住没出来了。以及top3的选手开源了一个高分代码，上分操作与我队有一些重合，拉高了复赛线。</p>
<p>暂时有空抽时间把前面两篇坑了的博客补了，Data Science/ Machine Learning这块考虑暂时就放一段时间了。</p>
<h2 id="之后">之后？</h2>
<p>开始刷leetcode和补一些以前干的后台开发相关的活了。</p>
<ul>
<li>刷下Cpp reference啥啥的，把一些忘了的Cpp相关的东西捡起来；</li>
<li>每天至少龟系刷题1道，先从dp刷起来。1~2个月之后再考虑兔系刷题；</li>
<li>补下APUE那套东西，以前碰过，现在忘了不少；</li>
<li>接触下NoSQL，Redis这套；</li>
</ul>
<h3 id="ps">PS:</h3>
<p>以后写博客就不会那么详细，主要还是自己理解，留下一步一个脚印。</p>
<h3 id="pps">PPS：</h3>
<p>至于比赛还打不打，看时间够不够吧，能支撑自己走下去的只有求生欲了。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>在调用folds-split进行交叉检验时，使用tqdm记录每折时间</title>
    <url>/2019/07/01/%E5%9C%A8%E8%B0%83%E7%94%A8folds-split%E8%BF%9B%E8%A1%8C%E4%BA%A4%E5%8F%89%E6%A3%80%E9%AA%8C%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8tqdm%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%8A%98%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>&#39;如何将相对unix初始时间的时间差转换为当前时间轴&#39;</title>
    <url>/2019/07/01/%E5%A6%82%E4%BD%95%E5%B0%86%E7%9B%B8%E5%AF%B9unix%E5%88%9D%E5%A7%8B%E6%97%B6%E9%97%B4%E7%9A%84%E6%97%B6%E9%97%B4%E5%B7%AE%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E8%BD%B4/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>内存不够时，替代sns.countplot()的实现方法</title>
    <url>/2019/06/24/%E5%86%85%E5%AD%98%E4%B8%8D%E5%A4%9F%E6%97%B6%EF%BC%8C%E6%9B%BF%E4%BB%A3sns-countplot-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="内存不够时替代sns.countplot的实现方法">内存不够时，替代sns.countplot()的实现方法</h1>
<p>最近做EDA的的时候会存在这样一种情况，<strong>数据量过大</strong>时，直接使用<code>sns.countplot()</code>内存很容易直接被榨干掉。</p>
<p>暂时没想清为什么会直接占用那么多内存，应该去StackOverflow提个Q的。</p>
<p>不过想了下又查了下StackOverflow，应该有用<code>df.value_counts() 和</code> <code>matplotlib</code>来实现<code>sns.countplot()</code>的实现方法，如此，<a href="https://stackoverflow.com/questions/55667185/what-is-matplotlibs-alternative-for-countplot-from-seaborn" target="_blank" rel="noopener">What is Matplotlib's alternative for countplot from seaborn?</a></p>
<p>引用自StackOverflow，<a href="https://stackoverflow.com/users/4124317/importanceofbeingernest" target="_blank" rel="noopener">ImportanceOfBeingErnest</a></p>
<p>Say you have this data:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np; np.random.seed(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">"Sex"</span> : np.random.choice([<span class="string">"male"</span>,  <span class="string">"female"</span>], size=<span class="number">1310</span>, p=[<span class="number">.65</span>, <span class="number">.35</span>]),</span><br><span class="line">                   <span class="string">"other"</span> : np.random.randint(<span class="number">0</span>,<span class="number">80</span>, size=<span class="number">1310</span>)&#125;)</span><br></pre></td></tr></table></figure>
<p>You can plot a countplot in seaborn as</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.countplot(x=<span class="string">"Sex"</span>, data=df)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2019/06/24/内存不够时，替代sns-countplot-的实现方法/06/24/内存不够时，替代sns-countplot-的实现方法/countplot.jpg" title="sns.countplot">
<p>Or you can create a bar plot in pandas</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">"Sex"</span>].value_counts().plot.bar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2019/06/24/内存不够时，替代sns-countplot-的实现方法/06/24/内存不够时，替代sns-countplot-的实现方法/plt_bar.jpg" title="df[Sex].value_counts().plot.bar()">
<p>Or you can create a bar plot in matplotlib</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counts = df[<span class="string">"Sex"</span>].value_counts()</span><br><span class="line">plt.bar(counts.index, counts.values)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2019/06/24/内存不够时，替代sns-countplot-的实现方法/06/24/内存不够时，替代sns-countplot-的实现方法/value_counts_plot_bar.jpg" title="plt.bar(df[Sex].value_counts().index, df[Sex].value_counts().values)">
<h1 id="reference">Reference</h1>
<ul>
<li><a href="https://stackoverflow.com/questions/55667185/what-is-matplotlibs-alternative-for-countplot-from-seaborn" target="_blank" rel="noopener">What is Matplotlib's alternative for countplot from seaborn?</a></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html" target="_blank" rel="noopener">Pandas:Visualization Guide</a></li>
</ul>
]]></content>
      <categories>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>code snippet</tag>
        <tag>data visualization</tag>
        <tag>matplotlib</tag>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title>如何指定xtick在一个特定的范围</title>
    <url>/2019/06/24/%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9Axtick%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E7%9A%84%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<p>在做EDA的时候，会有种情况，时序数据所做的<code>plot</code>的x-axis会存在过于密集的情况，如下</p>
<img src="/2019/06/24/如何指定xtick在一个特定的范围/06/24/如何指定xtick在一个特定的范围/high_frequency_x_axis_plot.png" title="high_frequency_x_axis_plot">
<p>所以我们要做的就是只用将数据所在范围按一定频率切分开就行了，如这个Q，[how to change the xticks to a specific range [duplicate\]](https://stackoverflow.com/questions/56713197/how-to-change-the-xticks-to-a-specific-range) 和 <a href="https://stackoverflow.com/questions/12608788/changing-the-tick-frequency-on-x-or-y-axis-in-matplotlib" target="_blank" rel="noopener">Changing the “tick frequency” on x or y axis in matplotlib?</a></p>
<p>分别引用自StackOverflow用户 <a href="https://stackoverflow.com/users/840947/heike" target="_blank" rel="noopener">Heike</a>和<a href="https://stackoverflow.com/users/10041823/alexandre-b" target="_blank" rel="noopener">Alexandre B.</a>并作出了一定修改。</p>
<p>在comment和answer处提供了两种解决方案：</p>
<ul>
<li><p>添加一行代码<code>plt.xticks(range(9, 40, 10), range(10, 41, 10))</code></p>
<p>这里第一个参数是是将xtick分块显示，第二个参数是各个分块处显示的数字.(这里原来的数据找不到了，就用了answer中随机生成的数据为例子).</p>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Your data to count</span></span><br><span class="line">y = np.random.randint(<span class="number">0</span>,<span class="number">41</span>,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">sns.countplot(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show graph</span></span><br><span class="line">plt.xticks(range(<span class="number">0</span>, <span class="number">41</span>, <span class="number">10</span>), range(<span class="number">0</span>, <span class="number">41</span>, <span class="number">10</span>))</span><br><span class="line">plt.xlabel(<span class="string">'user_id'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2019/06/24/如何指定xtick在一个特定的范围/06/24/如何指定xtick在一个特定的范围/set_xticks_plot.png" title="plot_with_setting_xticks">
<p>但是假如将第一个参数设置的分块范围超过数据已有的范围，则会在plot超出数据已有范围处显示出一段blank。</p>
<img src="/2019/06/24/如何指定xtick在一个特定的范围/06/24/如何指定xtick在一个特定的范围/plot_with_blank.png" title="plot_with_blank"></li>
<li><p>One way is to define the labels on the x-axis. The <code>set_xticklabels</code> method from <code>matplotlib</code>module do the job <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.set_xticklabels.html" target="_blank" rel="noopener">(doc)</a>. By defining your own labels, you can hide them by setting the label equal to <code>''</code>.</p>
<p>By defining your own labels, you <strong>need to take care</strong> that they are still <strong>consistent with your data</strong>.</p>
<p>Here is one example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import modules</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#Init seaborn</span></span><br><span class="line">sns.set()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your data to count</span></span><br><span class="line">y = np.random.randint(<span class="number">0</span>,<span class="number">41</span>,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the new x-axis labels </span></span><br><span class="line">x_labels = [<span class="string">''</span> <span class="keyword">if</span> i%<span class="number">10</span> != <span class="number">0</span> <span class="keyword">else</span> str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(np.unique(y)))]</span><br><span class="line">print(x_labels)</span><br><span class="line"><span class="comment"># ['0', '', '', '', '', '', '', '', '', '', </span></span><br><span class="line"><span class="comment"># '10', '', '', '', '', '', '', '', '', '', </span></span><br><span class="line"><span class="comment"># '20', '', '', '', '', '', '', '', '', '', </span></span><br><span class="line"><span class="comment"># '30', '', '', '', '', '', '', '', '', '', '40']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">sns.countplot(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the new x axis labels</span></span><br><span class="line">ax.set_xticklabels(x_labels)</span><br><span class="line"><span class="comment"># Show graph</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2019/06/24/如何指定xtick在一个特定的范围/06/24/如何指定xtick在一个特定的范围/define_label_plot.png" title="defined_own_label_plot"></li>
</ul>
<h1 id="reference">Reference</h1>
<ul>
<li>[how to change the xticks to a specific range [duplicate\]](https://stackoverflow.com/questions/56713197/how-to-change-the-xticks-to-a-specific-range)</li>
<li><a href="https://stackoverflow.com/questions/12608788/changing-the-tick-frequency-on-x-or-y-axis-in-matplotlib" target="_blank" rel="noopener">Changing the “tick frequency” on x or y axis in matplotlib?</a></li>
<li><a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.set_xticklabels.html" target="_blank" rel="noopener">matplotlib.axes.Axes.set_xticklabels</a></li>
</ul>
]]></content>
      <categories>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>code snippet</tag>
        <tag>EDA</tag>
        <tag>pandas</tag>
        <tag>data disualization</tag>
      </tags>
  </entry>
  <entry>
    <title>将DataFrame中的数据以表格的形式另存为图片</title>
    <url>/2019/04/25/%E5%B0%86DataFrame%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A5%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8F%A6%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="将dataframe中的数据以表格的形式另存为图片">将DataFrame中的数据以表格的形式另存为图片</h1>
<p>在上次按序输出关联矩阵的blog中有了将DataFrame中的数据以表格形式另存储为图片的想法。</p>
<p>起初，Google了在StackOverflow上找到了<a href="https://stackoverflow.com/questions/35634238/how-to-save-a-pandas-dataframe-table-as-a-png" target="_blank" rel="noopener">相关问题</a>，并将代码修改应用于<a href="https://www.kaggle.com/c/titanic" target="_blank" rel="noopener">Titanic的数据</a>上，具体如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.plotting <span class="keyword">import</span>  table</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, frame_on=<span class="literal">False</span>) <span class="comment"># no visible frame</span></span><br><span class="line">ax.xaxis.set_visible(<span class="literal">False</span>)  <span class="comment"># hide the x axis</span></span><br><span class="line">ax.yaxis.set_visible(<span class="literal">False</span>)  <span class="comment"># hide the y axis</span></span><br><span class="line"></span><br><span class="line">table(ax, train_corr, loc=<span class="string">'center'</span>)  <span class="comment"># where df is your data frame</span></span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">'correlation_matrix_vague.jpg'</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2019/04/25/将DataFrame中的数据以表格的形式另存为图片/correlation_matrix_vague.jpg" alt="This is a vague pic"><figcaption>This is a vague pic</figcaption>
</figure>
<p>但是，发现另存为的图片极为模糊，再思考并查询相关文档未果后，并在StackOverflow上提出了<a href="https://stackoverflow.com/questions/55813270/how-to-make-picture-clear-when-saving-the-table-of-dataframe-as-a-picture" target="_blank" rel="noopener">相关问题</a>，发现是因为没有设置合适的<code>dpi</code>参数，故设置合适的<code>dpi</code>参数并修改代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.plotting <span class="keyword">import</span>  table</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">5</span>, <span class="number">6</span>), dpi=<span class="number">1400</span>)</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, frame_on=<span class="literal">False</span>) <span class="comment"># no visible frame</span></span><br><span class="line">ax.xaxis.set_visible(<span class="literal">False</span>)  <span class="comment"># hide the x axis</span></span><br><span class="line">ax.yaxis.set_visible(<span class="literal">False</span>)  <span class="comment"># hide the y axis</span></span><br><span class="line"></span><br><span class="line">table(ax, train_corr, loc=<span class="string">'center'</span>)  <span class="comment"># where df is your data frame</span></span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">'correlation_matrix_HD.jpg'</span>)</span><br></pre></td></tr></table></figure>
<img src="/2019/04/25/将DataFrame中的数据以表格的形式另存为图片/04/25/将DataFrame中的数据以表格的形式另存为图片/correlation_matrix_HD.jpg" title="This is a HD image of correlation matrix">
<h1 id="reference">Reference</h1>
<p><a href="%5Bhttps://bovenpeng.github.io/2019/04/22/%E5%9C%A8matplotlib%E7%9A%84%E4%B8%80%E4%B8%AAfigure%E4%B8%AD%E7%94%BB%E5%A4%9A%E4%B8%AAsubplots/%5D(https://bovenpeng.github.io/2019/04/22/在matplotlib的一个figure中画多个subplots/)">在matplotlib的一个figure中画多个subplots</a></p>
<p><a href="https://stackoverflow.com/questions/35634238/how-to-save-a-pandas-dataframe-table-as-a-png" target="_blank" rel="noopener">How to save a pandas DataFrame table as a png</a></p>
<p><a href="https://www.kaggle.com/c/titanic" target="_blank" rel="noopener">Titanic in Kaggle</a></p>
<p><a href="https://stackoverflow.com/questions/55813270/how-to-make-picture-clear-when-saving-the-table-of-dataframe-as-a-picture" target="_blank" rel="noopener">How to make picture clear when saving the table of DataFrame as a picture</a></p>
<p><a href="https://stackoverflow.com/questions/47633546/relationship-between-dpi-and-figure-size" target="_blank" rel="noopener">Relationship between dpi and figure size</a></p>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html#plotting-tools" target="_blank" rel="noopener">pandas.plotting</a></p>
<p><a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.table.html?highlight=table#matplotlib.pyplot.table" target="_blank" rel="noopener">matplotlib.pyplot.table</a></p>
]]></content>
      <categories>
        <category>Pandas</category>
      </categories>
      <tags>
        <tag>pandas</tag>
        <tag>matplotlib</tag>
        <tag>seaborn</tag>
        <tag>Code Snippet</tag>
      </tags>
  </entry>
  <entry>
    <title>以DataFrame的形式按序输出关联矩阵(correlation matrix)</title>
    <url>/2019/04/23/%E4%BB%A5DataFrame%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8C%89%E5%BA%8F%E8%BE%93%E5%87%BA%E5%85%B3%E8%81%94%E7%9F%A9%E9%98%B5(correlation%20matrix)/</url>
    <content><![CDATA[<h1 id="以dataframe的形式按序输出关联矩阵correlation-matrix">以DataFrame的形式按序输出关联矩阵(correlation matrix)</h1>
<p>一般来说在做EDA的时候，我们都是输出相关矩阵的热力图或者是以表格形式输出。</p>
<p>但是我在Stantar 2019的一个<a href="https://www.kaggle.com/artgor/santander-eda-fe-fs-and-models" target="_blank" rel="noopener">kernel</a>见到了按序输出关联矩阵系数的代码，故在此基础上进行了一定修改，实现了一个自己的code snippet.</p>
<p>具体例子见下：(此处数据采用<a href="https://www.kaggle.com/c/titanic" target="_blank" rel="noopener">Titanic in Kaggle</a>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_corr = train_df.drop([<span class="string">'PassengerId'</span>], axis=<span class="number">1</span>).corr()</span><br><span class="line">train_corr</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置热力图尺寸为(20, 12)</span></span><br><span class="line">plt.subplots(figsize=(<span class="number">20</span>, <span class="number">12</span>))</span><br><span class="line">sns.heatmap(train_corr, vmin=<span class="number">-1</span>, vmax=<span class="number">1</span>, annot=<span class="literal">True</span>, square=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<img src="/2019/04/23/以DataFrame的数据格式按序输出关联矩阵(correlation matrix)/04/23/以DataFrame的数据格式按序输出关联矩阵(correlation%20matrix)/heatmap.jpg" title="heatmap">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr = train_corr.abs().unstack().sort_values(kind=<span class="string">'quicksort'</span>, ascending=<span class="literal">False</span>).reset_index()</span><br><span class="line">corr = corr[(corr[<span class="string">'level_0'</span>] != corr[<span class="string">'level_1'</span>]) &amp; (corr[<span class="string">'level_0'</span>] == <span class="string">'Survived'</span>)]</span><br><span class="line">corr</span><br></pre></td></tr></table></figure>
<img src="/2019/04/23/以DataFrame的数据格式按序输出关联矩阵(correlation matrix)/04/23/以DataFrame的数据格式按序输出关联矩阵(correlation%20matrix)/correlation_matrix_HD.jpg" title="correlation_matrx">
<p>一般是设置<code>ascending</code>参数，来看你是想要按序输出高或低相关度.</p>
<p>这里feature数量比较少，故直接输出，一般是<code>corr</code>调用<code>tail()</code>或者<code>head()</code>来输出该顺序中的后或前几个相关系数。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr.tail(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>下一篇会在再讲下，如何将<code>Pandas.DataFrame</code>的表格存储为图片，这也是在写这篇blog过程中的一点idea的实现.</p>
<h1 id="reference">Reference</h1>
<p><a href="https://www.kaggle.com/c/titanic" target="_blank" rel="noopener">Titanic in Kaggle</a></p>
<p><a href="https://www.kaggle.com/artgor/santander-eda-fe-fs-and-models" target="_blank" rel="noopener">按序输出correlation matrix出处</a></p>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.unstack.html" target="_blank" rel="noopener">Pandas.DataFrame.unstack</a></p>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.reset_index.html" target="_blank" rel="noopener">Pandas.DataFrame.reset_index</a></p>
]]></content>
      <categories>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>code snippet</tag>
        <tag>EDA</tag>
        <tag>pandas</tag>
        <tag>data disualization</tag>
      </tags>
  </entry>
  <entry>
    <title>在matplotlib的一个figure中画多个subplots</title>
    <url>/2019/04/22/%E5%9C%A8matplotlib%E7%9A%84%E4%B8%80%E4%B8%AAfigure%E4%B8%AD%E7%94%BB%E5%A4%9A%E4%B8%AAsubplots/</url>
    <content><![CDATA[<h2 id="在一个figure中画多个subplots">在一个figure中画多个subplots</h2>
<p>在做EDA和Data Visualization中常常会用到的一个code snippet,在这里以<a href="https://www.kaggle.com/c/titanic" title="Titanic in Kaggle" target="_blank" rel="noopener">kaggle上的titianic数据为例子</a>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先导入packages</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line"><span class="comment"># path需根据具体环境作调节</span></span><br><span class="line">path = <span class="string">'input'</span></span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(<span class="string">''</span>.join([path, <span class="string">'/train.csv'</span>]))</span><br><span class="line">test_df = pd.read_csv(<span class="string">''</span>.join([path, <span class="string">'/test.csv'</span>]))</span><br><span class="line">gender_sub_df = pd.read_csv(<span class="string">''</span>.join([path, <span class="string">'/gender_submission.csv'</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以Survived特征为例子</span></span><br><span class="line">fig, (ax1, ax2) = plt.subplots(nrows=<span class="number">1</span>, ncols=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax1</span></span><br><span class="line">sns.countplot(train_df[<span class="string">'Survived'</span>], ax=ax1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax2</span></span><br><span class="line"><span class="comment"># autopct参数是用来显示饼图上百分比的</span></span><br><span class="line">ax2.pie(train_df[<span class="string">'Survived'</span>].value_counts(), autopct=<span class="string">'%1.1f%%'</span>)</span><br><span class="line"><span class="comment"># set_aspect('equal')是为了让饼图成圆形(circle)而不是椭圆(ellipse， oval)</span></span><br><span class="line">ax2.set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">plt.set_xlabel(<span class="string">'Survived'</span>)</span><br></pre></td></tr></table></figure>
<p>其中部分代码也可重写为如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(nrows=<span class="number">1</span>, ncols=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax1</span></span><br><span class="line">sns.countplot(train_df[<span class="string">'Survived'</span>], ax=ax[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax2</span></span><br><span class="line">ax[<span class="number">1</span>].pie(train_df[<span class="string">'Survived'</span>].value_counts(), autopct=<span class="string">'%1.1f%%'</span>)</span><br><span class="line">ax[<span class="number">1</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">plt.set_xlabel(<span class="string">'Survived'</span>)</span><br></pre></td></tr></table></figure>
<img src="/2019/04/22/在matplotlib的一个figure中画多个subplots/04/22/在matplotlib的一个figure中画多个subplots/countplot_and_pieplot_in_one_figure.jpg" title="This is an image">
<p>也可以根据修改<code>nrows</code>, <code>ncols</code>参数来适用多行多列的情况：(这里举得这个例子只是为了举例而举例，没有过多实际意义)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax[0, 0]</span></span><br><span class="line">sns.countplot(train_df[<span class="string">'Survived'</span>], ax=ax[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax[0, 1]</span></span><br><span class="line">ax[<span class="number">0</span>, <span class="number">1</span>].pie(train_df[<span class="string">'Survived'</span>].value_counts(), autopct=<span class="string">'%1.1f%%'</span>)</span><br><span class="line">ax[<span class="number">0</span>, <span class="number">1</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">ax[<span class="number">0</span>, <span class="number">1</span>].set_xlabel(<span class="string">'Survived'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax[1, 0]</span></span><br><span class="line">sns.countplot(train_df[<span class="string">'Pclass'</span>], ax=ax[<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax[1, 1]</span></span><br><span class="line">ax[<span class="number">1</span>, <span class="number">1</span>].pie(train_df[<span class="string">'Pclass'</span>].value_counts(), autopct=<span class="string">'%1.1f%%'</span>)</span><br><span class="line">ax[<span class="number">1</span>, <span class="number">1</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">ax[<span class="number">1</span>, <span class="number">1</span>].set_xlabel(<span class="string">'Pclass'</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2019/04/22/在matplotlib的一个figure中画多个subplots/four_subplots_in_one_figure.jpg" alt="four_subplots_in_one_figure"><figcaption>four_subplots_in_one_figure</figcaption>
</figure>
<p>当然也可以用循环来实现，在此不对这举例了。</p>
<p>中间还有2个小插曲，就是我实现的时候，发现<code>ax[0, 0]</code>的subplot没有<code>x_label</code>,所以还去StackOverflow上面提了个<a href="https://stackoverflow.com/questions/55794894/set-xlabel-is-in-invalid-in-ax0-0-when-drawing-4-subplots-in-one-plot" title="ax[0, 0]的subplot的set_xlabel无效" target="_blank" rel="noopener">Question</a>，发现仅仅是被hidden住了，加上一行<code>plt.tight_layer()</code>代码即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax[0, 0]</span></span><br><span class="line">sns.countplot(train_df[<span class="string">'Survived'</span>], ax=ax[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax[0, 1]</span></span><br><span class="line">ax[<span class="number">0</span>, <span class="number">1</span>].pie(train_df[<span class="string">'Survived'</span>].value_counts(), autopct=<span class="string">'%1.1f%%'</span>)</span><br><span class="line">ax[<span class="number">0</span>, <span class="number">1</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">ax[<span class="number">0</span>, <span class="number">1</span>].set_xlabel(<span class="string">'Survived'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax[1, 0]</span></span><br><span class="line">sns.countplot(train_df[<span class="string">'Pclass'</span>], ax=ax[<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax[1, 1]</span></span><br><span class="line">ax[<span class="number">1</span>, <span class="number">1</span>].pie(train_df[<span class="string">'Pclass'</span>].value_counts(), autopct=<span class="string">'%1.1f%%'</span>)</span><br><span class="line">ax[<span class="number">1</span>, <span class="number">1</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">ax[<span class="number">1</span>, <span class="number">1</span>].set_xlabel(<span class="string">'Pclass'</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout(h_pad=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2019/04/22/在matplotlib的一个figure中画多个subplots/four_subplots_in_one_figure_plt_tight_layout.jpg" alt="four_subplots_in_one_figure_plt_tight_layout"><figcaption>four_subplots_in_one_figure_plt_tight_layout</figcaption>
</figure>
<p>还有就是hexo插图片时，若用markdown语法，说是文章在首页无法显示图片，点进去后仍可，所以只可采用最好用标签插件语法来实现，例如：</p>
<blockquote>
<img src="/2019/04/22/在matplotlib的一个figure中画多个subplots/04/22/在matplotlib的一个figure中画多个subplots/image.jpg" title="This is an image">
</blockquote>
<h2 id="reference">Reference</h2>
<p><a href="https://www.kaggle.com/c/titanic" target="_blank" rel="noopener">Titanic in Kaggle</a></p>
<p><a href="https://stackoverflow.com/questions/9230389/why-is-matplotlib-plotting-my-circles-as-ovals" target="_blank" rel="noopener">why-is-matplotlib-plotting-my-circles-as-ovals</a></p>
<p><a href="https://stackoverflow.com/questions/7082345/how-to-set-the-labels-size-on-a-pie-chart-in-python" target="_blank" rel="noopener">how-to-set-the-labels-size-on-a-pie-chart-in-python</a></p>
<p><a href="https://stackoverflow.com/questions/55794894/set-xlabel-is-in-invalid-in-ax0-0-when-drawing-4-subplots-in-one-plot" target="_blank" rel="noopener">set-xlabel-is-in-invalid-in-ax0-0-when-drawing-4-subplots-in-one-plot</a></p>
<p><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/" target="_blank" rel="noopener">How-to-insert-image-in-hexo-post</a></p>
]]></content>
      <categories>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>code snippet</tag>
        <tag>EDA</tag>
        <tag>data visualization</tag>
        <tag>matplotlib</tag>
        <tag>seaborn</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Stantar 2019有感</title>
    <url>/2019/04/22/Stantar-2019%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<h1 id="stantar-2019有感">Stantar 2019有感</h1>
<p>看了很多个top solution，尤其是<a href="https://www.kaggle.com/c/santander-customer-transaction-prediction/discussion/88926#latest-518288" target="_blank" rel="noopener">金牌区域的</a>。</p>
<p>给我感觉在这个比赛中的几个重要的<strong>magic</strong>有：</p>
<ul>
<li>frequency coding；在对于匿名数据或者categorical feature上，可以先试着这样做下，一般是会提升local CV之类；</li>
<li>fake data；对于training set和testing set中的unique value的数量明显不同，让人怀疑testing set中的数据包含伪造数据。对于testing set中的伪造数据进行删除即可。<a href="https://www.kaggle.com/yag320/list-of-fake-samples-and-public-private-lb-split" target="_blank" rel="noopener">List of Fake Samples and Public/Private LB split</a></li>
<li>independent feature；利用feature间的相互独立性，在用LightGBM训练时，只对某一特征训练，故有200个lgb classifier再对预测结果进行简单的simple linear blending。<a href="https://www.kaggle.com/titericz/giba-single-model-public-0-9245-private-0-9234" target="_blank" rel="noopener">a single model using all features vstacked that is enough for a top20 on Private</a></li>
</ul>
<p>感受颇深的是对于这些<strong>magic</strong>，一是自己确实没有通过EDA来发现到，能力有限；二是其实在kernel和discussion中都有多多少少提及到，自己未引起重视又或者不知如何是好。</p>
<p>个人主要感觉还是：</p>
<ol type="1">
<li>在EDA方面考虑得不够到位，而且可以利用：
<ol type="1">
<li>Local CV和LB的提升上差异来分析是哪里的问题，然后解决并使得Local CV和LB的提升近似。比如此次中，一开始无论local CV提升有多高，LB都会锁在9.001上。而解决到fake data的存在后，local CV提升，LB也会随之提升，使得LB锁在9.001的情况不复存在；</li>
<li>可以根据kernel和discussion区域中，若在新的发布后，上的存在着许多人的大幅度增长，则说明某个kernel或discussion揭露了<strong>magic</strong>；</li>
</ol></li>
<li><strong>Model</strong>这一块也是有问题，很明显在NN上存在很多问题，尤其是现在去看top solution中开源的NN代码，会存在很多逻辑看不太懂的情况；</li>
<li><strong>Parameter Tuning</strong>上面也有问题，除了最基本的<strong>Grid Search</strong>和<strong>Random Search</strong>外，对于<strong>Bayesian optimization</strong>没有理解且无法应用出来。<a href="https://www.kaggle.com/c/santander-customer-transaction-prediction/discussion/89320#517455" target="_blank" rel="noopener">Chris这个discussion给了很多inspirations</a>；</li>
<li>对于Data Science这块Coding能力上也存在着问题，不能很流畅的阅读代码逻辑；</li>
<li>这个比赛没有用到<strong>Feature Selection</strong>, 然而这块也是我的弱项；</li>
<li>在最后如何选取2个<strong>the most robust model</strong>用于提交到PB上也仍未解决。</li>
</ol>
<p>不过感觉还是收获了不少，在我上述几方面加强后，还是需要回来reiview Stantar这个比赛的各个solution。</p>
<h1 id="reference">Reference</h1>
<p><a href="https://www.kaggle.com/c/santander-customer-transaction-prediction/discussion/88926#latest-518288" target="_blank" rel="noopener">Gold Medal Solutions of Stantar 2019</a></p>
<p><a href="https://www.kaggle.com/yag320/list-of-fake-samples-and-public-private-lb-split" target="_blank" rel="noopener">List of Fake Samples and Public/Private LB split</a></p>
<p><a href="https://www.kaggle.com/titericz/giba-single-model-public-0-9245-private-0-9234" target="_blank" rel="noopener">Giba: a single model using all features vstacked that is enough for a top20 on Private</a></p>
<p><a href="https://www.kaggle.com/c/santander-customer-transaction-prediction/discussion/89320#517455" target="_blank" rel="noopener">Chirs: How do we optimize GBM hyperparameters?</a></p>
]]></content>
      <categories>
        <category>data competition</category>
      </categories>
      <tags>
        <tag>kaggle</tag>
        <tag>data competition</tag>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title>一些学习计划</title>
    <url>/2019/04/11/%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="学习计划">学习计划</h1>
<ol type="1">
<li><p>reivew知识，夯实基础。按着sklearn中User Guide中的6个模块来review一遍文档和其中涉及到的相关知识。不过不会以完整的罗列出来全部内容的形式来做，这样就不符合DRY原则了(笑)，只打算列出各个API中涉及到的不熟悉的知识点的相关知识，又或者是相关链接，自己做一定的归纳总结。</p>
<p>具体来说就是：</p>
<ul>
<li>理论知识上，在学习到一定程度下，留下学习到的相关链接，总结自己的理解；</li>
<li>代码实现上，在完全不熟悉或者理解不够透彻的情况下，需进行一定量的coding(暂不打算开源)；</li>
<li>主要方向上，主要围绕<code>Supervised Learning</code>, <code>Model selection and evaluation</code>, <code>Dataset transformations</code>, <code>Unsupervised Learning</code>这4个模块进行，除此之外对于<code>XGBoost</code>, <code>LightGBM</code>, <code>CatBoost</code>等Kaggle常见模型进行复习。</li>
<li>估计耗时：1个半月-2个月</li>
</ul></li>
<li><p>继续实战。</p>
<p>具体目标有：</p>
<ol type="1">
<li><p>完成对Stantar customer transaction prediction 2019的kernel和discussion的学习，并在别人给出的hints下，自己实现一个top 1 % kernel并开源出来。</p></li>
<li><p>在Don't Overfit 和TMDB Box Office Prediction 两个Plaground competition中争取进去Sliver Zone，并在Don't Overfit 结束并学习完后赶紧进入Jigsaw和Earthquake的两个比赛中去。</p></li>
<li><p>review Matplotlib和seaborn两个package，根据Kaggle开源kernel熟悉可视化部分。之前这块太弱了，严重影响了EDA的能力。</p></li>
<li><p>review Numpy和Pandas两个package，加强数据处理的能力。</p>
<ul>
<li><p>估计耗时：</p>
<ol type="1">
<li>10-15天</li>
<li>持续2个月+</li>
<li>15-20天</li>
<li>10-15天</li>
</ol></li>
</ul></li>
</ol></li>
<li><p>Book Reading&amp;Thesis Learing</p>
<p>具体目标有：</p>
<ol type="1">
<li>reivew线代(之前被搁置过)。把UTM-Applied-Linear-Algebra-and-Matrix-Analysis这本书剩下的地方内容+课后带答案的题仔细刷一遍(之前搁置到50%)；</li>
<li><del>开PRML/ESL/MLAPP的坑</del>。</li>
<li><del>开Boyd的凸优化的坑。</del></li>
<li><del>开NLP的坑。</del></li>
<li><del>开Stanford ML相关公开课的坑</del>
<ul>
<li>估计耗时：2-3天一节，争取1.5个月内review完UTM这本线代书，再考虑开什么坑比较合适...</li>
</ul></li>
</ol>
<p>将这些任务同时进行，争取2个月之内完成这些目标，中间老板可能会有各种任务，最多不要拖过2周。在大部分结束前1-2周，会定制新的计划。</p></li>
</ol>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title>杂谈-为什么要搭一个blog</title>
    <url>/2019/04/11/%E6%9D%82%E8%B0%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%90%AD%E4%B8%80%E4%B8%AAblog/</url>
    <content><![CDATA[<h1 id="为什么以前不搭一个blog">为什么以前不搭一个blog？</h1>
<p>先谈谈为什么一起没这么个念头，主要有以下几点：</p>
<ul>
<li>不想写些看上去很厉害其实没什么用的东西。</li>
<li>不想写些拾人牙慧的东西。</li>
<li>不想写些随便Google两下，或者看看两眼官方文档就能搞懂的东西。</li>
<li>写blog组织语言起来其实很费时。</li>
</ul>
<p>而在有的网站上充斥着大量的这类内容，当然不是说没有“金子”在其中，只不过都被“垃圾”掩埋住了，所以在我觉得我不能输出一份没有任何错误的干货下，并不打算输出自己的知识。</p>
<h1 id="为什么现在又搭了一个自己的blog呢">为什么现在又搭了一个自己的blog呢？</h1>
<p>无论是学业，还是生活都遭遇了很多糟心事，总得来说以下几个原因：</p>
<ul>
<li>学习状态一直受挫，到现在为止都很难维持住我以前的最佳状态(每天8-10小时有效学习时间)。导致有些东西学了查，查了用，用了忘，忘了又查的循环之中，低效率甚至无效率学习时间过多。我得找个地方记住这些常常需要review的问题。</li>
<li>刚参加的一场Kaggle比赛，最后比赛结束，结果从Public LB top 7%跌到Private LB top15%。很受打击，感觉自己学的东西很不扎实。用荀子《劝学》中的一句话来说就是“蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。”。我得沉下心来，所以我决定找个地方记录下这个过程。</li>
<li>常常写blog，可以刷下GitHub的contributions次数，让生活充满绿色(笑)，通过这个激励自己。</li>
</ul>
<h1 id="所以呢">所以呢？</h1>
<p>所以，可能我大概率可能在未来会输出一些我曾认为的“垃圾“。</p>
<p>Never mind,</p>
<p><a href="https://en.wikipedia.org/wiki/Lucky_You_(song)" target="_blank" rel="noopener">it's my turn to cut food.</a></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
