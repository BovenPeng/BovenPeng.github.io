<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode题解-1221-分割平衡字符串]]></title>
    <url>%2F2019%2F10%2F28%2Fleetcode%E9%A2%98%E8%A7%A3-1221-%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目 虽然打的是 贪心算法 的tag，但是我感觉实际上是括号匹配的简单变种。 解法 括号匹配/栈的做法 考虑L, R分别对应左右两个括号。 利用stack的push, pop和括号匹配的基本思路来完成。 栈为空，push当前元素。 top元素 等于 当前元素，push当前元素，否则pop top元素。 栈为空，平衡次数+1。 PS: 注意思路实现是带有先后顺序的。 123456789101112131415161718192021222324252627class Solution &#123;public: int balancedStringSplit(string s) &#123; int count = 0; stack&lt;char&gt; sc; for (int i = 0; i &lt; s.size(); ++i) &#123; char c = s[i]; if (sc.empty() || c == sc.top()) &#123; sc.push(c); &#125; else &#123; sc.pop(); &#125; if (sc.empty()) &#123; ++count; &#125; &#125; return count; &#125;&#125;; 利用数字计数代替括号匹配做法 因为这里不同于括号匹配需要是一个&lt;&gt;的匹配状态，可以是LR, RL, LLRR, RRLL， 也就是说可以看成一个简单版本的括号匹配过程， 因为不需要要求L, R之间的先后关系，所以可以通过 数字计数 取代掉 栈括号匹配 的过程。 若当前元素为L, 计数++num；为R, 计数--num; 若num == 0, 则平衡次数+1。 1234567891011121314151617181920212223242526class Solution &#123;public: int balancedStringSplit(string s) &#123; int num = 0; int count = 0; for (auto it = s.begin(); it &lt; s.end(); ++it) &#123; if (*it == 'L') &#123; ++num; &#125; else &#123; --num; &#125; if (num == 0) &#123; ++count; &#125; &#125; return count; &#125;&#125;; 总结 这题提及的&quot;尽可能多的平衡字符串分割“ + 实例，说明了这里的字符串分割是不存在前后分割出的字符串结果有交集的。 可以思考到，正常的从头到尾的一次遍历即可。 提及的” ‘L’和'R'字符的数量是相同的 &quot;, 并没有提及到 L和R要有前后顺序的关系 可以思考到，利用 数字计数法 代替 括号匹配法。 Reference Karua leetcode 题解 amanehayashi leetcode 题解 Extended std::stack STL header stack iterator library]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
        <tag>栈</tag>
        <tag>线性表</tag>
        <tag>括号匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解: 877.石子游戏]]></title>
    <url>%2F2019%2F10%2F27%2Fleetcode%E9%A2%98%E8%A7%A3-877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目 官方解 数学way 直接从官方解处摘抄过来，很有意思的数学归纳证明思想。如下： 显然，亚历克斯总是赢得 2 堆时的游戏。 通过一些努力，我们可以获知她总是赢得 4 堆时的游戏。 如果亚历克斯最初获得第一堆，她总是可以拿第三堆。 如果她最初取到第四堆，她总是可以取第二堆。第一 + 第三，第二 + 第四 中的至少一组是更大的，所以她总能获胜。 我们可以将这个想法扩展到 N 堆的情况下。设第一、第三、第五、第七桩是白色的，第二、第四、第六、第八桩是黑色的。 亚历克斯总是可以拿到所有白色桩或所有黑色桩，其中一种颜色具有的石头数量必定大于另一种颜色的。 因此，亚历克斯总能赢得比赛。 123456class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; return true; &#125;&#125;; 综评最高解 在dp解释上强于官方解，简要摘取部分过程，详细见reference处。 对于\(piles=[3, 9, 1, 2]\), 定义状态： \[ dp[i][j].fir\ or\ dp[i][j].sec\\ 其中：\\ 0 &lt;= i &lt; piles.length, i相当于石子堆最左堆\\ i &lt;= j &lt; piles.length, j相当于石子堆最右堆 \] 其中， \[ dp[i][j].fir表示，对于piles[i...j]这部分石子，先手能获得的最高分数 \\ dp[i][j].sec表示，对于piles[i...j]这部分石子，后手能获得的最高分数 \] 状态转移方程为： \[ dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec) \\ \] $$ \[\begin{align*} &amp; if 先手选择左边: dp[i][j].sec = dp[i+1][j].fir \\ &amp; if 先手选择右边: dp[i][j].sec = dp[i][j-1].fir \\ &amp; 解释：\\ &amp; 我作为后手，要等先手先选择，有两种情况： \\ &amp; 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j] \\ &amp; 此时轮到我，我变成了先手；\\ &amp; 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1] \\ &amp; 此时轮到我，我变成了先手。\\ \end{align*}\] $$ base case \[ \begin{align*} &amp; dp[i][j].fir = piles[i] \\ &amp; dp[i][j].sec = 0 \\ &amp; 其中 0 &lt;= i == j &lt; n \\ &amp; 解释：i 和 j 相等就是说面前只有一堆石头 piles[i] \\ &amp; 那么显然先手的得分为 piles[i] \\ &amp; 后手没有石头拿了，得分为 0 \\ \end{align*} \] 这里需要注意一点，我们发现 \(base\ case\)是斜着的，而且我们推算 dp[i][j] 时需要用到 dp[i+1][j] 和 dp[i][j-1]： 所以说算法不能简单的一行一行遍历 dp 数组，而要斜着遍历数组： 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int n = piles.size(); // initialize dp array vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; dp(n, vector&lt;pair&lt;int, int&gt;&gt;(n, make_pair(0, 0))); // fill with base case for (int i = 0; i &lt; n; ++i) &#123; dp[i][i].first = piles[i]; dp[i][i].second = 0; &#125; // traverse array in a diagonal way for (int l = 2; l &lt;= n; ++l) &#123; for (int i = 0; i &lt;= n - l; ++i) &#123; int j = i + l - 1; // 先手选择最左边或者最右边的分数 int left = piles[i] + dp[i+1][j].second; int right = piles[j] + dp[i][j-1].second; // 套用状态转移方程 if (left &gt; right) &#123; dp[i][j].first = left; dp[i][j].second = dp[i+1][j].first; &#125; else &#123; dp[i][j].first = right; dp[i][j].second = dp[i][j-1].first; &#125; &#125; &#125; pair&lt;int, int&gt; res(dp[0][n-1]); return res.first - res.second; &#125;&#125;; 综评Java实现 123456789101112131415161718192021222324252627282930313233/* 返回游戏最后先手和后手的得分之差 */int stoneGame(int[] piles) &#123; int n = piles.length; // 初始化 dp 数组 Pair[][] dp = new Pair[n][n]; for (int i = 0; i &lt; n; i++) for (int j = i; j &lt; n; j++) dp[i][j] = new Pair(0, 0); // 填入 base case for (int i = 0; i &lt; n; i++) &#123; dp[i][i].fir = piles[i]; dp[i][i].sec = 0; &#125; // 斜着遍历数组 for (int l = 2; l &lt;= n; l++) &#123; for (int i = 0; i &lt;= n - l; i++) &#123; int j = l + i - 1; // 先手选择最左边或最右边的分数 int left = piles[i] + dp[i+1][j].sec; int right = piles[j] + dp[i][j-1].sec; // 套用状态转移方程 if (left &gt; right) &#123; dp[i][j].fir = left; dp[i][j].sec = dp[i+1][j].fir; &#125; else &#123; dp[i][j].fir = right; dp[i][j].sec = dp[i][j-1].fir; &#125; &#125; &#125; Pair res = dp[0][n-1]; return res.fir - res.sec;&#125; 总结 二维DP，也是递推问题，但是给人的没有一维DP那么好处理。 状态定义，一般涉及到2个状态\(i,\ j\)。可以用表格法表示，有点类似0-1背包问题。 状态转移方程，一般涉及到上一状态的2个状态。 base case, 我的理解是一般类似于 corner case的存在，是一个需要考虑到的初始条件。 斜着遍历数组，这个在实现的时候，也不是一件非常容易的事情。 123456789// traverse array in a diagonal wayfor (int l = 2; l &lt;= n; ++l)&#123; for (int i = 0; i &lt;= n - l; ++i) &#123; int j = i + l - 1; // ... &#125;&#125; 若\(n = 4\), 则依次遍历： \[ \begin{align*} &amp; [0,\ 1],\ [1,\ 2], [2,\ 3], [3,\ 4] \\ &amp; [0,\ 2],\ [1,\ 3], [2,\ 4] \\ &amp; [0,\ 3],\ [1,\ 4] \\ &amp; [0,\ 4] \\ \end{align*} \] Reference labuladong: leetcode解 leetcode 官方解 extended std::pair std::vector]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>二维dp</tag>
        <tag>博弈问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解: 1025.除数博弈]]></title>
    <url>%2F2019%2F10%2F24%2Fleetcode%E9%A2%98%E8%A7%A3-1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[题目 My way: 这题靠归纳推理，首先很明显就能看出来偶数的时候Alice赢了； 然后多举了几个例子就发现奇数的时候Bob赢了。 就直接一个条件语句，结束。 但是尝试套dp的做法的时候，没捋清楚，看了综评最高的，基本懂了。 12345678910111213class Solution &#123;public: bool divisorGame(int N) &#123; if (!(N &amp; 1)) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;; 综评最高解 1.归纳法： 基本思路： 最终结果应该是占到 2 的赢，占到 1 的输； 若当前为奇数，奇数的约数只能是奇数或者 1，因此下一个一定是偶数； 若当前为偶数， 偶数的约数可以是奇数可以是偶数也可以是 1，因此直接减 1，则下一个是奇数； 因此，奇则输，偶则赢。 123class Solution: def divisorGame(self, N: int) -&gt; bool: return N%2==0 2.DP: 定义状态 \(i\): 数字\(N\)为\(i\)时； \(f[i]\): 数字\(N\)为\(i\)时，Alice的胜负状况，true为胜，false为负。 定义状态转移方程： \[ f[i] = \begin{cases} true, &amp; \text{if}\ f[i-j] == false,\ \text{if}\ i\ \%\ j == 0\ \\ &amp; and\ j\ is\ unsigned\ integer\ which \in (0, N) \ \\ false, &amp; \text{otherwise} \end{cases} \] 实现 1234567891011121314151617181920class Solution &#123;public: bool divisorGame(int N) &#123; vector&lt;bool&gt; vi(N+1); for (int i = 2; i &lt; N + 1; ++i) &#123; for (int j = 1; j &lt;= i / 2; ++j) &#123; if (vi[i-j] == false &amp;&amp; i % j == 0) &#123; vi[i] = true; &#125; &#125; &#125; return vi[N]; &#125;&#125;; 综评解 12345678910111213141516class Solution: def divisorGame(self, N: int) -&gt; bool: target = [0 for i in range(N+1)] target[1] = 0 #若爱丽丝抽到1，则爱丽丝输 if N&lt;=1: return False else: target[2] = 1 #若爱丽丝抽到2，则爱丽丝赢 for i in range(3,N+1): for j in range(1,i//2): # 若j是i的余数且target[i-j]为假（0）的话，则代表当前为真（1） if i%j==0 and target[i-j]==0: target[i] = 1 break return target[N]==1 总结 初等数学review: 奇数的因数： {奇数} 偶数的因数： {偶数} 奇数的最大公因数 = 奇数 目前做到的dp还是简单递推问题，可以简单套换成： 状态\(i\)就是数字为\(i\)的时候 \(f[i]\)就是数字为\(i\)时候，结果为\(f[i]\) Reference pandawakaka 给出的解]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学题</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解: 338.比特位计数]]></title>
    <url>%2F2019%2F10%2F23%2Fleetcode%E9%A2%98%E8%A7%A3-338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目 My way: 这题tag是dp，按着dp的思路写出了 状态， 状态转移方程包括 边界条件， 常规情况。 大致思路如下： 定义状态： \(i\): 数字为\(i\)时； \(f[i]\): 数字为i时，\(f[i]\)表示有多少个1，在数字\(i\)的二进制表示形式下。 状态转移方程： 边界：\(f[0] = [\ \ ]\) 正常情况：(第一时间也拿不出来，通过举例拿到的，) eg. \(f[1] = 1\) \(f[2] = 1\) \(f[3] = 1 + 1 = f[2] + f[1]\) \(f[4] = 1\) \(f[5] = 2 = f[4] + f[1]\) \(f[6] = 2 = f[4] + f[2]\) \(f[7] = 3 = f[4] + f[2] + f[1]\) 得到： \[ f[i] = \begin{cases} [\ \ ], &amp; \text{if}\ i == 0 \\ 1, &amp; \text{if}\ i == 2^m,\ \text{m is unisgned integer} \\ 1 + f[i - j], &amp; \text{if}\ 2^j &lt; i &lt; 2^{j+1},\ \text{j is unsigned integer} \end{cases} \] 合并下情况有： \[ f[i] = 1 + f[i-j],\ \text{if}\ 2^j &lt; i &lt; 2^{j+1},\ \text{j is unsigned integer} \] 然后以Cpp实现了如下： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; if (num == 0) &#123; return vector&lt;int&gt;&#123;0&#125;; &#125; if (num == 1) &#123; return vector&lt;int&gt; &#123;0, 1&#125;; &#125; vector&lt;int&gt; vi &#123;0, 1&#125;; for (int i = 2; i &lt; num+1; ++i) &#123; int j; for (j = 0; pow(2, j) &lt;= i; ++j) &#123;&#125; j = pow(2, j-1); int val; if (i-j-1 == -1) &#123; val = 1; &#125; else &#123; val = 1 + vi[i-j]; &#125; vi.push_back(val); &#125; return vi; &#125;&#125;; 不过很遗憾这是一种很低效的解法 Standard Way 详细解释见之后reference的官方解释link处，这里只给出最后的思路/状态转移方程和我的一些理解及实现。 1.Pop Count 思路 利用位运算x &amp; (x - 1)来不断消除最右边的一位1，直至数字为0时，可以算出这个数字有多少位1。 PS：确实没想到位运算这块，思维狭隘了。 实现 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; if (num == 0) &#123; return vector&lt;int&gt;&#123;0&#125;; &#125; if (num == 1) &#123; return vector&lt;int&gt; &#123;0, 1&#125;; &#125; vector&lt;int&gt; vi &#123;0, 1, &#125;; for (int i = 2; i &lt; num + 1; ++i) &#123; vi.push_back(pop_count(i)); &#125; return vi; &#125;private: int pop_count(int num) &#123; // 通过 x &amp;= x - 1 的位运算操作，来消除掉一个数从左到右的最右边的一个1 int count; for (count = 0; num != 0; ++count) &#123; num &amp;= num - 1; &#125; return count; &#125;&#125;; 官方解这里利用了 default initialization来implicit初始化 未初始化的结果。 1234567891011121314public class Solution &#123; public int[] countBits(int num) &#123; int[] ans = new int[num + 1]; for (int i = 0; i &lt;= num; ++i) ans[i] = popcount(i); return ans; &#125; private int popcount(int x) &#123; int count; for (count = 0; x != 0; ++count) x &amp;= x - 1; //zeroing out the least significant nonzero bit return count; &#125;&#125; 2. 动态规划 + 最高有效位 状态转移方程 结合1解法的pop_count \(P(x)\)函数来，有以下状态转移函数： \[ P(x+b) = P(x) + 1, b= 2^m &gt; x \] 我的理解 能想到最左最高有效位刚好多一个1的情况，这个1在m位的话，则是多了\(2^m\)值。 实现 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; vi(num+1); // 可以不初始化为，gcc, clang下，float, double, size_t, unsigned会由default initialization初始化0 // 同理, string会初始化为'' //vi[0] = 0; int x = 0, b = 1; // 利用外部循环来找到满足 b = 2^m &gt; x的情况 // i = 0是因为每4个一循环，给下4个取值 for ( ; b &lt;= num; b &lt;&lt;= 1, x = 0) &#123; while (x &lt; b &amp;&amp; x + b &lt;= num) &#123; vi[x+b] = vi[x] + 1; ++x; &#125; &#125; return vi; &#125;&#125;; 这里官方解的Java实现有个非常巧妙的地方： 利用了 while (b &lt;= num) {...}的外部循环来找到 \(b = 2^m &gt; x\) 的\(b\)值 123456789101112131415161718# standard solutionpublic class Solution &#123; public int[] countBits(int num) &#123; int[] ans = new int[num + 1]; int i = 0, b = 1; // [0, b) is calculated while (b &lt;= num) &#123; // generate [b, 2b) or [b, num) from [0, b) while(i &lt; b &amp;&amp; i + b &lt;= num)&#123; ans[i + b] = ans[i] + 1; ++i; &#125; i = 0; // reset i b &lt;&lt;= 1; // b = 2b &#125; return ans; &#125;&#125; 3. 动态规划 + 最低有效位 状态转移方程 同样基于pop_count()函数 \[ P(x) = P(x/2) + (x\ mod\ 2) \] 我的理解 同理2解法，由最高有效位，想到最低有效位： 实现 1234567891011121314class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; vi(num+1); int i = 1; for ( ; i &lt; num + 1; ++i) &#123; vi[i] = vi[i/2] + (i % 2); &#125; return vi; &#125;&#125;; 这里官方解，利用了位运算来代替已有的/和%运算： x &gt;&gt; 1 &lt;=&gt; x / 2 x &amp; 1 &lt;=&gt; x % 2 12345678public class Solution &#123; public int[] countBits(int num) &#123; int[] ans = new int[num + 1]; for (int i = 1; i &lt;= num; ++i) ans[i] = ans[i &gt;&gt; 1] + (i &amp; 1); // x / 2 is x &gt;&gt; 1 and x % 2 is x &amp; 1 return ans; &#125;&#125; 4.动态规划 + 最后设置位 状态转移方程 同样基于pop_count()函数 \[ P(x) = P(x\ \&amp;\ (x-1)) + 1 \] 我的理解 利用位运算x &amp; (x-1)消除最右边的一位“1”， 使得 x 比 x &amp; (x-1) 少一位“1”， 加上这个“1”即可. 实现 12345678910111213class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; vi(num+1); for (int i = 1; i &lt; num + 1; ++i) &#123; vi[i] = vi[i &amp; (i - 1)] + 1; &#125; return vi; &#125;&#125;; 官方解： 12345678public class Solution &#123; public int[] countBits(int num) &#123; int[] ans = new int[num + 1]; for (int i = 1; i &lt;= num; ++i) ans[i] = ans[i &amp; (i - 1)] + 1; return ans; &#125;&#125; 总结 简单DP，注意定义好状态，写出状态转移方程，然后注意corner case。写成代码即可。 注意涉及到 2进制， 全0 1 的数字， 非负整数, unsigned, size_t, size_type等等， 往位运算上面想。 总结这里的位运算操作，之后考虑全部总结下常见位运算操作, 我记得耗子有篇文章总结了很多这方面的。 x &amp; (x - 1) 消除 x 的最右边的一位1. (PS: 这一个确实不熟悉，虽然也见过) x &lt;&lt; 2 &lt;=&gt; x * 2 x &gt;&gt; 2 &lt;=&gt; x / 2 x &amp; 1 &lt;=&gt; x % 2 (PS：那篇文章link找不到了) Reference leetcode官方解答 Large braces for specifying values of variables by condition Extended knowledge std::bitset::bitset in cppreference How to print (using cout) a number in binary form? default initialization lifetime Why does c++ initialise a std::vector with zeros, but not a std::array?]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小结及之后]]></title>
    <url>%2F2019%2F10%2F23%2F%E5%B0%8F%E7%BB%93%E5%8F%8A%E4%B9%8B%E5%90%8E%2F</url>
    <content type="text"><![CDATA[小结 之前都去打了些结构化数据的比赛，也补了不少基础知识，尽管没有按当初的计划来。 尽管我觉得目前取得成绩不太够用吧，总结下有： 上海电信“添翼杯”成绩预测20名（吐槽下这破比赛结束，官网就没了？？？） kaggle Instant Gratification solo铜牌 19讯飞反欺诈，初赛第8，复赛a榜14，b榜24 DataCastle 国能日新光伏预测功率第二届第6名 多多少少打了些咸鱼成绩出来。 最惨的还是讯飞，基本上2-3个月天天熬。初赛最后分数还算不错，到了复赛因为数据量太大，导致CatBoost在Shrink Model的时候峰值占用的内存会高到至少100g+和租的辣鸡DBC服务器疯狂卡结果，最后几天把我队的两个模型结果卡住没出来了。以及top3的选手开源了一个高分代码，上分操作与我队有一些重合，拉高了复赛线。 暂时有空抽时间把前面两篇坑了的博客补了，Data Science/ Machine Learning这块考虑暂时就放一段时间了。 之后？ 开始刷leetcode和补一些以前干的后台开发相关的活了。 刷下Cpp reference啥啥的，把一些忘了的Cpp相关的东西捡起来； 每天至少龟系刷题1道，先从dp刷起来。1~2个月之后再考虑兔系刷题； 补下APUE那套东西，以前碰过，现在忘了不少； 接触下NoSQL，Redis这套； PS: 以后写博客就不会那么详细，主要还是自己理解，留下一步一个脚印。 PPS： 至于比赛还打不打，看时间够不够吧，能支撑自己走下去的只有求生欲了。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在调用folds-split进行交叉检验时，使用tqdm记录每折时间]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%9C%A8%E8%B0%83%E7%94%A8folds-split%E8%BF%9B%E8%A1%8C%E4%BA%A4%E5%8F%89%E6%A3%80%E9%AA%8C%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8tqdm%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%8A%98%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA['如何将相对unix初始时间的时间差转换为当前时间轴']]></title>
    <url>%2F2019%2F07%2F01%2F%E5%A6%82%E4%BD%95%E5%B0%86%E7%9B%B8%E5%AF%B9unix%E5%88%9D%E5%A7%8B%E6%97%B6%E9%97%B4%E7%9A%84%E6%97%B6%E9%97%B4%E5%B7%AE%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[内存不够时，替代sns.countplot()的实现方法]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%86%85%E5%AD%98%E4%B8%8D%E5%A4%9F%E6%97%B6%EF%BC%8C%E6%9B%BF%E4%BB%A3sns-countplot-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[内存不够时，替代sns.countplot()的实现方法 最近做EDA的的时候会存在这样一种情况，数据量过大时，直接使用sns.countplot()内存很容易直接被榨干掉。 暂时没想清为什么会直接占用那么多内存，应该去StackOverflow提个Q的。 不过想了下又查了下StackOverflow，应该有用df.value_counts() 和 matplotlib来实现sns.countplot()的实现方法，如此，What is Matplotlib's alternative for countplot from seaborn? 引用自StackOverflow，ImportanceOfBeingErnest Say you have this data: 123456import numpy as np; np.random.seed(42)import pandas as pdimport matplotlib.pyplot as pltdf = pd.DataFrame(&#123;"Sex" : np.random.choice(["male", "female"], size=1310, p=[.65, .35]), "other" : np.random.randint(0,80, size=1310)&#125;) You can plot a countplot in seaborn as 123import seaborn as snssns.countplot(x="Sex", data=df)plt.show() Or you can create a bar plot in pandas 12df["Sex"].value_counts().plot.bar()plt.show() Or you can create a bar plot in matplotlib 123counts = df["Sex"].value_counts()plt.bar(counts.index, counts.values)plt.show() Reference What is Matplotlib's alternative for countplot from seaborn? Pandas:Visualization Guide]]></content>
      <categories>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>code snippet</tag>
        <tag>data visualization</tag>
        <tag>matplotlib</tag>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何指定xtick在一个特定的范围]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9Axtick%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E7%9A%84%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[在做EDA的时候，会有种情况，时序数据所做的plot的x-axis会存在过于密集的情况，如下 所以我们要做的就是只用将数据所在范围按一定频率切分开就行了，如这个Q，[how to change the xticks to a specific range [duplicate\]](https://stackoverflow.com/questions/56713197/how-to-change-the-xticks-to-a-specific-range) 和 Changing the “tick frequency” on x or y axis in matplotlib? 分别引用自StackOverflow用户 Heike和Alexandre B.并作出了一定修改。 在comment和answer处提供了两种解决方案： 添加一行代码plt.xticks(range(9, 40, 10), range(10, 41, 10)) 这里第一个参数是是将xtick分块显示，第二个参数是各个分块处显示的数字.(这里原来的数据找不到了，就用了answer中随机生成的数据为例子). 例子: 1234567891011# Your data to county = np.random.randint(0,41,1000)# Create plotfig, ax = plt.subplots()sns.countplot(y)# Show graphplt.xticks(range(0, 41, 10), range(0, 41, 10))plt.xlabel('user_id')plt.show() 但是假如将第一个参数设置的分块范围超过数据已有的范围，则会在plot超出数据已有范围处显示出一段blank。 One way is to define the labels on the x-axis. The set_xticklabels method from matplotlibmodule do the job (doc). By defining your own labels, you can hide them by setting the label equal to ''. By defining your own labels, you need to take care that they are still consistent with your data. Here is one example: 123456789101112131415161718192021222324252627# import modulesimport numpy as npimport seaborn as snsimport matplotlib.pyplot as plt#Init seabornsns.set()# Your data to county = np.random.randint(0,41,1000)# Create the new x-axis labels x_labels = ['' if i%10 != 0 else str(i) for i in range(len(np.unique(y)))]print(x_labels)# ['0', '', '', '', '', '', '', '', '', '', # '10', '', '', '', '', '', '', '', '', '', # '20', '', '', '', '', '', '', '', '', '', # '30', '', '', '', '', '', '', '', '', '', '40']# Create plotfig, ax = plt.subplots()sns.countplot(y)# Set the new x axis labelsax.set_xticklabels(x_labels)# Show graphplt.show() Reference [how to change the xticks to a specific range [duplicate\]](https://stackoverflow.com/questions/56713197/how-to-change-the-xticks-to-a-specific-range) Changing the “tick frequency” on x or y axis in matplotlib? matplotlib.axes.Axes.set_xticklabels]]></content>
      <categories>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>code snippet</tag>
        <tag>EDA</tag>
        <tag>pandas</tag>
        <tag>data disualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将DataFrame中的数据以表格的形式另存为图片]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%B0%86DataFrame%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A5%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8F%A6%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[将DataFrame中的数据以表格的形式另存为图片 在上次按序输出关联矩阵的blog中有了将DataFrame中的数据以表格形式另存储为图片的想法。 起初，Google了在StackOverflow上找到了相关问题，并将代码修改应用于Titanic的数据上，具体如下： 12345678910from pandas.plotting import tablefig = plt.figure(figsize=(5, 6))ax = fig.add_subplot(111, frame_on=False) # no visible frameax.xaxis.set_visible(False) # hide the x axisax.yaxis.set_visible(False) # hide the y axistable(ax, train_corr, loc='center') # where df is your data frameplt.savefig('correlation_matrix_vague.jpg') This is a vague pic 但是，发现另存为的图片极为模糊，再思考并查询相关文档未果后，并在StackOverflow上提出了相关问题，发现是因为没有设置合适的dpi参数，故设置合适的dpi参数并修改代码如下： 12345678910from pandas.plotting import tablefig = plt.figure(figsize=(5, 6), dpi=1400)ax = fig.add_subplot(111, frame_on=False) # no visible frameax.xaxis.set_visible(False) # hide the x axisax.yaxis.set_visible(False) # hide the y axistable(ax, train_corr, loc='center') # where df is your data frameplt.savefig('correlation_matrix_HD.jpg') Reference 在matplotlib的一个figure中画多个subplots How to save a pandas DataFrame table as a png Titanic in Kaggle How to make picture clear when saving the table of DataFrame as a picture Relationship between dpi and figure size pandas.plotting matplotlib.pyplot.table]]></content>
      <categories>
        <category>Pandas</category>
      </categories>
      <tags>
        <tag>pandas</tag>
        <tag>matplotlib</tag>
        <tag>seaborn</tag>
        <tag>Code Snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以DataFrame的形式按序输出关联矩阵(correlation matrix)]]></title>
    <url>%2F2019%2F04%2F23%2F%E4%BB%A5DataFrame%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8C%89%E5%BA%8F%E8%BE%93%E5%87%BA%E5%85%B3%E8%81%94%E7%9F%A9%E9%98%B5(correlation%20matrix)%2F</url>
    <content type="text"><![CDATA[以DataFrame的形式按序输出关联矩阵(correlation matrix) 一般来说在做EDA的时候，我们都是输出相关矩阵的热力图或者是以表格形式输出。 但是我在Stantar 2019的一个kernel见到了按序输出关联矩阵系数的代码，故在此基础上进行了一定修改，实现了一个自己的code snippet. 具体例子见下：(此处数据采用Titanic in Kaggle) 12train_corr = train_df.drop(['PassengerId'], axis=1).corr()train_corr 123# 设置热力图尺寸为(20, 12)plt.subplots(figsize=(20, 12))sns.heatmap(train_corr, vmin=-1, vmax=1, annot=True, square=True) 123corr = train_corr.abs().unstack().sort_values(kind='quicksort', ascending=False).reset_index()corr = corr[(corr['level_0'] != corr['level_1']) &amp; (corr['level_0'] == 'Survived')]corr 一般是设置ascending参数，来看你是想要按序输出高或低相关度. 这里feature数量比较少，故直接输出，一般是corr调用tail()或者head()来输出该顺序中的后或前几个相关系数。例如： 1corr.tail(4) 下一篇会在再讲下，如何将Pandas.DataFrame的表格存储为图片，这也是在写这篇blog过程中的一点idea的实现. Reference Titanic in Kaggle 按序输出correlation matrix出处 Pandas.DataFrame.unstack Pandas.DataFrame.reset_index]]></content>
      <categories>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>code snippet</tag>
        <tag>EDA</tag>
        <tag>pandas</tag>
        <tag>data disualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在matplotlib的一个figure中画多个subplots]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%9C%A8matplotlib%E7%9A%84%E4%B8%80%E4%B8%AAfigure%E4%B8%AD%E7%94%BB%E5%A4%9A%E4%B8%AAsubplots%2F</url>
    <content type="text"><![CDATA[在一个figure中画多个subplots 在做EDA和Data Visualization中常常会用到的一个code snippet,在这里以kaggle上的titianic数据为例子: 12345# 先导入packagesimport pandas as pdimport matplotlib.pyplot as plt%matplotlib inlineimport seaborn as sns 1234567891011121314151617181920# 导入数据# path需根据具体环境作调节path = 'input'train_df = pd.read_csv(''.join([path, '/train.csv']))test_df = pd.read_csv(''.join([path, '/test.csv']))gender_sub_df = pd.read_csv(''.join([path, '/gender_submission.csv']))# 以Survived特征为例子fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2)# ax1sns.countplot(train_df['Survived'], ax=ax1)# ax2# autopct参数是用来显示饼图上百分比的ax2.pie(train_df['Survived'].value_counts(), autopct='%1.1f%%')# set_aspect('equal')是为了让饼图成圆形(circle)而不是椭圆(ellipse， oval)ax2.set_aspect('equal')plt.set_xlabel('Survived') 其中部分代码也可重写为如下： 123456789fig, ax = plt.subplots(nrows=1, ncols=2)# ax1sns.countplot(train_df['Survived'], ax=ax[0])# ax2ax[1].pie(train_df['Survived'].value_counts(), autopct='%1.1f%%')ax[1].set_aspect('equal')plt.set_xlabel('Survived') 也可以根据修改nrows, ncols参数来适用多行多列的情况：(这里举得这个例子只是为了举例而举例，没有过多实际意义) 1234567891011121314151617fig, ax = plt.subplots(nrows=2, ncols=2)# ax[0, 0]sns.countplot(train_df['Survived'], ax=ax[0, 0])# ax[0, 1]ax[0, 1].pie(train_df['Survived'].value_counts(), autopct='%1.1f%%')ax[0, 1].set_aspect('equal')ax[0, 1].set_xlabel('Survived')# ax[1, 0]sns.countplot(train_df['Pclass'], ax=ax[1, 0])# ax[1, 1]ax[1, 1].pie(train_df['Pclass'].value_counts(), autopct='%1.1f%%')ax[1, 1].set_aspect('equal')ax[1, 1].set_xlabel('Pclass') four_subplots_in_one_figure 当然也可以用循环来实现，在此不对这举例了。 中间还有2个小插曲，就是我实现的时候，发现ax[0, 0]的subplot没有x_label,所以还去StackOverflow上面提了个Question，发现仅仅是被hidden住了，加上一行plt.tight_layer()代码即可。 12345678910111213141516171819fig, ax = plt.subplots(nrows=2, ncols=2)# ax[0, 0]sns.countplot(train_df['Survived'], ax=ax[0, 0])# ax[0, 1]ax[0, 1].pie(train_df['Survived'].value_counts(), autopct='%1.1f%%')ax[0, 1].set_aspect('equal')ax[0, 1].set_xlabel('Survived')# ax[1, 0]sns.countplot(train_df['Pclass'], ax=ax[1, 0])# ax[1, 1]ax[1, 1].pie(train_df['Pclass'].value_counts(), autopct='%1.1f%%')ax[1, 1].set_aspect('equal')ax[1, 1].set_xlabel('Pclass')plt.tight_layout(h_pad=1) four_subplots_in_one_figure_plt_tight_layout 还有就是hexo插图片时，若用markdown语法，说是文章在首页无法显示图片，点进去后仍可，所以只可采用最好用标签插件语法来实现，例如： Reference Titanic in Kaggle why-is-matplotlib-plotting-my-circles-as-ovals how-to-set-the-labels-size-on-a-pie-chart-in-python set-xlabel-is-in-invalid-in-ax0-0-when-drawing-4-subplots-in-one-plot How-to-insert-image-in-hexo-post]]></content>
      <categories>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>code snippet</tag>
        <tag>EDA</tag>
        <tag>data visualization</tag>
        <tag>matplotlib</tag>
        <tag>seaborn</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stantar 2019有感]]></title>
    <url>%2F2019%2F04%2F22%2FStantar-2019%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[Stantar 2019有感 看了很多个top solution，尤其是金牌区域的。 给我感觉在这个比赛中的几个重要的magic有： frequency coding；在对于匿名数据或者categorical feature上，可以先试着这样做下，一般是会提升local CV之类； fake data；对于training set和testing set中的unique value的数量明显不同，让人怀疑testing set中的数据包含伪造数据。对于testing set中的伪造数据进行删除即可。List of Fake Samples and Public/Private LB split independent feature；利用feature间的相互独立性，在用LightGBM训练时，只对某一特征训练，故有200个lgb classifier再对预测结果进行简单的simple linear blending。a single model using all features vstacked that is enough for a top20 on Private 感受颇深的是对于这些magic，一是自己确实没有通过EDA来发现到，能力有限；二是其实在kernel和discussion中都有多多少少提及到，自己未引起重视又或者不知如何是好。 个人主要感觉还是： 在EDA方面考虑得不够到位，而且可以利用： Local CV和LB的提升上差异来分析是哪里的问题，然后解决并使得Local CV和LB的提升近似。比如此次中，一开始无论local CV提升有多高，LB都会锁在9.001上。而解决到fake data的存在后，local CV提升，LB也会随之提升，使得LB锁在9.001的情况不复存在； 可以根据kernel和discussion区域中，若在新的发布后，上的存在着许多人的大幅度增长，则说明某个kernel或discussion揭露了magic； Model这一块也是有问题，很明显在NN上存在很多问题，尤其是现在去看top solution中开源的NN代码，会存在很多逻辑看不太懂的情况； Parameter Tuning上面也有问题，除了最基本的Grid Search和Random Search外，对于Bayesian optimization没有理解且无法应用出来。Chris这个discussion给了很多inspirations； 对于Data Science这块Coding能力上也存在着问题，不能很流畅的阅读代码逻辑； 这个比赛没有用到Feature Selection, 然而这块也是我的弱项； 在最后如何选取2个the most robust model用于提交到PB上也仍未解决。 不过感觉还是收获了不少，在我上述几方面加强后，还是需要回来reiview Stantar这个比赛的各个solution。 Reference Gold Medal Solutions of Stantar 2019 List of Fake Samples and Public/Private LB split Giba: a single model using all features vstacked that is enough for a top20 on Private Chirs: How do we optimize GBM hyperparameters?]]></content>
      <categories>
        <category>data competition</category>
      </categories>
      <tags>
        <tag>kaggle</tag>
        <tag>data competition</tag>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些学习计划]]></title>
    <url>%2F2019%2F04%2F11%2F%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[学习计划 reivew知识，夯实基础。按着sklearn中User Guide中的6个模块来review一遍文档和其中涉及到的相关知识。不过不会以完整的罗列出来全部内容的形式来做，这样就不符合DRY原则了(笑)，只打算列出各个API中涉及到的不熟悉的知识点的相关知识，又或者是相关链接，自己做一定的归纳总结。 具体来说就是： 理论知识上，在学习到一定程度下，留下学习到的相关链接，总结自己的理解； 代码实现上，在完全不熟悉或者理解不够透彻的情况下，需进行一定量的coding(暂不打算开源)； 主要方向上，主要围绕Supervised Learning, Model selection and evaluation, Dataset transformations, Unsupervised Learning这4个模块进行，除此之外对于XGBoost, LightGBM, CatBoost等Kaggle常见模型进行复习。 估计耗时：1个半月-2个月 继续实战。 具体目标有： 完成对Stantar customer transaction prediction 2019的kernel和discussion的学习，并在别人给出的hints下，自己实现一个top 1 % kernel并开源出来。 在Don't Overfit 和TMDB Box Office Prediction 两个Plaground competition中争取进去Sliver Zone，并在Don't Overfit 结束并学习完后赶紧进入Jigsaw和Earthquake的两个比赛中去。 review Matplotlib和seaborn两个package，根据Kaggle开源kernel熟悉可视化部分。之前这块太弱了，严重影响了EDA的能力。 review Numpy和Pandas两个package，加强数据处理的能力。 估计耗时： 10-15天 持续2个月+ 15-20天 10-15天 Book Reading&amp;Thesis Learing 具体目标有： reivew线代(之前被搁置过)。把UTM-Applied-Linear-Algebra-and-Matrix-Analysis这本书剩下的地方内容+课后带答案的题仔细刷一遍(之前搁置到50%)； 开PRML/ESL/MLAPP的坑。 开Boyd的凸优化的坑。 开NLP的坑。 开Stanford ML相关公开课的坑 估计耗时：2-3天一节，争取1.5个月内review完UTM这本线代书，再考虑开什么坑比较合适... 将这些任务同时进行，争取2个月之内完成这些目标，中间老板可能会有各种任务，最多不要拖过2周。在大部分结束前1-2周，会定制新的计划。]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂谈-为什么要搭一个blog]]></title>
    <url>%2F2019%2F04%2F11%2F%E6%9D%82%E8%B0%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%90%AD%E4%B8%80%E4%B8%AAblog%2F</url>
    <content type="text"><![CDATA[为什么以前不搭一个blog？ 先谈谈为什么一起没这么个念头，主要有以下几点： 不想写些看上去很厉害其实没什么用的东西。 不想写些拾人牙慧的东西。 不想写些随便Google两下，或者看看两眼官方文档就能搞懂的东西。 写blog组织语言起来其实很费时。 而在有的网站上充斥着大量的这类内容，当然不是说没有“金子”在其中，只不过都被“垃圾”掩埋住了，所以在我觉得我不能输出一份没有任何错误的干货下，并不打算输出自己的知识。 为什么现在又搭了一个自己的blog呢？ 无论是学业，还是生活都遭遇了很多糟心事，总得来说以下几个原因： 学习状态一直受挫，到现在为止都很难维持住我以前的最佳状态(每天8-10小时有效学习时间)。导致有些东西学了查，查了用，用了忘，忘了又查的循环之中，低效率甚至无效率学习时间过多。我得找个地方记住这些常常需要review的问题。 刚参加的一场Kaggle比赛，最后比赛结束，结果从Public LB top 7%跌到Private LB top15%。很受打击，感觉自己学的东西很不扎实。用荀子《劝学》中的一句话来说就是“蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。”。我得沉下心来，所以我决定找个地方记录下这个过程。 常常写blog，可以刷下GitHub的contributions次数，让生活充满绿色(笑)，通过这个激励自己。 所以呢？ 所以，可能我大概率可能在未来会输出一些我曾认为的“垃圾“。 Never mind, it's my turn to cut food.]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
