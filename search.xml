<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode题解-326-3的幂]]></title>
    <url>%2F2019%2F12%2F02%2Fleetcode%E9%A2%98%E8%A7%A3-326-3%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[题目 我只会第一种循环迭代，后面3种方法均出自leetcode官方题解。 1. 循环迭代 12345678910111213class Solution &#123;public: bool isPowerOfThree(int n) &#123; if (n &lt; 1) return false; while (n % 3 == 0) &#123; n /= 3; &#125; return n == 1; &#125;&#125;; 时间: \(O(log_b(n))\) 空间: \(O(1)\) 2. 基准转换 将所有的数转化为以3为基数的数字。 12345public class Solution &#123; public boolean isPowerOfThree(int n) &#123; return Integer.toString(n, 3).matches("^10*$"); &#125;&#125; 时间: \(O(log_3n)\) 空间: \(O(log_3n)\) 3. 运算法 \[ n = 3^i i = log_3(n)i = \frac{log_b(n)}{log_b(3)} \] 12345public class Solution &#123; public boolean isPowerOfThree(int n) &#123; return (Math.log10(n) / Math.log10(3)) % 1 == 0; &#125;&#125; 为了解决精度错误，应该设置一个较小的epsilon 1return (Math.log(n) / Math.log(3) + epsilon) % 1 &lt;= 2 * epsilon; 4. 整数限制 在Java中，该变量是4个byte，则最大值为\(\frac{2^{32}}{2} - 1 = 2147483647\)，并得到最大的3的幂为\(3^{19} = 1162251467\). 若n是3的幂，则$ 3^{19} % n == 0$必成立 12345public class Solution &#123; public boolean isPowerOfThree(int n) &#123; return n &gt; 0 &amp;&amp; 1162261467 % n == 0; &#125;&#125; 时间: \(O(1 )\) 空间: \(O( 1)\) References https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode/]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>×</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-231-2的幂]]></title>
    <url>%2F2019%2F12%2F02%2Fleetcode%E9%A2%98%E8%A7%A3-231-2%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[题目 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; !(n&amp;(n-1)); &#125;&#125;; 考虑： num &gt; 0时，才会是一个数的幂。负数和0不会是一个正整数的幂。 !(num&amp;(num-1))时，用来判断num是不是2的幂， 因为一个数是2的幂的话，则它2进制的第一位必然是1，与num-1与运算后，结果必然为0 Reference https://leetcode-cn.com/problems/power-of-four/solution/e-you-shi-yi-dao-zhuang-bi-jie-fa-de-suan-fa-ti-2/ https://www.geeksforgeeks.org/program-to-find-whether-a-no-is-power-of-two/]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>×</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-324-4的幂]]></title>
    <url>%2F2019%2F12%2F02%2Fleetcode%E9%A2%98%E8%A7%A3-324-4%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[题目 非位运算解： 12345678910111213141516171819202122class Solution &#123;public: bool isPowerOfFour(int num) &#123; if (num == 0) return false; int mod; while (num != 1) &#123; mod = num % 4; num /= 4; if (mod != 0) &#123; return false; &#125; &#125; return true; &#125;&#125;; 位运算： 123456class Solution &#123;public: bool isPowerOfFour(int num) &#123; return num &gt; 0 &amp;&amp; !(num&amp;(num-1)) &amp;&amp; !(num &amp; 0xAAAAAAAA); &#125;&#125;; 考虑： num &gt; 0时，才会是一个数的幂。负数和0不会是一个正整数的幂。 !(num&amp;(num-1))时，用来判断num是不是2的幂， 因为一个数是2的幂的话，则它2进制的第一位必然是1，与num-1与运算后，结果必然为0 !(num &amp; 0xAAAAAAAA), 用来判断num是不是4的幂， 因为一个数是4的幂的话，则它2进制必然第一位是1且第一位是奇数位，0xA=1010，则4的幂与其求与运算后，则为0，求反得1 总结 位运算小技巧： !(n&amp;(n-1))，用于判断n是不是2的幂 !(num&amp;(num-1)) &amp;&amp; !(num &amp; 0xAAAAAAAA), 用于判断n是不是4的幂 对于n的幂，可以先枚举一定的例子，然后对枚举结果进行归纳找到规律。 Reference https://leetcode-cn.com/problems/power-of-four/solution/e-you-shi-yi-dao-zhuang-bi-jie-fa-de-suan-fa-ti-2/ https://www.geeksforgeeks.org/program-to-find-whether-a-no-is-power-of-two/ https://www.geeksforgeeks.org/find-whether-a-given-number-is-a-power-of-4-or-not/]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>×</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题.md]]></title>
    <url>%2F2019%2F11%2F29%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-md%2F</url>
    <content type="text"><![CDATA[背包问题总共有9种，称为背包9讲。 01背包问题 完全背包问题 多重背包问题 混合背包问题 二维费用的背包问题 分组背包问题 背包问题求方案数 求背包问题的方案 有依赖的背包问题 有\(N\)件物品和一个容量是\(V\)的背包。 不同背包问题的条件：每件物品只能使用一次。 第\(i\)件物品的体积是 \(v_i\)，价值是 \(w_i\)。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行两个整数，\(N, V\)用空格隔开，分别表示物品数量和背包容积。 接下来有 \(N\) 行，每行两个整数 \(v_i, w_i\)，用空格隔开，分别表示第 \(i\) 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 \(0&lt;N,V≤10000\) \(0&lt;v_i,w_i≤10000\) 输入样例 123454 51 22 43 44 5 输出样例： 18 01背包问题 题目描述 有\(N\)件物品和一个容量是\(V\)的背包。 每件物品只能使用一次。 第\(i\)件物品的体积是 \(v_i\)，价值是 \(w_i\)。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行两个整数，\(N, V\)用空格隔开，分别表示物品数量和背包容积。 接下来有 \(N\) 行，每行两个整数 \(v_i, w_i\)，用空格隔开，分别表示第 \(i\) 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 \(0&lt;N,V≤10000\) \(0&lt;v_i,w_i≤10000\) 输入样例 123454 51 22 43 44 5 输出样例： 18 解 状态： 状态\(f[i][j]\)表示前\(i\)个物品的总体积\(j\)下，总价值为\(f[i][j]\). \(result = f[i][j]\) 初始状态：\(f[0][0] = 0\) 终止状态：\(f[n][m]\) 状态转移方程： 考虑第\(i\)个状态和\(i-1\)个状态间的递推关系: 不选第\(i\)个物品，\(f[i][j] = f[i-1][j]\) 选第\(i\)个物品，\(f[i][j] = f[i-1][j-v[i]] + w[i]\) \(f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+ w[i])\) 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int f[N][N];int V[N], w[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= m; ++j) &#123; f[i][j] = f[i-1][j]; if (j &gt;= m) &#123; f[i][j] = max(f[i][j], f[i-1][j-v[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125; 因为状态\(i\)每次都仅依赖状态\(i-1\)，故可以优化额外空间复杂度为\(O(logN)\) 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt;; for (int i = 0; i &lt; n; ++i) &#123; int v, w; cin &gt;&gt; v &gt;&gt; w; for (int j = m; j &gt;=v; ++j) &#123; f[j] = max(f[j], f[j-v] + w); &#125; &#125; cout &lt;&lt; f[n] &lt;&lt; endl; return 0;&#125; 完全背包问题 有\(N\)件物品和一个容量是\(V\)的背包。 每件物品都有无限件可用。 第\(i\)件物品的体积是 \(v_i\)，价值是 \(w_i\)。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行两个整数，\(N, V\)用空格隔开，分别表示物品数量和背包容积。 接下来有 \(N\) 行，每行两个整数 \(v_i, w_i\)，用空格隔开，分别表示第 \(i\) 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 \(0&lt;N,V≤10000\) \(0&lt;v_i,w_i≤10000\) 输入样例 123454 51 22 43 44 5 输出样例： 110 解： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) &#123; int v, w; cin &gt;&gt; v &gt;&gt; w; // 要累加每一次的结果 for (int j = v; j &lt;= m; ++j) &#123; f[j] = max(f[j], f[j-v] + w); &#125; &#125; cout &lt;&lt; f[m]; return 0;&#125; 从代码上看就是，把 01背包 的代码的二重循环，由重后往前遍历，改成了重前往后遍历。 从状态转移方程上来看，通过二维DP表的形式: \(f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+ w[i])\) \(max(不选第i个物品，\ 选了第i个物品)\) \(if\ j-v[i]*k &lt;= 0 \\f[i][j] = max(f[i-1][j], f[i][j-v[i]]+ w[i], f[i][j-v[i]*2]+w[i]*2+...)\) \(max(不选第i个物品，\ 选了第i个物品1次, \ 选了第i个物品2次, ...)\) 现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v= 0..V的顺序循环。 或者由这个2维动态转移方程得来。 混合背包问题 References https://www.cnblogs.com/jbelial/articles/2116074.html https://www.bilibili.com/video/av33930433?p=1]]></content>
      <tags>
        <tag>DP</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-264-丑数Ⅱ]]></title>
    <url>%2F2019%2F11%2F27%2Fleetcode%E9%A2%98%E8%A7%A3-264-%E4%B8%91%E6%95%B0%E2%85%A1%2F</url>
    <content type="text"><![CDATA[题目 用STL实现小根堆 按理说应该实现些其它功能，比如： vecotor中是否包含multiple elements 堆的一些常用功能，如：heapify 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int nthUglyNumber(long n) &#123; vector&lt;long&gt; vi = &#123;1&#125;; make_heap(vi.begin(), vi.end(), greater&lt;&gt;()); long top; for (long i = 0; i &lt; n; ++i) &#123; pop_heap(vi.begin(), vi.end(), greater&lt;&gt;()); top = vi.back(); vi.pop_back(); if (find(vi.begin(), vi.end(), top*2) == vi.end()) &#123; vi.push_back(top*2); &#125; if (find(vi.begin(), vi.end(), top*3) == vi.end()) &#123; vi.push_back(top*3); &#125; if (find(vi.begin(), vi.end(), top*5) == vi.end()) &#123; vi.push_back(top*5); &#125; make_heap(vi.begin(), vi.end(), greater&lt;&gt;()); &#125; return top; &#125;&#125;; 实际上效率低了，因为用原生的make_heap需要重新构造一次堆，但是用heapify这种调整堆结构会快很多。 DP实现 状态转移方程： \[ dp[i] = min(2*dp[l_2], 3*dp[l_3], 5*dp[l_5]) \] 1234567891011121314151617181920212223242526272829class Solution &#123;public: int nthUglyNumber(long n) &#123; vector&lt;long&gt; dp(n+1); dp[1] = 1; long l2 = 1, l3 = 1, l5 = 1; for (long i = 2; i &lt;= n; ++i) &#123; dp[i] = min(2*dp[l2], min(3*dp[l3], 5*dp[l5])); if (dp[i] &gt;= 2*dp[l2]) &#123; l2 += 1; &#125; if (dp[i] &gt;= 3*dp[l3]) &#123; l3 += 1; &#125; if (dp[i] &gt;= 5*dp[l5]) &#123; l5 += 1; &#125; &#125; return dp[n]; &#125;&#125;; Reference powcai解]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-204-计数质数]]></title>
    <url>%2F2019%2F11%2F27%2Fleetcode%E9%A2%98%E8%A7%A3-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目 最佳思路，Sieve of Eratosthenes 又或者叫 数筛 12345678910111213141516class Solution &#123; public int countPrimes(int n) &#123; boolean[] isPrim = new boolean[n]; Arrays.fill(isPrim, true); for (int i = 2; i * i &lt; n; i++) if (isPrim[i]) for (int j = i * i; j &lt; n; j += i) isPrim[j] = false; int count = 0; for (int i = 2; i &lt; n; i++) if (isPrim[i]) count++; return count; &#125;&#125; C++实现 1234567891011121314151617181920212223242526class Solution &#123; public int countPrimes(int n) &#123; bool isPrime[n]; memset(isPrime, true, sizeof(isPrime)); for (int i = 2; i*i &lt; n; ++i) &#123; if(isPrime[i]) &#123; for (int j = i*i; j &lt; n; j += i) &#123; isPrim[j] = false; &#125; &#125; &#125; int count = 0; for (int i = 2; i &lt; n; ++i) &#123; if (isPrime[i]) ++count; &#125; return count; &#125;&#125; 总结 质数的判断上的条件优化 只用判断到\(\sqrt{n}\)即可，我之前都是判断到\(n/2\) 我对于数筛法的理解是： 一种 记忆化搜索， 减少了重复子过程的计算。 非质数 = 质数 * 质数 非质数 = 非质数 * 非质数/质数 References labuladong 解]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-263-丑数]]></title>
    <url>%2F2019%2F11%2F27%2Fleetcode%E9%A2%98%E8%A7%A3-263-%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool isUgly(int num) &#123; while (num != 1) &#123; int ori = num; if (num % 2 == 0) &#123; num /= 2; &#125; if (num % 3 == 0) &#123; num /= 3; &#125; if (num % 5 == 0) &#123; num /= 5; &#125; if (ori == num) &#123; return false; &#125; &#125; return true; &#125;&#125;; 思路： 丑数： 因数包括 1，2， 3， 5的数。 所以考虑 非丑数 的2种情况： 除了1，2，3，5的质数 因数除了 1，2，3，5外，还有质数的非质数 模2， 3，5后，这个数还是原来的值 =&gt; 非丑数 模2， 3，5后，这个数为1 =&gt; 丑数 模2， 3，5后，这个数为一个不为1的数，继续模2，3，5，直至出现上面两种情况。 总结 数学题，考虑找规律，找补集思考 质数 常涉及到 \(/, \%\)运算？]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>×</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-202-快乐数]]></title>
    <url>%2F2019%2F11%2F27%2Fleetcode%E9%A2%98%E8%A7%A3-202-%E5%BF%AB%E4%B9%90%E6%95%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-1155-掷骰子的N种方法]]></title>
    <url>%2F2019%2F11%2F21%2Fleetcode%E9%A2%98%E8%A7%A3-1155-%E6%8E%B7%E9%AA%B0%E5%AD%90%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int numRollsToTarget(int d, int f, int target) &#123; if (d &lt; 1 || f &lt; 1 || target &lt; 1 || target &gt; d*f) &#123; return 0; &#125; // 1. int MOD = 1000000007; // 2. int MIN = min(f, target); // 3. int MAX = d*f; vector&lt;vector&lt;int&gt;&gt; dp(d+1, vector&lt;int&gt;(MAX+1, 0)); for (int j = 1; j &lt;= MIN; ++j) &#123; dp[1][j] = 1; &#125; for (int i = 2; i &lt;= d; ++i) &#123; // 因为每个筛子至少丢出来的值是 &gt;=1 的 for (int j = i; j &lt;= MAX; ++j) &#123; for (int k = 1; j - k &gt;= 0 &amp;&amp; k &lt;= f; ++k) &#123; dp[i][j] = (dp[i][j] + dp[i-1][j-k]) % MOD; &#125; &#125; &#125; return dp[d][target]; &#125;&#125;;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-403-青蛙过河]]></title>
    <url>%2F2019%2F11%2F14%2Fleetcode%E9%A2%98%E8%A7%A3-403-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3%2F</url>
    <content type="text"><![CDATA[题目 My way 1.暴力解 12345678910111213141516171819202122232425class Solution &#123;public: bool canCross(vector&lt;int&gt;&amp; stones) &#123; return helper(stones, 0, 0); &#125; bool helper(const vector&lt;int&gt;&amp; stones, int curPos, int jumpSize) &#123; for (int nextPos = curPos+1; nextPos &lt; stones.size(); ++nextPos) &#123; // gap值表示curPos位置 跳到 i位置 的跳跃距离 int gap = stones[nextPos] - stones[curPos]; if (gap &gt;= jumpSize - 1 &amp;&amp; gap &lt;= jumpSize + 1) &#123; // 能跳到i位置，则递归下去 if (helper(stones, nextPos, gap)) &#123; return true; &#125; &#125; &#125; return curPos == stones.size() - 1; &#125;&#125;; 2. 记忆化搜索 利用暴力解的递归关系，使用一个数组提前存储好对应的值，然后查询的时候遇到已有的结果则提前跳出。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; bool helper(const vector&lt;int&gt;&amp; stones, int curPos, int jumpSize, vector&lt;vector&lt;int&gt;&gt;&amp; mem) &#123; // 已有的计算结果则提前跳出 if (mem[curPos][jumpSize] &gt;= 0) &#123; return mem[curPos][jumpSize]; &#125; for (int nextPos = curPos+1; i &lt; stones.size(); ++i) &#123; // gap值表示curPos位置 跳到 i位置 的跳跃距离 int gap = stones[nextPos] - stones[curPos]; if (gap &gt;= jumpSize - 1 &amp;&amp; gap &lt;= jumpSize + 1) &#123; // 能从curPos位置 跳到 i位置上，则记录为1 if (helper(stones, nextPos, gap, mem) == 1) &#123; mem[nextPos][gap] = 1; return 1; &#125; &#125; &#125; // 假如能跳到最后一个位置上，则记录下，反之同理 mem[curPos][jumpSize] = (curPos == stones.size()-1) ? 1 : 0; return mem[curPos][jumpSize]; &#125;public: bool canCross(vector&lt;int&gt;&amp; stones) &#123; int n = stones.size(); vector&lt;vector&lt;int&gt;&gt; mem(n, vector&lt;int&gt;(n, -1)); return (helper(stones, 0, 0, mem) == 1); &#125;&#125;; 3.DP 在思考怎么通过已有的递归中的依赖关系 &lt;=&gt; dp的状态转移方程上去。 发现假如是使用2维DP表的话，是不可成立的，因为一个i值需要对应多个j值，所以无从下手。 官方解 1.记忆化搜索 + 二分查找 在检索位置curPos + jumpSize时候，使用二分搜索来查找位置上是否有石头 12345678910111213141516171819202122232425262728293031public class Solution &#123; public boolean canCross(int[] stones) &#123; int[][] memo = new int[stones.length][stones.length]; for (int[] row : memo) &#123; Arrays.fill(row, -1); &#125; return can_Cross(stones, 0, 0, memo) == 1; &#125; public int can_Cross(int[] stones, int ind, int jumpsize, int[][] memo) &#123; if (memo[ind][jumpsize] &gt;= 0) &#123; return memo[ind][jumpsize]; &#125; int ind1 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize); if (ind1 &gt;= 0 &amp;&amp; can_Cross(stones, ind1, jumpsize, memo) == 1) &#123; memo[ind][jumpsize] = 1; return 1; &#125; int ind2 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize - 1); if (ind2 &gt;= 0 &amp;&amp; can_Cross(stones, ind2, jumpsize - 1, memo) == 1) &#123; memo[ind][jumpsize - 1] = 1; return 1; &#125; int ind3 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize + 1); if (ind3 &gt;= 0 &amp;&amp; can_Cross(stones, ind3, jumpsize + 1, memo) == 1) &#123; memo[ind][jumpsize + 1] = 1; return 1; &#125; memo[ind][jumpsize] = ((ind == stones.length - 1) ? 1 : 0); return memo[ind][jumpsize]; &#125;&#125; 2.DP 在动态规划方法中，我们会利用散列表 mapmap，对于散列表中的 key:valuekey:value，keykey 表示当前石头的位置，valuevalue 是一个包含 jumpsizejumpsize 的集合，其中每个 jumpsizejumpsize 代表可以通过大小为 jumpysizejumpysize 的一跳到达当前位置。 首先我们对散列表初始化，keykey 为所有石头的位置，除了位置 0 对应的 valuevalue 为包含一个值 0 的集合以外，其余都初始化为空集。接下来，依次遍历每个位置上的石头。对于每个 currentPositioncurrentPosition，遍历 valuevalue 中每个 jumpsizejumpsize，判断位置 currentPosition + newjumpsizecurrentPosition+newjumpsize 是否存在于 mapmap 中，对于每个 jumpsizejumpsize，newjumpsizenewjumpsize 分别为 jumpsize-1jumpsize−1，jumpsizejumpsize，jumpsize+1jumpsize+1。如果找到了，就在对应的 valuevalue 集合里新增 newjumpsizenewjumpsize。重复这个过程直到结束。如果在结束的时候，最后一个位置对应的集合非空，那也就意味着我们可以到达终点，如果还是空集那就意味着不能到达终点。 12345678910111213141516171819public class Solution &#123; public boolean canCross(int[] stones) &#123; HashMap&lt;Integer, Set&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; stones.length; i++) &#123; map.put(stones[i], new HashSet&lt;Integer&gt;()); &#125; map.get(0).add(0); for (int i = 0; i &lt; stones.length; i++) &#123; for (int k : map.get(stones[i])) &#123; for (int step = k - 1; step &lt;= k + 1; step++) &#123; if (step &gt; 0 &amp;&amp; map.containsKey(stones[i] + step)) &#123; map.get(stones[i] + step).add(step); &#125; &#125; &#125; &#125; return map.get(stones[stones.length - 1]).size() &gt; 0; &#125;&#125; 总结 暴力递归解总是有的，不过要找出一个靠谱的递归实现，然后可以通过其优化为 用一个数组存好结果的记忆化搜索的方式； dp数组可以是 hash散列 这种存储方式，不一定是 数组 的存储方式。 Reference 官方解]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
        <tag>数组</tag>
        <tag>DFS</tag>
        <tag>特殊DP数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-638-大礼包]]></title>
    <url>%2F2019%2F11%2F04%2Fleetcode%E9%A2%98%E8%A7%A3-638-%E5%A4%A7%E7%A4%BC%E5%8C%85%2F</url>
    <content type="text"><![CDATA[题目 My way 题目有提到 大礼包以优惠的价格捆绑销售一组物品 &lt;=&gt; 大礼包价格更优惠，优先级更高。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
        <tag>数组</tag>
        <tag>DFS</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-312-戳气球]]></title>
    <url>%2F2019%2F11%2F04%2Fleetcode%E9%A2%98%E8%A7%A3-312-%E6%88%B3%E6%B0%94%E7%90%83%2F</url>
    <content type="text"><![CDATA[My way 很蠢的思路： 选择min值，爆掉，然后循环至结束。 测都不用测。。。 没想到怎么往DP上面套。 ivan_allen 解 思路转变： 气球从头到尾爆炸 &lt;=&gt; 气球从尾到头爆炸 状态转移方程: \[ dp[i][j] = max(dp[i][j],\ nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j]), \text{if $k \in\ [i,\ j]$} \] 遍历方式： 控制子数组长度len 子数组首尾i, j 使用k对数组分割 二维DP实现： 123456789101112131415161718192021222324252627282930class Solution &#123;public: int N; int maxCoins(vector&lt;int&gt;&amp; nums) &#123; // 添加哨兵在头尾，因为假如最后只删一个数字的时候，是需要乘以2个1的 nums.insert(nums.begin(), 1); nums.push_back(1); int m = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(m)); // 只能按长度打表 // dp[i][j], j - i &gt;= 2 for (int len = 2; len &lt; m; ++len) &#123; for (int i = 0; i &lt; m - len; ++i) &#123; int j = i + len; for (int k = i + 1; k &lt; j; ++k) &#123; dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j]); &#125; &#125; &#125; return dp[0][m-1]; &#125;&#125;; 总结 思路的转变： 气球从头到尾爆炸 &lt;=&gt; 气球从尾到头爆炸 头尾虚拟1的添加 类似于之前虚拟0的添加 和 哨兵的思想 Reference ivan_allen解]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
        <tag>分治算法</tag>
        <tag>哨兵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-62-不同路径]]></title>
    <url>%2F2019%2F11%2F04%2Fleetcode%E9%A2%98%E8%A7%A3-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[My way 1. 2维DP 状态转移方程： \[ \begin{align*} &amp; dp[i][j] = dp[i-1][j] + dp[i][j-1] \\ \end{align*} \] base case: \[ \begin{align*} &amp; dp[i][j] = 1,\ \text{if $i==1$ or $j==1$} \\ \end{align*} \] corner case: \[ \begin{align*} &amp; dp[i][j] = 1, \text{if $i == 1$ and $j == 1$} \\ &amp; AND \\ &amp; return\ function \end{align*} \] 2. 1维DP 还可以转换成1维DP. powcai way 组合数学： PS： 这个排列组合的方法其实我想到过，但是没有找出通项公式 :cry: Reference powcai 解]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
        <tag>2维DP-to-1维DP</tag>
        <tag>组合数学</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-413.等差数列划分]]></title>
    <url>%2F2019%2F11%2F03%2Fleetcode%E9%A2%98%E8%A7%A3-413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[My way 状态转移方程: \[ dp[i][j] = \begin{cases} &amp; 2^{j-i-2}-1 &amp; \text{if $A[i:j]$是等差数列}\\ &amp; dp[i-1][j] + dp[i][j-1] &amp; otherwise\\ \end{cases} \] 官方解 2. 优雅暴力 3. 递归 状态定义： \[ \begin{align*} &amp; sum:\ 数组A中的所有的等差数列的个数 \\ &amp; slice(A,\ i):\ 求区间(k,\ i)中，而不在区间(k,\ j)中等差数列的个数，其中j&lt;i. \\ &amp; \end{align*} \] 假设知道了\(slice(A, i-1)\)的值为x, 同时这个区间元素用\([a_0, a_1, a_2, ..., a_{i-1}]\)来表示。 若这个区间本身就是一个等差数列，那么这里所有相邻元素之间的差值是相等的。 现加入一个元素\(a_i\)将区间扩展为\((0,\ i)\)，如果扩展之后的区间还是一个等差数列，那么一定存在\(a_i - a_{(i-1)} == a_{(i-1)} -a_{(i-2)}\). 故每加入一个新元素，就会多出\(ap\)个等差数列。其中新增的等差数列的区间为\((0,i), (1,i), ..., (i-2, i)\), 这些区间总数为\(x+1\). 这是因为除了区间\((0,i)\)之外，其余的区间如\((1,i), (2,i),...,(i-2,i)\)都可以对应到之前的区间\((0,i-1), (1,i-1), ...,(i-3,i-1)\)上去，其值为\(x\). 因此，每次调用slices, 如果第\(i\)个元素与前一个元素的差值正好等于之前的差值，我们直接就可以算出新增的等差数列的个数\(ap\), 同时可以更新\(sum\). 但是，如果新元素跟之前一个元素的差值不等于之前的差值，也就不会增加等差数列的个数 123456789101112131415161718public class Solution &#123; int sum = 0; public int numberOfArithmeticSlices(int[] A) &#123; slices(A, A.length - 1); return sum; &#125; public int slices(int[] A, int i) &#123; if (i &lt; 2) return 0; int ap = 0; if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) &#123; ap = 1 + slices(A, i - 1); sum += ap; &#125; else slices(A, i - 1); return ap; &#125;&#125; 4.DP 状态定义： \[ \begin{align*} &amp; dp:\ 存储在区间(k,i), 而不在区间(k,j)中的等差数列个数，其中j&lt;i\\ &amp; \end{align*} \] 12345678910111213public class Solution &#123; public int numberOfArithmeticSlices(int[] A) &#123; int[] dp = new int[A.length]; int sum = 0; for (int i = 2; i &lt; dp.length; i++) &#123; if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) &#123; dp[i] = 1 + dp[i - 1]; sum += dp[i]; &#125; &#125; return sum; &#125;&#125; 5.\(O(1)空间复杂度\)DP 对于\(dp\)数组来说，仅有\(dp[i-1]\)决定\(dp[i]\). 故只用保存最近一个\(dp\) 就可以了。 1234567891011121314public class Solution &#123; public int numberOfArithmeticSlices(int[] A) &#123; int dp = 0; int sum = 0; for (int i = 2; i &lt; A.length; i++) &#123; if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) &#123; dp = 1 + dp; sum += dp; &#125; else dp = 0; &#125; return sum; &#125;&#125; 6. 公式计算 123456789101112131415public class Solution &#123; public int numberOfArithmeticSlices(int[] A) &#123; int count = 0; int sum = 0; for (int i = 2; i &lt; A.length; i++) &#123; if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) &#123; count++; &#125; else &#123; sum += (count + 1) * (count) / 2; count = 0; &#125; &#125; return sum += count * (count + 1) / 2; &#125;&#125; reference extended How to sum up elements of a C++ vector? how to sum up a vector of vector int in C++ without loops]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
        <tag>数组</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-303-区域和检索 - 数组不可变]]></title>
    <url>%2F2019%2F11%2F03%2Fleetcode%E9%A2%98%E8%A7%A3-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98%2F</url>
    <content type="text"><![CDATA[题目 12345678910111213141516class NumArray &#123;public: NumArray(vector&lt;int&gt;&amp; nums) &#123; &#125; int sumRange(int i, int j) &#123; &#125;&#125;;/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * int param_1 = obj-&gt;sumRange(i,j); */ My way 1. 暴力法 1234567891011121314151617181920212223242526class NumArray &#123;private: vector&lt;int&gt; dp; public: NumArray(vector&lt;int&gt;&amp; nums) &#123; dp = nums; &#125; int sumRange(int i, int j) &#123; int sum = 0; for (int k = i; k &lt;= j; ++k) &#123; sum += dp[k]; &#125; return sum; &#125;&#125;;/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * int param_1 = obj-&gt;sumRange(i,j); */ 结果，时间复杂度极低，仅超过10%的解。 很明显是要先用dp数组存入各个索引\(i\), \(j\)对应的值。 2. 2维DP 状态转移方程： \[ dp[i][j] = dp[i][j-1] + nums[j-1] \] 12345678910111213141516171819202122232425262728class NumArray &#123;private: vector&lt;vector&lt;int&gt;&gt; dp; public: NumArray(vector&lt;int&gt;&amp; nums):dp(nums.size()+1, vector&lt;int&gt;(nums.size()+1)) &#123; for (int i = 1; i &lt;= nums.size(); ++i) &#123; for (int j = i; j &lt;= nums.size(); ++j) &#123; dp[i][j] = dp[i][j-1] + nums[j-1]; &#125; &#125; &#125; int sumRange(int i, int j) &#123; return dp[i+1][j+1]; &#125;&#125;;/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * int param_1 = obj-&gt;sumRange(i,j); */ 结果更慢了，仅超过5%的解。。。 应该是哪里思路出了问题... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class NumArray &#123;private: int **dp; int m;public: NumArray(vector&lt;int&gt;&amp; nums) &#123; m = nums.size() + 1; dp = new int*[m]; for(int i = 0; i &lt; m; ++i) &#123; dp[i] = new int[m]; &#125; for (int i = 1; i &lt;= nums.size(); ++i) &#123; int sum = 0; for (int j = i; j &lt;= nums.size(); ++j) &#123; sum += nums[j-1]; dp[i][j] = sum; &#125; &#125; &#125; ~NumArray() &#123; for (int i = 0; i &lt; m; ++i) &#123; delete []dp[i]; &#125; delete []dp; &#125; int sumRange(int i, int j) &#123; return dp[i+1][j+1]; &#125;&#125;;/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * int param_1 = obj-&gt;sumRange(i,j); */ 换成原生数组，时间复杂度仅超过7%，仍然很糟糕。。。 假如直接静态数组int dp[INT_MAX][INT_MAX];，内存会炸掉。。。 官方way 2. 缓存 将计算结果提前存入到 哈希表 中。 PS：而我用的是vector&lt;vector&lt;int&gt;&gt; dp, int **dp, 感觉没区别，应该是resize()/动态分配内存那耗费了不少时间。 123456789101112131415private Map&lt;Pair&lt;Integer, Integer&gt;, Integer&gt; map = new HashMap&lt;&gt;();public NumArray(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; int sum = 0; for (int j = i; j &lt; nums.length; j++) &#123; sum += nums[j]; map.put(Pair.create(i, j), sum); &#125; &#125;&#125;public int sumRange(int i, int j) &#123; return map.get(Pair.create(i, j));&#125; 3. 缓存 优化空间复杂度从\(O(n^2) = &gt; O(n)\). \[ sum[k] = \begin{cases} &amp; \sum_{i=0}^{k-1} nums[i] &amp; , k &gt; 0 \\ &amp; 0 &amp; , k == 0\\ \end{cases} \] 优化为: \[ sumrange(i,\ j)= sum[j+1] - sum[i] \] java: 123456789101112private int[] sum;public NumArray(int[] nums) &#123; sum = new int[nums.length + 1]; for (int i = 0; i &lt; nums.length; i++) &#123; sum[i + 1] = sum[i] + nums[i]; &#125;&#125;public int sumRange(int i, int j) &#123; return sum[j + 1] - sum[i];&#125; C++: use array 12345678910111213141516171819202122232425262728class NumArray &#123;private: int *sum;public: NumArray(vector&lt;int&gt;&amp; nums) &#123; sum = new int [nums.size() + 1]; for (int i = 0; i &lt; nums.size(); ++i) &#123; sum[i+1] = sum[i] + nums[i]; &#125; &#125; ~NumArray() &#123; delete []sum; &#125; int sumRange(int i, int j) &#123; return sum[j + 1] - sum[i]; &#125;&#125;;/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * int param_1 = obj-&gt;sumRange(i,j); */ 但这也只超过了 78.45%... C++: user vector&lt;int&gt; 1234567891011121314151617class NumArray &#123; vector&lt;int&gt; dp;public: NumArray(vector&lt;int&gt;&amp; nums) &#123; int sum=0; dp.push_back(0); for(int i=0;i&lt;nums.size();++i) &#123; sum+=nums[i]; dp.push_back(sum); &#125; &#125; int sumRange(int i, int j) &#123; return dp[j+1]-dp[i]; &#125;&#125;; 超过了96.23%，代码类似 陈乐乐解2. 但仔细看她代码，你会发现她在C++编码时，有个很不好的习惯，我在这纠正了，就不指出来了。 总结 傻了，老想着把计算结果存起来，到时候直接取，居然忘记了 \(sumrange(i,\ j)= sum[j+1] - sum[i]\) 这里也用到了插入了一个虚拟 0 作为 sum 数组中的第一个元素。 这个技巧可以避免在 sumrange 函数中进行额外的条件检查，对于base case, corner case等等 PS：尽管，我其实喜欢加上对于base case, corner case的检查，但却是实现起来有些冗余 Reference 官方解 陈乐乐解 extended How do I declare a 2d array in C++ using new?]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
        <tag>2维dp</tag>
        <tag>插入1个虚拟0</tag>
        <tag>数组</tag>
        <tag>hash</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-1143-最公共子序列长]]></title>
    <url>%2F2019%2F11%2F03%2Fleetcode%E9%A2%98%E8%A7%A3-1143-%E6%9C%80%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%95%BF%2F</url>
    <content type="text"><![CDATA[题目 简单DP，只给出状态转移方程。 状态转移方程 \[ dp[i][j] = \begin{cases} &amp; dp[i-1][j-1]+1, &amp; \text{if $text1[i]==text2[j]$} \\ &amp; max(dp[i-1][j],\ dp[i][j-1]), &amp; otherwise \\ \end{cases} \] 123456789101112131415161718192021222324class Solution &#123;public: int longestCommonSubsequence(string text1, string text2) &#123; int m = text1.size() + 1, n = text2.size() + 1; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n)); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; if (text1[i-1] == text2[j-1]) &#123; dp[i][j] = dp[i-1][j-1] + 1; &#125; else &#123; dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 总结 这里只求，最大公共子序列的长度，简单的2维DP即可实现 记住，这种在状态转移方程中存在f[i] = f[i-1]的递推式情况下， 将设置 新数组长度 = 旧数组长度 + 1 从而可以减少在base case, corner case的语句，减少代码冗余程度。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
        <tag>2维dp</tag>
        <tag>最大公共子序列</tag>
        <tag>插入1个虚拟0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-931-下降路径最小和]]></title>
    <url>%2F2019%2F11%2F02%2Fleetcode%E9%A2%98%E8%A7%A3-931-%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目 My way 1.二维DP 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int m = A.size(); int n = A[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(A); // base case for (int j = 0; j &lt; n; ++j) &#123; dp[0][j] = A[0][j]; &#125; // for (int i = 1; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (j - 1 == -1) &#123; dp[i][j] = min(dp[i-1][j], dp[i-1][j+1]) + A[i][j]; &#125; else if (j + 1 == n) &#123; dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + A[i][j]; &#125; else &#123; dp[i][j] = min(min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]) + A[i][j]; &#125; &#125; &#125; return *min_element(dp[m-1].begin(), dp[m-1].end()); &#125;&#125;; 2.一维DP 可以将二维DP压缩至一维DP处理。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>2维dp</tag>
        <tag>2维DP-to-1维DP</tag>
        <tag>√</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-714-买卖股票的最佳时机含手续费]]></title>
    <url>%2F2019%2F11%2F01%2Fleetcode%E9%A2%98%E8%A7%A3-714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%2F</url>
    <content type="text"><![CDATA[My way 一开始审题失误了，没有看到股票可以 多次买入，卖出。 所以想了个 只准单次买入，卖出的解法。 1234567891011121314151617181920212223242526272829303132class Solution &#123;private: static bool mycomp(vector&lt;int&gt; a, vector&lt;int&gt; b) &#123; return *max_element(a.begin(), a.end()) &lt; *max_element(b.begin(), b.end()); &#125;public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; size_t n = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); // Base case for (size_t i = 0; i &lt; n; ++i) &#123; dp[i][i] = 0; &#125; for (size_t i = 0; i &lt; n; ++i) &#123; for (size_t j = i + 1; j &lt; n; ++j) &#123; dp[i][j] = dp[i][j-1] + prices[j] - prices[j-1] - fee; &#125; &#125; auto itv = max_element(dp.begin(), dp.end(), mycomp); // find the vector // with the max element return *max_element((*itv).begin(), (*itv).end()); // finds the max element // in the desired vector &#125;&#125;; 官方解 通过第\(i\)天和\(i-1\)天\(cash,\ hold\)的递推关系，来得到最后最大收益。 *但是给我的感觉，这个思路，并不是很好捋清楚。 状态定义： \[ \begin{align*} &amp; cash:\ 不持有股票时的最大利润 \\ &amp; hold:\ 持有股票时的最大利润\\ \end{align*} \] 状态转移方程： 12cash = Math.max(cash, hold + prices[i] - fee); // max(原来请况，假设第i天卖出股票)hold = Math.max(hold, cash - prices[i]); // max(原来情况，假设第i天买进股票) Base case 12cash = 0;hold = -prices[0]; // 假设第0天买了股票 12345678910class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int cash = 0, hold = -prices[0]; for (int i = 1; i &lt; prices.length; i++) &#123; cash = Math.max(cash, hold + prices[i] - fee); hold = Math.max(hold, cash - prices[i]); &#125; return cash; &#125;&#125; e.g. $$ \[\begin{align*} &amp;输入: prices = [1, 3, 2, 8, 4, 9], fee = 2\\ &amp;输出: 8\\ &amp;解释: 能够达到的最大利润: \\ &amp;在此处买入 prices[0] = 1\\ &amp;在此处卖出 prices[3] = 8\\ &amp;在此处买入 prices[4] = 4\\ &amp;在此处卖出 prices[5] = 9\\ &amp;总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. \\ \end{align*}\] $$ prices cash hold 0 1 0 -1 1 3 max(0, -1+3-2)=0 max(0, 0-3)=-3 2 2 max(0, -1+2-2)=0 max(-1, 0-2)=-1 3 8 max(0, -1+8-2)=5 max(-1, 5-8)=-1 4 4 max(5, -1+4-2)=5 max(-1, 5-4)=1 5 9 max(5, 1+9-2)=8 max(1, 8-9)=-1 Reference 官方解 laluladong解 extended Find the max value in vector&gt; without for loop markdown generator]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>×</tag>
        <tag>动态规划</tag>
        <tag>贪心算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-647-回文子串]]></title>
    <url>%2F2019%2F11%2F01%2Fleetcode%E9%A2%98%E8%A7%A3-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目 My way 状态定义： \[ \begin{align*} &amp; s:\ 字符串s\\ &amp; i:\ 字符串s第i位\\ &amp; j:\ 字符串s第j位\\ &amp; s[i:j]:\ 字符串s第i位到第j位的子串, s[i,j]\\ &amp; dp[i][j]:\ dp数组在s[i,j]上是否为回文串的记录。 \end{align*} \] Base case： \[ \begin{align*} &amp;s[i][j] = 1, &amp;\text{if $i==j$}\ \end{align*} \] 状态转移方程： \[ s[i-1][j+1] = \begin{cases} &amp; 1,\ \text{if $s[i] == s[j]$}\\ &amp; 0,\ otherwise \end{cases} \] Error: 在如何实现数组遍历上面，出现了问题。 套用了 glamour的逆向对角遍历思路： 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int countSubstrings(string s) &#123; int m = s.size(); int cnt = 0; vector&lt;vector&lt;bool&gt;&gt; dp(m, vector&lt;bool&gt;(m, false)); // base case for (int i = 0; i &lt; m; ++i) &#123; dp[i][i] = true; ++cnt; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 0; j &lt;= m - i - 1; ++j) &#123; int row = j; int column = i + j; bool cur = s[row] == s[column]; if (cur &amp;&amp; (i == 1 || dp[row+1][column-1])) &#123; dp[row][column] = true; ++cnt; &#125; &#125; &#125; return cnt; &#125;&#125;; Glamour way 1.DP + 逆向对角遍历 逆向对角遍历思路： 上图中同一条直线上的值有前者依赖于后者的关系，因此我们应该以对角线方向遍历 但是本方法在發現一字符串不是回文串后，仍然對包含其的字符串進行回文判斷。 此方法包含了冗餘的判斷，因此還有優化的地方。 123456789101112131415161718192021222324252627public int countSubstrings(String s) &#123; int len = s.length(); if(len &lt;= 1) return len; boolean[][] dp = new boolean[len][len]; int i; int j; int row, column; boolean current; int count = 0; for(i = 0; i &lt; len; i++)&#123; dp[i][i] = true; count++; &#125; for(i = 1; i &lt; len; i++)&#123; for(j = 0; j &lt;= len - i - 1; j++)&#123; row = j; column = i + j; current = s.charAt(row) == s.charAt(column); if(current &amp;&amp; (i == 1 || dp[row + 1][column - 1]))&#123; dp[row][column] = true; count++; &#125; &#125; &#125; return count; &#125; 2. 分治法 + 中心扩散法 分治法，对以不同字符为中心的回文分而治之，同时又将回文的长度分为奇数和偶数，奇数的中心有一个，而偶数的中心有两个. 有一個規律： 回文串左右兩邊同時去掉一個字符仍然是回文串；反之一個字符串不是回文串， 那麽他左右兩邊不論加上什麽字符都不可能是回文串. 12345678910111213141516public int countSubstrings(String s) &#123; int count = 0; int i; for(i = 0; i &lt; s.length(); i++)&#123; count += countPalindrome(s, i, i); count += countPalindrome(s, i, i + 1); &#125; return count; &#125; public int countPalindrome (String s, int left, int right)&#123; int count = 0; while(left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left--) == s.charAt(right++))&#123; count++; &#125; return count; &#125; C++实现 1234567891011121314151617181920212223242526class Solution &#123;public: int countSubstrings(string s) &#123; int m = s.size(); int cnt = 0; for (int i = 0; i &lt; m; ++i) &#123; cnt += countPalindrome(s, i, i); // even length of string cnt += countPalindrome(s, i, i+1); // old length of string &#125; return cnt; &#125; int countPalindrome(const string&amp; s, int l, int r) &#123; int cnt = 0; while (l &gt;= 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l--] == s[r++]) &#123; ++cnt; &#125; return cnt; &#125;&#125;; Reference glamour解法]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>×</tag>
        <tag>动态规划</tag>
        <tag>数组对角遍历</tag>
        <tag>字符串</tag>
        <tag>中心扩散法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-712-两个字符串的最小ASCII删除和]]></title>
    <url>%2F2019%2F11%2F01%2Fleetcode%E9%A2%98%E8%A7%A3-712-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8FASCII%E5%88%A0%E9%99%A4%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目 官方解 状态定义： \[ \begin{align*} &amp; i:\ \text{字符串}s1的第i位\\ &amp; j:\ \text{字符串}s2的第j位\\ &amp; s1[i:]:\ 第i位到末尾的子串\\ &amp; s2[j:]:\ 第j位到末尾的子串\\ &amp; dp[i][j]:\ 表示使字符串s1[i:],s2[j:]从第i位到末尾的子串相等，要删除的ASCII码值最小 \end{align*} \] 状态转移方程： \[ \begin{align*} dp[i][j] = \begin{cases} &amp; min(dp[i+1][j] + s1.asciiAtPos(i), dp[i][j+1] + s2.asciiAtPos(j))\ &amp; \text{if $s1[i] != s2[j]$ }\\ &amp; df[i-1][j-1]\ &amp;\text{if $s1[i] = s2[j]$} \end{cases} \end{align*} \] Base case: \[ \begin{align*} &amp;dp[i][j] = 0 &amp;\text{if $i == 0$ and $j == 0$} \end{align*} \] Corner case: \[ dp[i][j] = \begin{cases} &amp; dp[i+1][j] + s1.asciiAtPos(i) &amp; \text{if $s[j:].size() == 0$, 即$j==s1.size()$}\\ &amp; dp[i][j+1] + s2.asciiAtPos(j) &amp; \text{if $s[i:].size() == 0$, 即$i==s1.size()$}\\ \end{cases} \] C++实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: int minimumDeleteSum(string s1, string s2) &#123; vector&lt;vector&lt;int&gt;&gt; dp(s1.size()+1, vector&lt;int&gt;(s2.size()+1)); int m = s1.size(), n = s2.size(); for (int i = m - 1; i &gt;= 0; --i) &#123; dp[i][n] = dp[i+1][n] + s1[i]; &#125; for (int j = n - 1; j &gt;= 0; --j) &#123; dp[m][j] = dp[m][j+1] + s2[j]; &#125; for (int i = m - 1; i &gt;= 0; --i) &#123; for (int j = n - 1; j &gt;= 0; --j) &#123; if (s1[i] == s2[j]) &#123; dp[i][j] = dp[i+1][j+1]; &#125; else &#123; dp[i][j] = min(dp[i+1][j] + s1[i], dp[i][j+1] + s2[j]); &#125; &#125; &#125; return dp[0][0]; &#125;private: int getStrAsciiSum(const string s) &#123; int sum = 0; for (auto i : s) &#123; sum += i; &#125; return sum; &#125;&#125;; Java实现 1234567891011121314151617181920212223class Solution &#123; public int minimumDeleteSum(String s1, String s2) &#123; int[][] dp = new int[s1.length() + 1][s2.length() + 1]; for (int i = s1.length() - 1; i &gt;= 0; i--) &#123; dp[i][s2.length()] = dp[i+1][s2.length()] + s1.codePointAt(i); &#125; for (int j = s2.length() - 1; j &gt;= 0; j--) &#123; dp[s1.length()][j] = dp[s1.length()][j+1] + s2.codePointAt(j); &#125; for (int i = s1.length() - 1; i &gt;= 0; i--) &#123; for (int j = s2.length() - 1; j &gt;= 0; j--) &#123; if (s1.charAt(i) == s2.charAt(j)) &#123; dp[i][j] = dp[i+1][j+1]; &#125; else &#123; dp[i][j] = Math.min(dp[i+1][j] + s1.codePointAt(i), dp[i][j+1] + s2.codePointAt(j)); &#125; &#125; &#125; return dp[0][0]; &#125;&#125; 总结 类似于 最长公共子序列 的一道题。 在 二维DP数组初始化的时候，没有考虑到初始化大小为\((m+1)*(n+1)\) . 对于\(dp[m][n] = 0\)其实是一种 base case， 是考虑到第\(m\)位字符到第\(m\)位字符上的一个情况，即 空串情况。 Reference leetcode官方解 Falcon解 Extended std::basic_string basic_string/substr]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>×</tag>
        <tag>插入1个虚拟0</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-95-不同的二叉搜索树2]]></title>
    <url>%2F2019%2F10%2F31%2Fleetcode%E9%A2%98%E8%A7%A3-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912%2F</url>
    <content type="text"><![CDATA[题目 官方解 简要改自官网解。 利用树的遍历，以递归方式实现不同二叉树的构造。 我们从序列 \(1 ...n\) 中取出数字 \(i\)，作为当前树的树根。于是，剩余 \(i - 1\) 个元素可用于左子树，\(n - i\) 个元素用于右子树。 如 前文所述，这样会产生 \(G(i - 1)\) 种左子树 和 \(G(n - i)\) 种右子树，其中 \(G\) 是卡特兰数。 现在，我们对序列 \(1 ... i - 1\) 重复上述过程，以构建所有的左子树；然后对 \(i + 1 ... n\) 重复，以构建所有的右子树。 这样，我们就有了树根 \(i\) 和可能的左子树、右子树的列表。 最后一步，对两个列表循环，将左子树和右子树连接在根上。 C++实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // [start, end] vector&lt;TreeNode*&gt; generate_trees(int start, int end) &#123; vector&lt;TreeNode*&gt; all_trees; if (start &gt; end) &#123; all_trees.push_back(NULL); return all_trees; &#125; // pick up a root for (int i = 0; i &lt;= end; ++i) &#123; vector&lt;TreeNode*&gt; leftTrees = generate_trees(start, i - 1); vector&lt;TreeNode*&gt; rightTrees = generate_trees(i + 1, end); for (auto l : leftTrees) &#123; for (auto r : rightTrees) &#123; TreeNode* curTree(i); curTree-&gt;left = l; curTree-&gt;right = r; all_trees.push_back(curTree); &#125; &#125; &#125; return all_trees; &#125; vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if (n == 0) &#123; return vector&lt;TreeNode*&gt;(); &#125; else &#123; return generate_trees(1, n); &#125; &#125;&#125;; Java实现 1234567891011121314151617181920212223242526272829303132class Solution &#123; public LinkedList&lt;TreeNode&gt; generate_trees(int start, int end) &#123; LinkedList&lt;TreeNode&gt; all_trees = new LinkedList&lt;TreeNode&gt;(); if (start &gt; end) &#123; all_trees.add(null); return all_trees; &#125; // pick up a root for (int i = start; i &lt;= end; i++) &#123; // all possible left subtrees if i is choosen to be a root LinkedList&lt;TreeNode&gt; left_trees = generate_trees(start, i - 1); // all possible right subtrees if i is choosen to be a root LinkedList&lt;TreeNode&gt; right_trees = generate_trees(i + 1, end); // connect left and right trees to the root i for (TreeNode l : left_trees) &#123; for (TreeNode r : right_trees) &#123; TreeNode current_tree = new TreeNode(i); current_tree.left = l; current_tree.right = r; all_trees.add(current_tree); &#125; &#125; &#125; return all_trees; &#125; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if (n == 0) &#123; return new LinkedList&lt;TreeNode&gt;(); Reference 官方解]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>×</tag>
        <tag>动态规划</tag>
        <tag>树</tag>
        <tag>递归</tag>
        <tag>树的遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-1227-风机座位分配概率]]></title>
    <url>%2F2019%2F10%2F31%2Fleetcode%E9%A2%98%E8%A7%A3-1227-%E9%A3%8E%E6%9C%BA%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D%E6%A6%82%E7%8E%87%2F</url>
    <content type="text"><![CDATA[My way 习惯不是很好。。最开始试答案试出来结果的。 \(1/n\), \(1/2\), 然后得到正确解。。 因为第一眼看上去就是组合数学题，就类似你买彩票，先买后买的顺序不影响概率。 简单思路 为什么试\(1/n\)，以为要考虑的是\(n\)个状态取1个。 后来发现应该是\(1/2\)，感觉解释起来就有问题了。 水氷/Leoooooo/winterock way 简单递推dp的思路，在此略作修改。 状态定义： \[ \begin{align*} &amp; i:\ 第i个入座的人 \\ &amp; n:\ 一共有n个座位 \\ &amp; f[i]:\ 第i个入座的人，坐到自己位置上的概率 \\ \end{align*} \] *状态转移方程： \[ \begin{align*} f[i] = 1/n + (n-2)/n * f(n-1) \end{align*} \] Leoooooo给出的推导过程： $$ \[\begin{alignat}{1} f(n) = &amp; 1/n &amp; // \text{1st person picks his own seat, probability = 1/n} \\ &amp;+ 1/n * 0 &amp; // \text{1st person picks last one&#39;s seat, probability = 1/n} \\ &amp;+ (n-2)/n * &amp; // \text{1st person picks one of seat from 2nd to (n-1)th, probability = (n-2)/n} \\ &amp;( \\ &amp;\ \ \ 1/(n-2) * f(n-1) &amp; // \text{1st person pick 2nd&#39;s seat, 2nd person becomes the new &quot;careless&quot; person, and there are n-1 seats left. it becomes subproblem of n-1.}\\ &amp;\ \ \ 1/(n-2) * f(n-2) &amp; // \text{1st person pick 3rd&#39;s seat, 2nd person will pick his own seat, 3nd person becomes the new &quot;careless&quot; person, and there are n-2 seats left. it becomes subproblem of n-2.}\\ &amp;\ \ \ ......\\ &amp;\ \ \ 1/(n-2) * f(2) &amp; // \text{1st person pick (n-1)th&#39;s seat, (n-1)th person becomes the new &quot;careless&quot; person, there are 2 seats left.}\\ &amp;) \\ \\ =&gt; &amp; f(n) = 1/n &amp; \text{\{when $n &lt;= 2$\}} \\ &amp; f(n) = 1/n + 1/n * ( f(n-1) + f(n-2) + f(n-3) + ... + f(2) ) &amp; \text{\{when $n &gt; 2$\}} \\ \end{alignat}\] $$ 根据winterock给出的解释，简单来说: 按照条件概率，分成3种情况，在此以1号为例子： \(1/n\), 第1个人，选择了自己的座位，则对\(2,...,n\)位置空出来了，他们必然可以做到自己的位置，即\(n\)可以坐到自己的位置； \(1/n*0\), 第1个人坐到\(n\)位置上，则\(n\)必然坐不到自己位置上； \((n-2)/n * (...)\) ，这个情况，简单来说就是，如果\(i\)坐到\(k\)位置上，则\((i,\ k)\)里的人都能坐到自己位置上来，因为每个人看到自己位置空的时候必然坐上来。具体举例不展开了，很容易想明白。 证明结论为\(f(n)=1/2\): \[ \begin{align*} &amp; \text{When}\ n &lt;= 2 \\ &amp; \ f(n) = 1/n \\ &amp; \text{When}\ n &gt; 2\ \text{(all these 5 formulas are correct, we can choose any one of them)} \\ &amp; \ f(n) = 1/n + 1/n * ( f(n-1) + f(n-2) + f(n-3) + ... + f(2) ) \\ &amp; \ f(n+1) = f(n)\\ &amp; \ f(n) = 1/n + (n-2)/n * f(n) \\ &amp; \ f(n) = 1/n + (n-2)/n * f(n-1) \ \text{is correct too since} f(n) == f(n-1) \\ &amp; \ f(n) = 1/2 \\ \end{align*} \] 12345678910111213class Solution &#123;public: double nthPersonGetsNthSeat(int n) &#123; double f[n+1]; f[1] = 1; if(n == 1) return 1; for (int i = 2; i &lt;= n; ++i) f[i] = (1 + (i - 2) * f[i - 1]) / (double)i; return f[n]; &#125;&#125;; 总结 怎么求出合理的递推式用于状态转移方程。 这里是用了 条件概率来入手。 然后通过思考发现了这样一个规律: 如果\(i\)坐到\(k\)位置上，则\((i,\ k)\)里的人都能坐到自己位置上来，因为每个人看到自己位置空的时候必然坐上来。 有没有从组合数学的思路的解法呢？ Reference 水氷 leetcode 解 Leoooooo 状态转移方程详解 winterock 状态转移方程详解]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学题</tag>
        <tag>×</tag>
        <tag>插入1个虚拟0</tag>
        <tag>动态规划</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-120-三角形最小路径]]></title>
    <url>%2F2019%2F10%2F31%2Fleetcode%E9%A2%98%E8%A7%A3-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目 My way 很简单的二维dp思路，每一层的元素依赖于上一层同列元素和上一层前一列元素。 二维DP 状态定义： \[ \begin{align*} &amp; i:\ 行号 \\ &amp; j:\ 列号 \\ &amp; triangle[i][j]:\ 原始三角形上的i行,\ j列的数字 \\ &amp; dp[i][j]:\ dp数组的i行,\ j列上的数字 \\ &amp; 0 &lt;= i == j &lt;= n, n为行数 \end{align*} \] 状态转移方程: \[ dp[i][j] = triangle[i][j] + min\{dp[i-1][j-1],\ dp[i-1][j] \} \] Base case: \[ dp[i][j] = triangle[i][j],\ \text{if $i == 0$ and $j == 0$} \] Corner case: \[ dp[i][j] = triangle[i][j] + dp[i-1][j],\ \text{if $j == 0$} \\ dp[i][j] = triangle[i][j] + dp[i-1][j-1],\ \text{if $i == j$} \] C++实现 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;vector&lt;int&gt;&gt; dp(triangle); for (int i = 0; i &lt; triangle.size(); ++i) &#123; for (int j = 0; j &lt; triangle[i].size(); ++j) &#123; if (i == 0 &amp;&amp; j == 0) &#123; dp[i][j] = triangle[0][0]; &#125; else if (i != 0 &amp;&amp; j == 0) &#123; dp[i][j] = triangle[i][j] + dp[i-1][j]; &#125; else if (i == j) &#123; dp[i][j] = triangle[i][j] + dp[i-1][j-1]; &#125; else &#123; dp[i][j] = triangle[i][j] + min(dp[i-1][j-1], dp[i-1][j]); &#125; &#125; &#125; return *min_element(dp[triangle.size()-1].begin(), dp[triangle.size()-1].end()); &#125;&#125;; 一维DP 如何仅使用\(O(n)\)大小的额外空间呢？ 因为每一行的状态仅依赖于上一行的状态，故可将二维DP to 一维DP. 对空间复杂度进行优化。 状态定义： \[ \begin{align*} &amp; i:\ 行号 \\ &amp; j:\ 列号 \\ &amp; triangle[i][j]:\ 原始三角形上的i行,\ j列的数字 \\ &amp; dp[k]:\ dp数组的第k个数字 \\ &amp; 0 &lt;= j &lt;= i &lt;= k == n, n为行数 \\ \end{align*} \] 状态转移方程: \[ dp[j] = triangle[i][j] + min\{dp[j-1], dp[j]\} \] Base case: \[ dp[j] = triangle[i][j],\ \text{if $i == 0$ and $j == 0$} \] Corner case: \[ dp[j] = triangle[i][j] + dp[j],\ \text{if $j == 0$} \\ dp[j] = triangle[i][j] + dp[j-1],\ \text{if $i == j$} \] C++实现 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; dp(triangle.size()); for (int i = 0; i &lt;= triangle.size() - 1; ++i) &#123; for (int j = triangle[i].size() - 1; j &gt;= 0; --j) &#123; if (i == 0 &amp;&amp; j == 0) &#123; dp[j] = triangle[0][0]; &#125; else if (i != 0 &amp;&amp; j == 0) &#123; dp[j] = triangle[i][j] + dp[j]; &#125; else if (i == j) &#123; dp[j] = triangle[i][j] + dp[j-1]; &#125; else &#123; dp[j] = triangle[i][j] + min(dp[j-1], dp[j]); &#125; &#125; &#125; return *min_element(dp.begin(), dp.end()); &#125;&#125;; Elon way 关键能有这个思路上的转变： 自顶向下最短距离 &lt;=&gt; 自底向上最短距离 自顶向下, 记忆化搜索 思路类似上面 二维DP。 还利用了树的遍历思维解决问题 123456789101112131415161718192021class Solution &#123; int row; Integer[][] memo; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; row = triangle.size(); memo = new Integer[row][row]; return helper(0,0, triangle); &#125; private int helper(int level, int c, List&lt;List&lt;Integer&gt;&gt; triangle)&#123; // System.out.println("helper: level="+ level+ " c=" + c); if (memo[level][c]!=null) return memo[level][c]; if (level==row-1)&#123; return memo[level][c] = triangle.get(level).get(c); &#125; int left = helper(level+1, c, triangle); int right = helper(level+1, c+1, triangle); return memo[level][c] = Math.min(left, right) + triangle.get(level).get(c); &#125;&#125; 自底向上, DP 12345678910public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int row = triangle.size(); int[] minlen = new int[row+1]; for (int level = row-1;level&gt;=0;level--)&#123; for (int i = 0;i&lt;=level;i++)&#123; //第i行有i+1个数字 minlen[i] = Math.min(minlen[i], minlen[i+1]) + triangle.get(level).get(i); &#125; &#125; return minlen[0];&#125; 总结 这里的自顶向下，自底向上 感觉就是我之前所理解的二维DP。不过我是采用非递归方式实现的，而这里是递归方式实现的。 *思考题目后，思路上的转变: 自顶向下最短距离 &lt;=&gt; 自底向上最短距离 以及多多尝试 递归方式实现此类DP。 Reference Elon leetcode解法 extended How to find minimum value from vector? [closed]]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>×</tag>
        <tag>插入1个虚拟0</tag>
        <tag>动态规划</tag>
        <tag>2维DP</tag>
        <tag>2维DP-to-1维DP</tag>
        <tag>自顶向下DP</tag>
        <tag>自底向上DP</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-64-最小路径和]]></title>
    <url>%2F2019%2F10%2F30%2Fleetcode%E9%A2%98%E8%A7%A3-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[My way 第一眼感觉就是一个当前表格状态依赖于左边表格状态和上边表格状态的二维DP题。 状态定义： \[ \begin{align*} &amp; i:\ 表示第i行 \\ &amp; j:\ 表示第j列 \\ &amp; [i,\ j]:\ 表示第i行，j列上的数字\\ &amp; grid[i][j]:\ 表示原始网格上第i行，j列上的数字\\ &amp; dp[i][j]:\ 表示经过某些步之后，达到第i行，j列的时候，这个数字和的最小值\\ \end{align*} \] 状态转移方程： \[ \begin{align*} &amp; dp[i][j] = grid[i][j] + max(df[i-1][j],\ df[i][j-1]) \end{align*} \] Base Case: \[ \begin{align*} &amp; df[0][0] = grid[0][0] \end{align*} \] Corner Case: \[ \begin{align*} &amp; df[i][j] = grid[i][j] + df[i, j-1],\ \text{if $j-1$ == 0} \\ &amp; df[i][j] = grid[i][j] + df[i-1, j],\ \text{if $j-1$ == 0} \end{align*} \] C++实现 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;vector&lt;int&gt;&gt; vvi(grid); int m = grid.size(), n = grid[0].size(); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (i == 0 &amp;&amp; j == 0) &#123; vvi[i][j] = grid[i][j]; &#125; else if (i == 0) &#123; vvi[i][j] = grid[i][j] + vvi[i][j-1]; &#125; else if (j == 0) &#123; vvi[i][j] = grid[i][j] + vvi[i-1][j]; &#125; else &#123; vvi[i][j] = grid[i][j] + min(vvi[i-1][j], vvi[i][j-1]); &#125; &#125; &#125; return vvi[m-1][n-1]; &#125;&#125;; 可以试试斜着遍历 !对于\(m*n\ array\)来说，不太好实现。 有一个思路就是补成正方形之后，然后以对角线的方式倾斜遍历数组。 官方解 1.暴力 不做解释了。 2.二维DP 类似我的思路。 3.一维DP 因为这里每个阶段的状态仅依赖上一个表格状态和左一个表格的状态， 再加上我们利用按行遍历的方式，依次求出每一行对应的\(dp[i][j]\)，然后得到结果。 官方Java解 123456789101112131415161718public class Solution &#123; public int minPathSum(int[][] grid) &#123; int[] dp = new int[grid[0].length]; for (int i = grid.length - 1; i &gt;= 0; i--) &#123; for (int j = grid[0].length - 1; j &gt;= 0; j--) &#123; if(i == grid.length - 1 &amp;&amp; j != grid[0].length - 1) dp[j] = grid[i][j] + dp[j + 1]; else if(j == grid[0].length - 1 &amp;&amp; i != grid.length - 1) dp[j] = grid[i][j] + dp[j]; else if(j != grid[0].length - 1 &amp;&amp; i != grid.length - 1) dp[j] = grid[i][j] + Math.min(dp[j], dp[j + 1]); else dp[j] = grid[i][j]; &#125; &#125; return dp[0]; &#125;&#125; 重上到下，C++实现 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;int&gt; dp(grid[0].size()); for (int i = 0; i &lt; grid.size(); ++i) &#123; for (int j = 0; j &lt; grid[0].size(); ++j) &#123; if (i == 0 &amp;&amp; j == 0) &#123; dp[j] = grid[0][0]; &#125; else if (i == 0 &amp;&amp; j != 0) &#123; dp[j] = grid[i][j] + dp[j-1]; &#125; else if (i != 0 &amp;&amp; j == 0) &#123; dp[j] = grid[i][j] + dp[j]; &#125; else &#123; dp[j] = grid[i][j] + min(dp[j], dp[j-1]); &#125; &#125; &#125; return dp[grid[0].size()-1]; &#125;&#125;; Reference leetcode 官方解 extended Traverse an array diagonally Traverse 2D m*n Array (Matrix) Diagonally]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>2维DP</tag>
        <tag>2维DP-to-1维DP</tag>
        <tag>数组对角遍历</tag>
        <tag>√</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-96-不同的二叉搜索树]]></title>
    <url>%2F2019%2F10%2F29%2Fleetcode%E9%A2%98%E8%A7%A3-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目 官方解 思考题目中，输入为\(n\)，表示由\(n\)个节点来构成二叉搜索树。 可以考虑到的是，每个子树的根节点不同，则为一个新的子树结构(包括 叶节点)。 所以要考虑到如何从 根节点 入手，以及对于当前根节点的左右子树的递推的方式解决。 动态规划 状态定义： 考虑到涉及到 输入节点个数\(n\) 和所取 根节点\(i\)，可以定义如下： \[ \begin{align*} &amp; F(i,\ n) = \text{以$i$为根节点，长度为$n$的二叉搜索树的树的个数} \\ &amp; G(n) = \text{长度为$n$的二叉搜索树的树的个数} \\ \end{align*} \] 可以得到如下 状态转移方程/递推公式： \[ \begin{align*} &amp; G(n) = \sum_{i=1}^{n}F(i,\ n) \\ &amp; F(i,\ n) = G(i-1) * G(n-i),\ 因为同一长度n的二叉搜索树个数一样 \\ &amp; so\ we\ get: \\ &amp; G(n) = \sum_{i=1}^{n}\{G(i-1) * G(n-i)\} \\ &amp; 0 &lt;= i &lt;= n \end{align*} \] Base case: \[ \begin{align*} &amp; G(0) = 0\\ &amp; G(1) = 1\\ &amp; 0 &lt;= i &lt;= n \end{align*} \] \(G[0] = 0\)， 一方面说明 空树也是一种二叉搜索树。 一方面为了 构造的递推式中涉及到乘法，要保证乘积因子不为0才可。 1234567891011121314public class Solution &#123; public int numTrees(int n) &#123; int[] G = new int[n + 1]; G[0] = 1; G[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; G[i] += G[j - 1] * G[i - j]; &#125; &#125; return G[n]; &#125;&#125; 数学way 数学归纳法： 可以归纳得出：\(G(n)\)的值被称为Catalan数\(C_n\)。 定义如下： \[ \begin{align*} &amp; C_0 = 1, \\ &amp; C_{n+1} = \frac{2(2n+1)}{n+2} C_n \end{align*} \] 12345678910class Solution &#123; public int numTrees(int n) &#123; // Note: we should use long here instead of int, otherwise overflow long C = 1; for (int i = 0; i &lt; n; ++i) &#123; C = C * 2 * (2 * i + 1) / (i + 2); &#125; return (int) C; &#125;&#125; 总结 要考虑到二叉搜索树的基本定义之一 左子树上的值 &lt; 根节点 &lt; 右子树上的值 空树也是二叉搜索树的一种 *如何摸索出状态定义的中的2个状态：\(n\), \(i\). 题目已给条件中的状态有: 构成二叉搜索树的序列长度\(n\)。 考虑到子树的根节点不同，影响到二叉搜索树的结构，所以推测出: \(i\)是\([0,\ n]\)中取的一个值作为根节点。 *Catalan数，一个组合数学问题常常涉及到的。 Reference leetcode官方解 wikipidia-cn: catalan number baidu baike: 卡特兰数 extended C++ memory model C memory model]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>×</tag>
        <tag>插入1个虚拟0</tag>
        <tag>动态规划</tag>
        <tag>树</tag>
        <tag>Catalan数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解-1221-分割平衡字符串]]></title>
    <url>%2F2019%2F10%2F28%2Fleetcode%E9%A2%98%E8%A7%A3-1221-%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目 虽然打的是 贪心算法 的tag，但是我感觉实际上是括号匹配的简单变种。 解法 括号匹配/栈的做法 考虑L, R分别对应左右两个括号。 利用stack的push, pop和括号匹配的基本思路来完成。 栈为空，push当前元素。 top元素 等于 当前元素，push当前元素，否则pop top元素。 栈为空，平衡次数+1。 PS: 注意思路实现是带有先后顺序的。 123456789101112131415161718192021222324252627class Solution &#123;public: int balancedStringSplit(string s) &#123; int count = 0; stack&lt;char&gt; sc; for (int i = 0; i &lt; s.size(); ++i) &#123; char c = s[i]; if (sc.empty() || c == sc.top()) &#123; sc.push(c); &#125; else &#123; sc.pop(); &#125; if (sc.empty()) &#123; ++count; &#125; &#125; return count; &#125;&#125;; 利用数字计数代替括号匹配做法 因为这里不同于括号匹配需要是一个&lt;&gt;的匹配状态，可以是LR, RL, LLRR, RRLL， 也就是说可以看成一个简单版本的括号匹配过程， 因为不需要要求L, R之间的先后关系，所以可以通过 数字计数 取代掉 栈括号匹配 的过程。 若当前元素为L, 计数++num；为R, 计数--num; 若num == 0, 则平衡次数+1。 1234567891011121314151617181920212223242526class Solution &#123;public: int balancedStringSplit(string s) &#123; int num = 0; int count = 0; for (auto it = s.begin(); it &lt; s.end(); ++it) &#123; if (*it == 'L') &#123; ++num; &#125; else &#123; --num; &#125; if (num == 0) &#123; ++count; &#125; &#125; return count; &#125;&#125;; 总结 这题提及的&quot;尽可能多的平衡字符串分割“ + 实例，说明了这里的字符串分割是不存在前后分割出的字符串结果有交集的。 可以思考到，正常的从头到尾的一次遍历即可。 提及的” ‘L’和'R'字符的数量是相同的 &quot;, 并没有提及到 L和R要有前后顺序的关系 可以思考到，利用 数字计数法 代替 括号匹配法。 Reference Karua leetcode 题解 amanehayashi leetcode 题解 Extended std::stack STL header stack iterator library]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>×</tag>
        <tag>贪心算法</tag>
        <tag>栈</tag>
        <tag>线性表</tag>
        <tag>括号匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解: 877.石子游戏]]></title>
    <url>%2F2019%2F10%2F27%2Fleetcode%E9%A2%98%E8%A7%A3-877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目 官方解 数学way 直接从官方解处摘抄过来，很有意思的数学归纳证明思想。如下： 显然，亚历克斯总是赢得 2 堆时的游戏。 通过一些努力，我们可以获知她总是赢得 4 堆时的游戏。 如果亚历克斯最初获得第一堆，她总是可以拿第三堆。 如果她最初取到第四堆，她总是可以取第二堆。第一 + 第三，第二 + 第四 中的至少一组是更大的，所以她总能获胜。 我们可以将这个想法扩展到 N 堆的情况下。设第一、第三、第五、第七桩是白色的，第二、第四、第六、第八桩是黑色的。 亚历克斯总是可以拿到所有白色桩或所有黑色桩，其中一种颜色具有的石头数量必定大于另一种颜色的。 因此，亚历克斯总能赢得比赛。 123456class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; return true; &#125;&#125;; 综评最高解 在dp解释上强于官方解，简要摘取部分过程，详细见reference处。 对于\(piles=[3, 9, 1, 2]\), 定义状态： \[ dp[i][j].fir\ or\ dp[i][j].sec\\ 其中：\\ 0 &lt;= i &lt; piles.length, i相当于石子堆最左堆\\ i &lt;= j &lt; piles.length, j相当于石子堆最右堆 \] 其中， \[ dp[i][j].fir表示，对于piles[i...j]这部分石子，先手能获得的最高分数 \\ dp[i][j].sec表示，对于piles[i...j]这部分石子，后手能获得的最高分数 \] 状态转移方程为： \[ dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec) \\ \] $$ \[\begin{align*} &amp; if 先手选择左边: dp[i][j].sec = dp[i+1][j].fir \\ &amp; if 先手选择右边: dp[i][j].sec = dp[i][j-1].fir \\ &amp; 解释：\\ &amp; 我作为后手，要等先手先选择，有两种情况： \\ &amp; 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j] \\ &amp; 此时轮到我，我变成了先手；\\ &amp; 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1] \\ &amp; 此时轮到我，我变成了先手。\\ \end{align*}\] $$ base case \[ \begin{align*} &amp; dp[i][j].fir = piles[i] \\ &amp; dp[i][j].sec = 0 \\ &amp; 其中 0 &lt;= i == j &lt; n \\ &amp; 解释：i 和 j 相等就是说面前只有一堆石头 piles[i] \\ &amp; 那么显然先手的得分为 piles[i] \\ &amp; 后手没有石头拿了，得分为 0 \\ \end{align*} \] 这里需要注意一点，我们发现 \(base\ case\)是斜着的，而且我们推算 dp[i][j] 时需要用到 dp[i+1][j] 和 dp[i][j-1]： 所以说算法不能简单的一行一行遍历 dp 数组，而要斜着遍历数组： 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int n = piles.size(); // initialize dp array vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; dp(n, vector&lt;pair&lt;int, int&gt;&gt;(n, make_pair(0, 0))); // fill with base case for (int i = 0; i &lt; n; ++i) &#123; dp[i][i].first = piles[i]; dp[i][i].second = 0; &#125; // traverse array in a diagonal way for (int l = 2; l &lt;= n; ++l) &#123; for (int i = 0; i &lt;= n - l; ++i) &#123; int j = i + l - 1; // 先手选择最左边或者最右边的分数 int left = piles[i] + dp[i+1][j].second; int right = piles[j] + dp[i][j-1].second; // 套用状态转移方程 if (left &gt; right) &#123; dp[i][j].first = left; dp[i][j].second = dp[i+1][j].first; &#125; else &#123; dp[i][j].first = right; dp[i][j].second = dp[i][j-1].first; &#125; &#125; &#125; pair&lt;int, int&gt; res(dp[0][n-1]); return res.first - res.second; &#125;&#125;; 综评Java实现 123456789101112131415161718192021222324252627282930313233/* 返回游戏最后先手和后手的得分之差 */int stoneGame(int[] piles) &#123; int n = piles.length; // 初始化 dp 数组 Pair[][] dp = new Pair[n][n]; for (int i = 0; i &lt; n; i++) for (int j = i; j &lt; n; j++) dp[i][j] = new Pair(0, 0); // 填入 base case for (int i = 0; i &lt; n; i++) &#123; dp[i][i].fir = piles[i]; dp[i][i].sec = 0; &#125; // 斜着遍历数组 for (int l = 2; l &lt;= n; l++) &#123; for (int i = 0; i &lt;= n - l; i++) &#123; int j = l + i - 1; // 先手选择最左边或最右边的分数 int left = piles[i] + dp[i+1][j].sec; int right = piles[j] + dp[i][j-1].sec; // 套用状态转移方程 if (left &gt; right) &#123; dp[i][j].fir = left; dp[i][j].sec = dp[i+1][j].fir; &#125; else &#123; dp[i][j].fir = right; dp[i][j].sec = dp[i][j-1].fir; &#125; &#125; &#125; Pair res = dp[0][n-1]; return res.fir - res.sec;&#125; 总结 二维DP，也是递推问题，但是给人的没有一维DP那么好处理。 状态定义，一般涉及到2个状态\(i,\ j\)。可以用表格法表示，有点类似0-1背包问题。 状态转移方程，一般涉及到上一状态的2个状态。 base case, 我的理解是一般类似于 corner case的存在，是一个需要考虑到的初始条件。 斜着遍历数组，这个在实现的时候，也不是一件非常容易的事情。 123456789// traverse array in a diagonal wayfor (int l = 2; l &lt;= n; ++l)&#123; for (int i = 0; i &lt;= n - l; ++i) &#123; int j = i + l - 1; // ... &#125;&#125; 若\(n = 4\), 则依次遍历： \[ \begin{align*} &amp; [0,\ 1],\ [1,\ 2], [2,\ 3], [3,\ 4] \\ &amp; [0,\ 2],\ [1,\ 3], [2,\ 4] \\ &amp; [0,\ 3],\ [1,\ 4] \\ &amp; [0,\ 4] \\ \end{align*} \] Reference labuladong: leetcode解 leetcode 官方解 extended std::pair std::vector]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
        <tag>二维dp</tag>
        <tag>博弈问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解: 1025.除数博弈]]></title>
    <url>%2F2019%2F10%2F24%2Fleetcode%E9%A2%98%E8%A7%A3-1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[题目 My way: 这题靠归纳推理，首先很明显就能看出来偶数的时候Alice赢了； 然后多举了几个例子就发现奇数的时候Bob赢了。 就直接一个条件语句，结束。 但是尝试套dp的做法的时候，没捋清楚，看了综评最高的，基本懂了。 12345678910111213class Solution &#123;public: bool divisorGame(int N) &#123; if (!(N &amp; 1)) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;; 综评最高解 1.归纳法： 基本思路： 最终结果应该是占到 2 的赢，占到 1 的输； 若当前为奇数，奇数的约数只能是奇数或者 1，因此下一个一定是偶数； 若当前为偶数， 偶数的约数可以是奇数可以是偶数也可以是 1，因此直接减 1，则下一个是奇数； 因此，奇则输，偶则赢。 123class Solution: def divisorGame(self, N: int) -&gt; bool: return N%2==0 2.DP: 定义状态 \(i\): 数字\(N\)为\(i\)时； \(f[i]\): 数字\(N\)为\(i\)时，Alice的胜负状况，true为胜，false为负。 定义状态转移方程： \[ f[i] = \begin{cases} true, &amp; \text{if}\ f[i-j] == false,\ \text{if}\ i\ \%\ j == 0\ \\ &amp; and\ j\ is\ unsigned\ integer\ which \in (0, N) \ \\ false, &amp; \text{otherwise} \end{cases} \] 实现 1234567891011121314151617181920class Solution &#123;public: bool divisorGame(int N) &#123; vector&lt;bool&gt; vi(N+1); for (int i = 2; i &lt; N + 1; ++i) &#123; for (int j = 1; j &lt;= i / 2; ++j) &#123; if (vi[i-j] == false &amp;&amp; i % j == 0) &#123; vi[i] = true; &#125; &#125; &#125; return vi[N]; &#125;&#125;; 综评解 12345678910111213141516class Solution: def divisorGame(self, N: int) -&gt; bool: target = [0 for i in range(N+1)] target[1] = 0 #若爱丽丝抽到1，则爱丽丝输 if N&lt;=1: return False else: target[2] = 1 #若爱丽丝抽到2，则爱丽丝赢 for i in range(3,N+1): for j in range(1,i//2): # 若j是i的余数且target[i-j]为假（0）的话，则代表当前为真（1） if i%j==0 and target[i-j]==0: target[i] = 1 break return target[N]==1 总结 初等数学review: 奇数的因数： {奇数} 偶数的因数： {偶数} 奇数的最大公因数 = 奇数 目前做到的dp还是简单递推问题，可以简单套换成： 状态\(i\)就是数字为\(i\)的时候 \(f[i]\)就是数字为\(i\)时候，结果为\(f[i]\) Reference pandawakaka 给出的解]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学题</tag>
        <tag>DP</tag>
        <tag>×</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解: 338.比特位计数]]></title>
    <url>%2F2019%2F10%2F23%2Fleetcode%E9%A2%98%E8%A7%A3-338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目 My way: 这题tag是dp，按着dp的思路写出了 状态， 状态转移方程包括 边界条件， 常规情况。 大致思路如下： 定义状态： \(i\): 数字为\(i\)时； \(f[i]\): 数字为i时，\(f[i]\)表示有多少个1，在数字\(i\)的二进制表示形式下。 状态转移方程： 边界：\(f[0] = [\ \ ]\) 正常情况：(第一时间也拿不出来，通过举例拿到的，) eg. \(f[1] = 1\) \(f[2] = 1\) \(f[3] = 1 + 1 = f[2] + f[1]\) \(f[4] = 1\) \(f[5] = 2 = f[4] + f[1]\) \(f[6] = 2 = f[4] + f[2]\) \(f[7] = 3 = f[4] + f[2] + f[1]\) 得到： \[ f[i] = \begin{cases} [\ \ ], &amp; \text{if}\ i == 0 \\ 1, &amp; \text{if}\ i == 2^m,\ \text{m is unisgned integer} \\ 1 + f[i - j], &amp; \text{if}\ 2^j &lt; i &lt; 2^{j+1},\ \text{j is unsigned integer} \end{cases} \] 合并下情况有： \[ f[i] = 1 + f[i-j],\ \text{if}\ 2^j &lt; i &lt; 2^{j+1},\ \text{j is unsigned integer} \] 然后以Cpp实现了如下： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; if (num == 0) &#123; return vector&lt;int&gt;&#123;0&#125;; &#125; if (num == 1) &#123; return vector&lt;int&gt; &#123;0, 1&#125;; &#125; vector&lt;int&gt; vi &#123;0, 1&#125;; for (int i = 2; i &lt; num+1; ++i) &#123; int j; for (j = 0; pow(2, j) &lt;= i; ++j) &#123;&#125; j = pow(2, j-1); int val; if (i-j-1 == -1) &#123; val = 1; &#125; else &#123; val = 1 + vi[i-j]; &#125; vi.push_back(val); &#125; return vi; &#125;&#125;; 不过很遗憾这是一种很低效的解法 Standard Way 详细解释见之后reference的官方解释link处，这里只给出最后的思路/状态转移方程和我的一些理解及实现。 1.Pop Count 思路 利用位运算x &amp; (x - 1)来不断消除最右边的一位1，直至数字为0时，可以算出这个数字有多少位1。 PS：确实没想到位运算这块，思维狭隘了。 实现 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; if (num == 0) &#123; return vector&lt;int&gt;&#123;0&#125;; &#125; if (num == 1) &#123; return vector&lt;int&gt; &#123;0, 1&#125;; &#125; vector&lt;int&gt; vi &#123;0, 1, &#125;; for (int i = 2; i &lt; num + 1; ++i) &#123; vi.push_back(pop_count(i)); &#125; return vi; &#125;private: int pop_count(int num) &#123; // 通过 x &amp;= x - 1 的位运算操作，来消除掉一个数从左到右的最右边的一个1 int count; for (count = 0; num != 0; ++count) &#123; num &amp;= num - 1; &#125; return count; &#125;&#125;; 官方解这里利用了 default initialization来implicit初始化 未初始化的结果。 1234567891011121314public class Solution &#123; public int[] countBits(int num) &#123; int[] ans = new int[num + 1]; for (int i = 0; i &lt;= num; ++i) ans[i] = popcount(i); return ans; &#125; private int popcount(int x) &#123; int count; for (count = 0; x != 0; ++count) x &amp;= x - 1; //zeroing out the least significant nonzero bit return count; &#125;&#125; 2. 动态规划 + 最高有效位 状态转移方程 结合1解法的pop_count \(P(x)\)函数来，有以下状态转移函数： \[ P(x+b) = P(x) + 1, b= 2^m &gt; x \] 我的理解 能想到最左最高有效位刚好多一个1的情况，这个1在m位的话，则是多了\(2^m\)值。 实现 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; vi(num+1); // 可以不初始化为，gcc, clang下，float, double, size_t, unsigned会由default initialization初始化0 // 同理, string会初始化为'' //vi[0] = 0; int x = 0, b = 1; // 利用外部循环来找到满足 b = 2^m &gt; x的情况 // i = 0是因为每4个一循环，给下4个取值 for ( ; b &lt;= num; b &lt;&lt;= 1, x = 0) &#123; while (x &lt; b &amp;&amp; x + b &lt;= num) &#123; vi[x+b] = vi[x] + 1; ++x; &#125; &#125; return vi; &#125;&#125;; 这里官方解的Java实现有个非常巧妙的地方： 利用了 while (b &lt;= num) {...}的外部循环来找到 \(b = 2^m &gt; x\) 的\(b\)值 123456789101112131415161718# standard solutionpublic class Solution &#123; public int[] countBits(int num) &#123; int[] ans = new int[num + 1]; int i = 0, b = 1; // [0, b) is calculated while (b &lt;= num) &#123; // generate [b, 2b) or [b, num) from [0, b) while(i &lt; b &amp;&amp; i + b &lt;= num)&#123; ans[i + b] = ans[i] + 1; ++i; &#125; i = 0; // reset i b &lt;&lt;= 1; // b = 2b &#125; return ans; &#125;&#125; 3. 动态规划 + 最低有效位 状态转移方程 同样基于pop_count()函数 \[ P(x) = P(x/2) + (x\ mod\ 2) \] 我的理解 同理2解法，由最高有效位，想到最低有效位： 实现 1234567891011121314class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; vi(num+1); int i = 1; for ( ; i &lt; num + 1; ++i) &#123; vi[i] = vi[i/2] + (i % 2); &#125; return vi; &#125;&#125;; 这里官方解，利用了位运算来代替已有的/和%运算： x &gt;&gt; 1 &lt;=&gt; x / 2 x &amp; 1 &lt;=&gt; x % 2 12345678public class Solution &#123; public int[] countBits(int num) &#123; int[] ans = new int[num + 1]; for (int i = 1; i &lt;= num; ++i) ans[i] = ans[i &gt;&gt; 1] + (i &amp; 1); // x / 2 is x &gt;&gt; 1 and x % 2 is x &amp; 1 return ans; &#125;&#125; 4.动态规划 + 最后设置位 状态转移方程 同样基于pop_count()函数 \[ P(x) = P(x\ \&amp;\ (x-1)) + 1 \] 我的理解 利用位运算x &amp; (x-1)消除最右边的一位“1”， 使得 x 比 x &amp; (x-1) 少一位“1”， 加上这个“1”即可. 实现 12345678910111213class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; vi(num+1); for (int i = 1; i &lt; num + 1; ++i) &#123; vi[i] = vi[i &amp; (i - 1)] + 1; &#125; return vi; &#125;&#125;; 官方解： 12345678public class Solution &#123; public int[] countBits(int num) &#123; int[] ans = new int[num + 1]; for (int i = 1; i &lt;= num; ++i) ans[i] = ans[i &amp; (i - 1)] + 1; return ans; &#125;&#125; 总结 简单DP，注意定义好状态，写出状态转移方程，然后注意corner case。写成代码即可。 注意涉及到 2进制， 全0 1 的数字， 非负整数, unsigned, size_t, size_type等等， 往位运算上面想。 总结这里的位运算操作，之后考虑全部总结下常见位运算操作, 我记得耗子有篇文章总结了很多这方面的。 x &amp; (x - 1) 消除 x 的最右边的一位1. (PS: 这一个确实不熟悉，虽然也见过) x &lt;&lt; 2 &lt;=&gt; x * 2 x &gt;&gt; 2 &lt;=&gt; x / 2 x &amp; 1 &lt;=&gt; x % 2 (PS：那篇文章link找不到了) Reference leetcode官方解答 Large braces for specifying values of variables by condition Extended knowledge std::bitset::bitset in cppreference How to print (using cout) a number in binary form? default initialization lifetime Why does c++ initialise a std::vector with zeros, but not a std::array?]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
        <tag>×</tag>
        <tag>插入1个虚拟0</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小结及之后]]></title>
    <url>%2F2019%2F10%2F23%2F%E5%B0%8F%E7%BB%93%E5%8F%8A%E4%B9%8B%E5%90%8E%2F</url>
    <content type="text"><![CDATA[小结 之前都去打了些结构化数据的比赛，也补了不少基础知识，尽管没有按当初的计划来。 尽管我觉得目前取得成绩不太够用吧，总结下有： 上海电信“添翼杯”成绩预测20名（吐槽下这破比赛结束，官网就没了？？？） kaggle Instant Gratification solo铜牌 19讯飞反欺诈，初赛第8，复赛a榜14，b榜24 DataCastle 国能日新光伏预测功率第二届第6名 多多少少打了些咸鱼成绩出来。 最惨的还是讯飞，基本上2-3个月天天熬。初赛最后分数还算不错，到了复赛因为数据量太大，导致CatBoost在Shrink Model的时候峰值占用的内存会高到至少100g+和租的辣鸡DBC服务器疯狂卡结果，最后几天把我队的两个模型结果卡住没出来了。以及top3的选手开源了一个高分代码，上分操作与我队有一些重合，拉高了复赛线。 暂时有空抽时间把前面两篇坑了的博客补了，Data Science/ Machine Learning这块考虑暂时就放一段时间了。 之后？ 开始刷leetcode和补一些以前干的后台开发相关的活了。 刷下Cpp reference啥啥的，把一些忘了的Cpp相关的东西捡起来； 每天至少龟系刷题1道，先从dp刷起来。1~2个月之后再考虑兔系刷题； 补下APUE那套东西，以前碰过，现在忘了不少； 接触下NoSQL，Redis这套； PS: 以后写博客就不会那么详细，主要还是自己理解，留下一步一个脚印。 PPS： 至于比赛还打不打，看时间够不够吧，能支撑自己走下去的只有求生欲了。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在调用folds-split进行交叉检验时，使用tqdm记录每折时间]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%9C%A8%E8%B0%83%E7%94%A8folds-split%E8%BF%9B%E8%A1%8C%E4%BA%A4%E5%8F%89%E6%A3%80%E9%AA%8C%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8tqdm%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%8A%98%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA['如何将相对unix初始时间的时间差转换为当前时间轴']]></title>
    <url>%2F2019%2F07%2F01%2F%E5%A6%82%E4%BD%95%E5%B0%86%E7%9B%B8%E5%AF%B9unix%E5%88%9D%E5%A7%8B%E6%97%B6%E9%97%B4%E7%9A%84%E6%97%B6%E9%97%B4%E5%B7%AE%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[内存不够时，替代sns.countplot()的实现方法]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%86%85%E5%AD%98%E4%B8%8D%E5%A4%9F%E6%97%B6%EF%BC%8C%E6%9B%BF%E4%BB%A3sns-countplot-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[内存不够时，替代sns.countplot()的实现方法 最近做EDA的的时候会存在这样一种情况，数据量过大时，直接使用sns.countplot()内存很容易直接被榨干掉。 暂时没想清为什么会直接占用那么多内存，应该去StackOverflow提个Q的。 不过想了下又查了下StackOverflow，应该有用df.value_counts() 和 matplotlib来实现sns.countplot()的实现方法，如此，What is Matplotlib's alternative for countplot from seaborn? 引用自StackOverflow，ImportanceOfBeingErnest Say you have this data: 123456import numpy as np; np.random.seed(42)import pandas as pdimport matplotlib.pyplot as pltdf = pd.DataFrame(&#123;"Sex" : np.random.choice(["male", "female"], size=1310, p=[.65, .35]), "other" : np.random.randint(0,80, size=1310)&#125;) You can plot a countplot in seaborn as 123import seaborn as snssns.countplot(x="Sex", data=df)plt.show() Or you can create a bar plot in pandas 12df["Sex"].value_counts().plot.bar()plt.show() Or you can create a bar plot in matplotlib 123counts = df["Sex"].value_counts()plt.bar(counts.index, counts.values)plt.show() Reference What is Matplotlib's alternative for countplot from seaborn? Pandas:Visualization Guide]]></content>
      <categories>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>code snippet</tag>
        <tag>data visualization</tag>
        <tag>matplotlib</tag>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何指定xtick在一个特定的范围]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9Axtick%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E7%9A%84%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[在做EDA的时候，会有种情况，时序数据所做的plot的x-axis会存在过于密集的情况，如下 所以我们要做的就是只用将数据所在范围按一定频率切分开就行了，如这个Q，[how to change the xticks to a specific range [duplicate\]](https://stackoverflow.com/questions/56713197/how-to-change-the-xticks-to-a-specific-range) 和 Changing the “tick frequency” on x or y axis in matplotlib? 分别引用自StackOverflow用户 Heike和Alexandre B.并作出了一定修改。 在comment和answer处提供了两种解决方案： 添加一行代码plt.xticks(range(9, 40, 10), range(10, 41, 10)) 这里第一个参数是是将xtick分块显示，第二个参数是各个分块处显示的数字.(这里原来的数据找不到了，就用了answer中随机生成的数据为例子). 例子: 1234567891011# Your data to county = np.random.randint(0,41,1000)# Create plotfig, ax = plt.subplots()sns.countplot(y)# Show graphplt.xticks(range(0, 41, 10), range(0, 41, 10))plt.xlabel('user_id')plt.show() 但是假如将第一个参数设置的分块范围超过数据已有的范围，则会在plot超出数据已有范围处显示出一段blank。 One way is to define the labels on the x-axis. The set_xticklabels method from matplotlibmodule do the job (doc). By defining your own labels, you can hide them by setting the label equal to ''. By defining your own labels, you need to take care that they are still consistent with your data. Here is one example: 123456789101112131415161718192021222324252627# import modulesimport numpy as npimport seaborn as snsimport matplotlib.pyplot as plt#Init seabornsns.set()# Your data to county = np.random.randint(0,41,1000)# Create the new x-axis labels x_labels = ['' if i%10 != 0 else str(i) for i in range(len(np.unique(y)))]print(x_labels)# ['0', '', '', '', '', '', '', '', '', '', # '10', '', '', '', '', '', '', '', '', '', # '20', '', '', '', '', '', '', '', '', '', # '30', '', '', '', '', '', '', '', '', '', '40']# Create plotfig, ax = plt.subplots()sns.countplot(y)# Set the new x axis labelsax.set_xticklabels(x_labels)# Show graphplt.show() Reference [how to change the xticks to a specific range [duplicate\]](https://stackoverflow.com/questions/56713197/how-to-change-the-xticks-to-a-specific-range) Changing the “tick frequency” on x or y axis in matplotlib? matplotlib.axes.Axes.set_xticklabels]]></content>
      <categories>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>code snippet</tag>
        <tag>EDA</tag>
        <tag>pandas</tag>
        <tag>data disualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将DataFrame中的数据以表格的形式另存为图片]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%B0%86DataFrame%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A5%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8F%A6%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[将DataFrame中的数据以表格的形式另存为图片 在上次按序输出关联矩阵的blog中有了将DataFrame中的数据以表格形式另存储为图片的想法。 起初，Google了在StackOverflow上找到了相关问题，并将代码修改应用于Titanic的数据上，具体如下： 12345678910from pandas.plotting import tablefig = plt.figure(figsize=(5, 6))ax = fig.add_subplot(111, frame_on=False) # no visible frameax.xaxis.set_visible(False) # hide the x axisax.yaxis.set_visible(False) # hide the y axistable(ax, train_corr, loc='center') # where df is your data frameplt.savefig('correlation_matrix_vague.jpg') This is a vague pic 但是，发现另存为的图片极为模糊，再思考并查询相关文档未果后，并在StackOverflow上提出了相关问题，发现是因为没有设置合适的dpi参数，故设置合适的dpi参数并修改代码如下： 12345678910from pandas.plotting import tablefig = plt.figure(figsize=(5, 6), dpi=1400)ax = fig.add_subplot(111, frame_on=False) # no visible frameax.xaxis.set_visible(False) # hide the x axisax.yaxis.set_visible(False) # hide the y axistable(ax, train_corr, loc='center') # where df is your data frameplt.savefig('correlation_matrix_HD.jpg') Reference 在matplotlib的一个figure中画多个subplots How to save a pandas DataFrame table as a png Titanic in Kaggle How to make picture clear when saving the table of DataFrame as a picture Relationship between dpi and figure size pandas.plotting matplotlib.pyplot.table]]></content>
      <categories>
        <category>Pandas</category>
      </categories>
      <tags>
        <tag>pandas</tag>
        <tag>matplotlib</tag>
        <tag>seaborn</tag>
        <tag>Code Snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以DataFrame的形式按序输出关联矩阵(correlation matrix)]]></title>
    <url>%2F2019%2F04%2F23%2F%E4%BB%A5DataFrame%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%8C%89%E5%BA%8F%E8%BE%93%E5%87%BA%E5%85%B3%E8%81%94%E7%9F%A9%E9%98%B5(correlation%20matrix)%2F</url>
    <content type="text"><![CDATA[以DataFrame的形式按序输出关联矩阵(correlation matrix) 一般来说在做EDA的时候，我们都是输出相关矩阵的热力图或者是以表格形式输出。 但是我在Stantar 2019的一个kernel见到了按序输出关联矩阵系数的代码，故在此基础上进行了一定修改，实现了一个自己的code snippet. 具体例子见下：(此处数据采用Titanic in Kaggle) 12train_corr = train_df.drop(['PassengerId'], axis=1).corr()train_corr 123# 设置热力图尺寸为(20, 12)plt.subplots(figsize=(20, 12))sns.heatmap(train_corr, vmin=-1, vmax=1, annot=True, square=True) 123corr = train_corr.abs().unstack().sort_values(kind='quicksort', ascending=False).reset_index()corr = corr[(corr['level_0'] != corr['level_1']) &amp; (corr['level_0'] == 'Survived')]corr 一般是设置ascending参数，来看你是想要按序输出高或低相关度. 这里feature数量比较少，故直接输出，一般是corr调用tail()或者head()来输出该顺序中的后或前几个相关系数。例如： 1corr.tail(4) 下一篇会在再讲下，如何将Pandas.DataFrame的表格存储为图片，这也是在写这篇blog过程中的一点idea的实现. Reference Titanic in Kaggle 按序输出correlation matrix出处 Pandas.DataFrame.unstack Pandas.DataFrame.reset_index]]></content>
      <categories>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>code snippet</tag>
        <tag>EDA</tag>
        <tag>pandas</tag>
        <tag>data disualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在matplotlib的一个figure中画多个subplots]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%9C%A8matplotlib%E7%9A%84%E4%B8%80%E4%B8%AAfigure%E4%B8%AD%E7%94%BB%E5%A4%9A%E4%B8%AAsubplots%2F</url>
    <content type="text"><![CDATA[在一个figure中画多个subplots 在做EDA和Data Visualization中常常会用到的一个code snippet,在这里以kaggle上的titianic数据为例子: 12345# 先导入packagesimport pandas as pdimport matplotlib.pyplot as plt%matplotlib inlineimport seaborn as sns 1234567891011121314151617181920# 导入数据# path需根据具体环境作调节path = 'input'train_df = pd.read_csv(''.join([path, '/train.csv']))test_df = pd.read_csv(''.join([path, '/test.csv']))gender_sub_df = pd.read_csv(''.join([path, '/gender_submission.csv']))# 以Survived特征为例子fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2)# ax1sns.countplot(train_df['Survived'], ax=ax1)# ax2# autopct参数是用来显示饼图上百分比的ax2.pie(train_df['Survived'].value_counts(), autopct='%1.1f%%')# set_aspect('equal')是为了让饼图成圆形(circle)而不是椭圆(ellipse， oval)ax2.set_aspect('equal')plt.set_xlabel('Survived') 其中部分代码也可重写为如下： 123456789fig, ax = plt.subplots(nrows=1, ncols=2)# ax1sns.countplot(train_df['Survived'], ax=ax[0])# ax2ax[1].pie(train_df['Survived'].value_counts(), autopct='%1.1f%%')ax[1].set_aspect('equal')plt.set_xlabel('Survived') 也可以根据修改nrows, ncols参数来适用多行多列的情况：(这里举得这个例子只是为了举例而举例，没有过多实际意义) 1234567891011121314151617fig, ax = plt.subplots(nrows=2, ncols=2)# ax[0, 0]sns.countplot(train_df['Survived'], ax=ax[0, 0])# ax[0, 1]ax[0, 1].pie(train_df['Survived'].value_counts(), autopct='%1.1f%%')ax[0, 1].set_aspect('equal')ax[0, 1].set_xlabel('Survived')# ax[1, 0]sns.countplot(train_df['Pclass'], ax=ax[1, 0])# ax[1, 1]ax[1, 1].pie(train_df['Pclass'].value_counts(), autopct='%1.1f%%')ax[1, 1].set_aspect('equal')ax[1, 1].set_xlabel('Pclass') four_subplots_in_one_figure 当然也可以用循环来实现，在此不对这举例了。 中间还有2个小插曲，就是我实现的时候，发现ax[0, 0]的subplot没有x_label,所以还去StackOverflow上面提了个Question，发现仅仅是被hidden住了，加上一行plt.tight_layer()代码即可。 12345678910111213141516171819fig, ax = plt.subplots(nrows=2, ncols=2)# ax[0, 0]sns.countplot(train_df['Survived'], ax=ax[0, 0])# ax[0, 1]ax[0, 1].pie(train_df['Survived'].value_counts(), autopct='%1.1f%%')ax[0, 1].set_aspect('equal')ax[0, 1].set_xlabel('Survived')# ax[1, 0]sns.countplot(train_df['Pclass'], ax=ax[1, 0])# ax[1, 1]ax[1, 1].pie(train_df['Pclass'].value_counts(), autopct='%1.1f%%')ax[1, 1].set_aspect('equal')ax[1, 1].set_xlabel('Pclass')plt.tight_layout(h_pad=1) four_subplots_in_one_figure_plt_tight_layout 还有就是hexo插图片时，若用markdown语法，说是文章在首页无法显示图片，点进去后仍可，所以只可采用最好用标签插件语法来实现，例如： Reference Titanic in Kaggle why-is-matplotlib-plotting-my-circles-as-ovals how-to-set-the-labels-size-on-a-pie-chart-in-python set-xlabel-is-in-invalid-in-ax0-0-when-drawing-4-subplots-in-one-plot How-to-insert-image-in-hexo-post]]></content>
      <categories>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>code snippet</tag>
        <tag>EDA</tag>
        <tag>data visualization</tag>
        <tag>matplotlib</tag>
        <tag>seaborn</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stantar 2019有感]]></title>
    <url>%2F2019%2F04%2F22%2FStantar-2019%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[Stantar 2019有感 看了很多个top solution，尤其是金牌区域的。 给我感觉在这个比赛中的几个重要的magic有： frequency coding；在对于匿名数据或者categorical feature上，可以先试着这样做下，一般是会提升local CV之类； fake data；对于training set和testing set中的unique value的数量明显不同，让人怀疑testing set中的数据包含伪造数据。对于testing set中的伪造数据进行删除即可。List of Fake Samples and Public/Private LB split independent feature；利用feature间的相互独立性，在用LightGBM训练时，只对某一特征训练，故有200个lgb classifier再对预测结果进行简单的simple linear blending。a single model using all features vstacked that is enough for a top20 on Private 感受颇深的是对于这些magic，一是自己确实没有通过EDA来发现到，能力有限；二是其实在kernel和discussion中都有多多少少提及到，自己未引起重视又或者不知如何是好。 个人主要感觉还是： 在EDA方面考虑得不够到位，而且可以利用： Local CV和LB的提升上差异来分析是哪里的问题，然后解决并使得Local CV和LB的提升近似。比如此次中，一开始无论local CV提升有多高，LB都会锁在9.001上。而解决到fake data的存在后，local CV提升，LB也会随之提升，使得LB锁在9.001的情况不复存在； 可以根据kernel和discussion区域中，若在新的发布后，上的存在着许多人的大幅度增长，则说明某个kernel或discussion揭露了magic； Model这一块也是有问题，很明显在NN上存在很多问题，尤其是现在去看top solution中开源的NN代码，会存在很多逻辑看不太懂的情况； Parameter Tuning上面也有问题，除了最基本的Grid Search和Random Search外，对于Bayesian optimization没有理解且无法应用出来。Chris这个discussion给了很多inspirations； 对于Data Science这块Coding能力上也存在着问题，不能很流畅的阅读代码逻辑； 这个比赛没有用到Feature Selection, 然而这块也是我的弱项； 在最后如何选取2个the most robust model用于提交到PB上也仍未解决。 不过感觉还是收获了不少，在我上述几方面加强后，还是需要回来reiview Stantar这个比赛的各个solution。 Reference Gold Medal Solutions of Stantar 2019 List of Fake Samples and Public/Private LB split Giba: a single model using all features vstacked that is enough for a top20 on Private Chirs: How do we optimize GBM hyperparameters?]]></content>
      <categories>
        <category>data competition</category>
      </categories>
      <tags>
        <tag>kaggle</tag>
        <tag>data competition</tag>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些学习计划]]></title>
    <url>%2F2019%2F04%2F11%2F%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[学习计划 reivew知识，夯实基础。按着sklearn中User Guide中的6个模块来review一遍文档和其中涉及到的相关知识。不过不会以完整的罗列出来全部内容的形式来做，这样就不符合DRY原则了(笑)，只打算列出各个API中涉及到的不熟悉的知识点的相关知识，又或者是相关链接，自己做一定的归纳总结。 具体来说就是： 理论知识上，在学习到一定程度下，留下学习到的相关链接，总结自己的理解； 代码实现上，在完全不熟悉或者理解不够透彻的情况下，需进行一定量的coding(暂不打算开源)； 主要方向上，主要围绕Supervised Learning, Model selection and evaluation, Dataset transformations, Unsupervised Learning这4个模块进行，除此之外对于XGBoost, LightGBM, CatBoost等Kaggle常见模型进行复习。 估计耗时：1个半月-2个月 继续实战。 具体目标有： 完成对Stantar customer transaction prediction 2019的kernel和discussion的学习，并在别人给出的hints下，自己实现一个top 1 % kernel并开源出来。 在Don't Overfit 和TMDB Box Office Prediction 两个Plaground competition中争取进去Sliver Zone，并在Don't Overfit 结束并学习完后赶紧进入Jigsaw和Earthquake的两个比赛中去。 review Matplotlib和seaborn两个package，根据Kaggle开源kernel熟悉可视化部分。之前这块太弱了，严重影响了EDA的能力。 review Numpy和Pandas两个package，加强数据处理的能力。 估计耗时： 10-15天 持续2个月+ 15-20天 10-15天 Book Reading&amp;Thesis Learing 具体目标有： reivew线代(之前被搁置过)。把UTM-Applied-Linear-Algebra-and-Matrix-Analysis这本书剩下的地方内容+课后带答案的题仔细刷一遍(之前搁置到50%)； 开PRML/ESL/MLAPP的坑。 开Boyd的凸优化的坑。 开NLP的坑。 开Stanford ML相关公开课的坑 估计耗时：2-3天一节，争取1.5个月内review完UTM这本线代书，再考虑开什么坑比较合适... 将这些任务同时进行，争取2个月之内完成这些目标，中间老板可能会有各种任务，最多不要拖过2周。在大部分结束前1-2周，会定制新的计划。]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂谈-为什么要搭一个blog]]></title>
    <url>%2F2019%2F04%2F11%2F%E6%9D%82%E8%B0%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%90%AD%E4%B8%80%E4%B8%AAblog%2F</url>
    <content type="text"><![CDATA[为什么以前不搭一个blog？ 先谈谈为什么一起没这么个念头，主要有以下几点： 不想写些看上去很厉害其实没什么用的东西。 不想写些拾人牙慧的东西。 不想写些随便Google两下，或者看看两眼官方文档就能搞懂的东西。 写blog组织语言起来其实很费时。 而在有的网站上充斥着大量的这类内容，当然不是说没有“金子”在其中，只不过都被“垃圾”掩埋住了，所以在我觉得我不能输出一份没有任何错误的干货下，并不打算输出自己的知识。 为什么现在又搭了一个自己的blog呢？ 无论是学业，还是生活都遭遇了很多糟心事，总得来说以下几个原因： 学习状态一直受挫，到现在为止都很难维持住我以前的最佳状态(每天8-10小时有效学习时间)。导致有些东西学了查，查了用，用了忘，忘了又查的循环之中，低效率甚至无效率学习时间过多。我得找个地方记住这些常常需要review的问题。 刚参加的一场Kaggle比赛，最后比赛结束，结果从Public LB top 7%跌到Private LB top15%。很受打击，感觉自己学的东西很不扎实。用荀子《劝学》中的一句话来说就是“蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。”。我得沉下心来，所以我决定找个地方记录下这个过程。 常常写blog，可以刷下GitHub的contributions次数，让生活充满绿色(笑)，通过这个激励自己。 所以呢？ 所以，可能我大概率可能在未来会输出一些我曾认为的“垃圾“。 Never mind, it's my turn to cut food.]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
